{
  "id": "64df45a3ad4f8719e5355244",
  "title": "Step 46",
  "challengeType": 20,
  "dashedName": "step-46",
  "challengeFiles": [
    {
      "head": "",
      "tail": "",
      "id": "",
      "editableRegionBoundaries": [
        7,
        16
      ],
      "history": [
        "main.py"
      ],
      "name": "main",
      "ext": "py",
      "path": "main.py",
      "fileKey": "mainpy",
      "contents": "NUMBER_OF_DISKS = 4\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\ndef move(n, source, auxiliary, target):\n    if n > 0:\n        # move n - 1 disks from source to auxiliary, so they are out of the way\n        move(n - 1, source, auxiliary, target)\n        \n        # display starting configuration\n        print(rods, '\\n')\n              \n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')",
      "error": null,
      "seed": "NUMBER_OF_DISKS = 4\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\ndef move(n, source, auxiliary, target):\n    if n > 0:\n        # move n - 1 disks from source to auxiliary, so they are out of the way\n        move(n - 1, source, auxiliary, target)\n        \n        # display starting configuration\n        print(rods, '\\n')\n              \n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
    }
  ],
  "solutions": [],
  "assignments": [],
  "tests": [
    {
      "text": "<p>You should remove the last element from the <code>rods[source]</code> list and append it to the <code>rods[target]</code> list before the <code>print</code> call.</p>",
      "testString": "({ test: () => assert.match(code, /move\\(\\s*n\\s*-\\s*1\\s*,\\s*source\\s*,\\s*auxiliary\\s*,\\s*target\\s*\\)\\s+rods\\s*\\[\\s*target\\s*\\]\\s*\\.append\\(\\s*rods\\s*\\[\\s*source\\s*\\]\\s*\\.pop\\(\\s*\\)\\s*\\)/) })"
    }
  ],
  "description": "<section id=\"description\">\n<p>The steps of moving <code>n - 1</code> disks can be broken down further until only a single disk is considered. This will be the first move occurring. After the first move occurs, the following moves are generated by the unwinding of the recursive calls. Keep in mind that in each recursive step the role played by the rods changes between source, target, and auxiliary.</p>\n<p>For now, each recursive call prints the <code>rods</code> dictionary without performing any changes to the lists. Before the <code>print()</code> call, remove the last element from the <code>rods[source]</code> list and append it to the <code>rods[target]</code> list.</p>\n</section>",
  "translationPending": false,
  "block": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
  "hasEditableBoundaries": true,
  "order": 8,
  "superOrder": 7,
  "certification": "scientific-computing-with-python",
  "superBlock": "scientific-computing-with-python",
  "challengeOrder": 45,
  "required": [],
  "helpCategory": "Python",
  "usesMultifileEditor": true,
  "disableLoopProtectTests": false,
  "disableLoopProtectPreview": false
}