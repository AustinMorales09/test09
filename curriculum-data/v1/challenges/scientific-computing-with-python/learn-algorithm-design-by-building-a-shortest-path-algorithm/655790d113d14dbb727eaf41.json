{
  "id": "655790d113d14dbb727eaf41",
  "title": "Step 45",
  "challengeType": 20,
  "dashedName": "step-45",
  "challengeFiles": [
    {
      "head": "",
      "tail": "",
      "id": "",
      "editableRegionBoundaries": [
        12,
        18
      ],
      "history": [
        "main.py"
      ],
      "name": "main",
      "ext": "py",
      "path": "main.py",
      "fileKey": "mainpy",
      "contents": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\ndef shortest_path(graph, start):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n    while unvisited:\n        current = min(unvisited, key=distances.get)\n        for node, distance in graph[current]:\n            if distance + distances[current] < distances[node]:\n                distances[node] = distance + distances[current]\n    print(f'Unvisited: {unvisited}\\nDistances: {distances}\\nPaths: {paths}')\n    \n#shortest_path(my_graph, 'A')",
      "error": null,
      "seed": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\ndef shortest_path(graph, start):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n    while unvisited:\n        current = min(unvisited, key=distances.get)\n        for node, distance in graph[current]:\n            if distance + distances[current] < distances[node]:\n                distances[node] = distance + distances[current]\n    print(f'Unvisited: {unvisited}\\nDistances: {distances}\\nPaths: {paths}')\n    \n#shortest_path(my_graph, 'A')"
    }
  ],
  "solutions": [],
  "assignments": [],
  "tests": [
    {
      "text": "<p>You should create a nested <code>if</code> statements that checks if <code>paths[node][-1]</code> is equal to <code>node</code>. Don't forget to use <code>pass</code>.</p>",
      "testString": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;    \n    assert(function_body.match(/^(\\s*)if.*:.*^\\1(\\s{4})if\\s+paths\\s*\\[\\s*node\\s*\\]\\s*\\[\\s*-\\s*1\\s*\\]\\s*==\\s*node\\s*:\\s*^\\1\\2\\2pass/ms));\n  }\n})"
    }
  ],
  "description": "<section id=\"description\">\n<p>Once the distance to a node is set inside the <code>distances</code> dictionary, you need to keep track of the path to that node, too. If the distance for the node in the processed tuple has been updated, the last item in its path is the node itself.</p>\n<p>Inside your conditional, nest another <code>if</code> statement that triggers when the last element of <code>paths[node]</code> is equal to <code>node</code>. Use <code>pass</code> to fill the <code>if</code> statement body.</p>\n</section>",
  "translationPending": false,
  "block": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
  "hasEditableBoundaries": true,
  "order": 7,
  "superOrder": 7,
  "certification": "scientific-computing-with-python",
  "superBlock": "scientific-computing-with-python",
  "challengeOrder": 44,
  "required": [],
  "helpCategory": "Python",
  "usesMultifileEditor": true,
  "disableLoopProtectTests": false,
  "disableLoopProtectPreview": false
}