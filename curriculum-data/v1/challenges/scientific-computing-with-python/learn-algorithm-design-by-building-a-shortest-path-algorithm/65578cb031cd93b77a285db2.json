{
  "id": "65578cb031cd93b77a285db2",
  "title": "Step 38",
  "challengeType": 20,
  "dashedName": "step-38",
  "challengeFiles": [
    {
      "head": "",
      "tail": "",
      "id": "",
      "editableRegionBoundaries": [
        6,
        16
      ],
      "history": [
        "main.py"
      ],
      "name": "main",
      "ext": "py",
      "path": "main.py",
      "fileKey": "mainpy",
      "contents": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\ndef shortest_path(graph, start):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n    \n    print(f'Unvisited: {unvisited}\\nDistances: {distances}\\nPaths: {paths}')\n    \nshortest_path(my_graph, 'A')",
      "error": null,
      "seed": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\ndef shortest_path(graph, start):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n    \n    print(f'Unvisited: {unvisited}\\nDistances: {distances}\\nPaths: {paths}')\n    \nshortest_path(my_graph, 'A')"
    }
  ],
  "solutions": [],
  "assignments": [],
  "tests": [
    {
      "text": "<p>You should turn your function call into a comment.</p>",
      "testString": "({ test: () => assert.match(code, /#\\s*shortest_path\\s*\\(\\s*my_graph\\s*,\\s*(\"|')A\\1\\s*\\)/) })"
    }
  ],
  "description": "<section id=\"description\">\n<p>Your function is going to explore all the nodes connected to the starting node. It will calculate the shortest paths for all of them. Then, it will remove the starting node from the unvisited nodes.</p>\n<p>Next, the closest neighbor node will be visited and the process will be repeated until all the nodes are visited.</p>\n<p>From now on, you are going to work on the main loop that explores the nodes in the graph. To avoid issues with running an infinite loop during the algorithm development, turn your function call into a comment.</p>\n</section>",
  "translationPending": false,
  "block": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
  "hasEditableBoundaries": true,
  "order": 7,
  "superOrder": 7,
  "certification": "scientific-computing-with-python",
  "superBlock": "scientific-computing-with-python",
  "challengeOrder": 37,
  "required": [],
  "helpCategory": "Python",
  "usesMultifileEditor": true,
  "disableLoopProtectTests": false,
  "disableLoopProtectPreview": false
}