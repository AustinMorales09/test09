{
  "id": "657db4cb77190e33a20e852a",
  "title": "Step 69",
  "challengeType": 20,
  "dashedName": "step-69",
  "challengeFiles": [
    {
      "head": "",
      "tail": "",
      "id": "",
      "editableRegionBoundaries": [
        36,
        39
      ],
      "history": [
        "main.py"
      ],
      "name": "main",
      "ext": "py",
      "path": "main.py",
      "fileKey": "mainpy",
      "contents": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length=16, nums=1, special_chars=1, uppercase=1, lowercase=1):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, r'\\d'),\n            (special_chars, fr'[{symbols}]'),\n            (uppercase, r'[A-Z]'),\n            (lowercase, r'[a-z]')\n        ]\n\n        # Check constraints        \n        if all(\n            constraint <= len(re.findall(pattern, password))\n            for constraint, pattern in constraints\n        ):\n            break\n    \n    return password\n    \nnew_password = generate_password(nums=1, length=8, special_chars=1, uppercase=1, lowercase=1)\nprint(new_password)",
      "error": null,
      "seed": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length=16, nums=1, special_chars=1, uppercase=1, lowercase=1):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, r'\\d'),\n            (special_chars, fr'[{symbols}]'),\n            (uppercase, r'[A-Z]'),\n            (lowercase, r'[a-z]')\n        ]\n\n        # Check constraints        \n        if all(\n            constraint <= len(re.findall(pattern, password))\n            for constraint, pattern in constraints\n        ):\n            break\n    \n    return password\n    \nnew_password = generate_password(nums=1, length=8, special_chars=1, uppercase=1, lowercase=1)\nprint(new_password)"
    }
  ],
  "solutions": [],
  "assignments": [],
  "tests": [
    {
      "text": "<p>You should pass only <code>length=8</code> to your <code>generate_password()</code> call.</p>",
      "testString": "({ test: () => assert.match(code, /^new_password\\s*=\\s*generate_password\\s*\\(\\s*length\\s*=\\s*8\\s*\\)/m) })"
    }
  ],
  "description": "<section id=\"description\">\n<p>When you combine default arguments with keyword arguments, you are able to explicitly pass fewer arguments than those required by the function. The arguments that are not explicitly passed to the function call will take their default values.</p>\n<p>Modify your <code>generate_password()</code> call to take only <code>length=8</code>.</p>\n</section>",
  "translationPending": false,
  "block": "learn-regular-expressions-by-building-a-password-generator",
  "hasEditableBoundaries": true,
  "order": 6,
  "superOrder": 7,
  "certification": "scientific-computing-with-python",
  "superBlock": "scientific-computing-with-python",
  "challengeOrder": 68,
  "required": [],
  "helpCategory": "Python",
  "usesMultifileEditor": true,
  "disableLoopProtectTests": false,
  "disableLoopProtectPreview": false
}