{
  "id": "587d7db6367417b2b2512b9b",
  "title": "Find Characters with Lazy Matching",
  "challengeType": 1,
  "forumTopicId": 301341,
  "dashedName": "find-characters-with-lazy-matching",
  "challengeFiles": [
    {
      "head": "",
      "tail": "",
      "id": "",
      "editableRegionBoundaries": [],
      "history": [
        "script.js"
      ],
      "name": "script",
      "ext": "js",
      "path": "script.js",
      "fileKey": "scriptjs",
      "contents": "let text = \"<h1>Winter is coming</h1>\";\nlet myRegex = /<.*>/; // Change this line\nlet result = text.match(myRegex);",
      "error": null,
      "seed": "let text = \"<h1>Winter is coming</h1>\";\nlet myRegex = /<.*>/; // Change this line\nlet result = text.match(myRegex);"
    }
  ],
  "solutions": [
    [
      {
        "head": "",
        "tail": "",
        "id": "",
        "history": [
          "script.js"
        ],
        "name": "script",
        "ext": "js",
        "path": "script.js",
        "fileKey": "scriptjs",
        "contents": "let text = \"<h1>Winter is coming</h1>\";\nlet myRegex = /<.*?>/; // Change this line\nlet result = text.match(myRegex);",
        "error": null,
        "seed": "let text = \"<h1>Winter is coming</h1>\";\nlet myRegex = /<.*?>/; // Change this line\nlet result = text.match(myRegex);"
      }
    ]
  ],
  "assignments": [],
  "tests": [
    {
      "text": "<p>The <code>result</code> variable should be an array with <code>&#x3C;h1></code> in it</p>",
      "testString": "assert(result[0] == '<h1>');"
    },
    {
      "text": "<p><code>myRegex</code> should use lazy matching</p>",
      "testString": "assert(/[^\\\\][\\*\\+\\?]\\?/.test(myRegex));"
    },
    {
      "text": "<p><code>myRegex</code> should not include the string <code>h1</code></p>",
      "testString": "assert(!myRegex.source.match('h1'));"
    }
  ],
  "description": "<section id=\"description\">\n<p>In regular expressions, a <dfn>greedy</dfn> match finds the longest possible part of a string that fits the regex pattern and returns it as a match. The alternative is called a <dfn>lazy</dfn> match, which finds the smallest possible part of the string that satisfies the regex pattern.</p>\n<p>You can apply the regex <code>/t[a-z]*i/</code> to the string <code>\"titanic\"</code>. This regex is basically a pattern that starts with <code>t</code>, ends with <code>i</code>, and has some letters in between.</p>\n<p>Regular expressions are by default greedy, so the match would return <code>[\"titani\"]</code>. It finds the largest sub-string possible to fit the pattern.</p>\n<p>However, you can use the <code>?</code> character to change it to lazy matching. <code>\"titanic\"</code> matched against the adjusted regex of <code>/t[a-z]*?i/</code> returns <code>[\"ti\"]</code>.</p>\n<p><strong>Note:</strong> Parsing HTML with regular expressions should be avoided, but pattern matching an HTML string with regular expressions is completely fine.</p>\n</section>",
  "instructions": "<section id=\"instructions\">\n<p>Fix the regex <code>/&#x3C;.*>/</code> to return the HTML tag <code>&#x3C;h1></code> and not the text <code>\"&#x3C;h1>Winter is coming&#x3C;/h1>\"</code>. Remember the wildcard <code>.</code> in a regular expression matches any character.</p>\n</section>",
  "translationPending": false,
  "block": "regular-expressions",
  "hasEditableBoundaries": false,
  "order": 2,
  "superOrder": 19,
  "certification": "javascript-algorithms-and-data-structures",
  "superBlock": "javascript-algorithms-and-data-structures",
  "challengeOrder": 13,
  "required": [],
  "helpCategory": "JavaScript",
  "usesMultifileEditor": false,
  "disableLoopProtectTests": false,
  "disableLoopProtectPreview": false
}