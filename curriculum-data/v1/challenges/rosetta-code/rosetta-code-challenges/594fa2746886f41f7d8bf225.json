{
  "id": "594fa2746886f41f7d8bf225",
  "title": "Topological sort",
  "challengeType": 1,
  "forumTopicId": 302340,
  "dashedName": "topological-sort",
  "challengeFiles": [
    {
      "head": "",
      "tail": "const libsSimple =\n  `aaa bbb\n  bbb`;\n\nconst libsVHDL =\n  `des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\n  dw01             ieee dw01 dware gtech\n  dw02             ieee dw02 dware\n  dw03             std synopsys dware dw03 dw02 dw01 ieee gtech\n  dw04             dw04 ieee dw01 dware gtech\n  dw05             dw05 ieee dware\n  dw06             dw06 ieee dware\n  dw07             ieee dware\n  dware            ieee dware\n  gtech            ieee gtech\n  ramlib           std ieee\n  std_cell_lib     ieee std_cell_lib\n  synopsys`;\n\nconst libsCustom =\n  `a b c d\n  b c d\n  d c\n  c base\n  base`;\n\nconst libsUnorderable =\n  `TestLib Base MainLib\n  MainLib TestLib\n  Base`;",
      "id": "",
      "editableRegionBoundaries": [],
      "history": [
        "script.js"
      ],
      "name": "script",
      "ext": "js",
      "path": "script.js",
      "fileKey": "scriptjs",
      "contents": "function topologicalSort(libs) {\n\n  return true;\n}",
      "error": null,
      "seed": "function topologicalSort(libs) {\n\n  return true;\n}"
    }
  ],
  "solutions": [
    [
      {
        "head": "",
        "tail": "",
        "id": "",
        "history": [
          "script.js"
        ],
        "name": "script",
        "ext": "js",
        "path": "script.js",
        "fileKey": "scriptjs",
        "contents": "function topologicalSort(libs) {\n  // A map of the input data, with the keys as the packages, and the values as\n  // and array of packages on which it depends.\n  const D = libs\n    .split('\\n')\n    .map(e => e.split(' ').filter(ep => ep !== ''))\n    .reduce((p, c) =>\n      p.set(c[0], c.filter((e, i) => (i > 0 && e !== c[0] ? e : null))), new Map());\n  [].concat(...D.values()).forEach(e => {\n    D.set(e, D.get(e) || []);\n  });\n\n  // The above map rotated so that it represents a DAG of the form\n  // Map {\n  //    A => [ A, B, C],\n  //    B => [C],\n  //    C => []\n  // }\n  // where each key represents a node, and the array contains the edges.\n  const G = [...D.keys()].reduce((p, c) =>\n    p.set(\n      c,\n      [...D.keys()].filter(e => D.get(e).includes(c))),\n    new Map()\n  );\n\n  // An array of leaf nodes; nodes with 0 in degrees.\n  const Q = [...D.keys()].filter(e => D.get(e).length === 0);\n\n  // The result array.\n  const S = [];\n  while (Q.length) {\n    const u = Q.pop();\n    S.push(u);\n    G.get(u).forEach(v => {\n      D.set(v, D.get(v).filter(e => e !== u));\n      if (D.get(v).length === 0) {\n        Q.push(v);\n      }\n    });\n  }\n\n  return S;\n}",
        "error": null,
        "seed": "function topologicalSort(libs) {\n  // A map of the input data, with the keys as the packages, and the values as\n  // and array of packages on which it depends.\n  const D = libs\n    .split('\\n')\n    .map(e => e.split(' ').filter(ep => ep !== ''))\n    .reduce((p, c) =>\n      p.set(c[0], c.filter((e, i) => (i > 0 && e !== c[0] ? e : null))), new Map());\n  [].concat(...D.values()).forEach(e => {\n    D.set(e, D.get(e) || []);\n  });\n\n  // The above map rotated so that it represents a DAG of the form\n  // Map {\n  //    A => [ A, B, C],\n  //    B => [C],\n  //    C => []\n  // }\n  // where each key represents a node, and the array contains the edges.\n  const G = [...D.keys()].reduce((p, c) =>\n    p.set(\n      c,\n      [...D.keys()].filter(e => D.get(e).includes(c))),\n    new Map()\n  );\n\n  // An array of leaf nodes; nodes with 0 in degrees.\n  const Q = [...D.keys()].filter(e => D.get(e).length === 0);\n\n  // The result array.\n  const S = [];\n  while (Q.length) {\n    const u = Q.pop();\n    S.push(u);\n    G.get(u).forEach(v => {\n      D.set(v, D.get(v).filter(e => e !== u));\n      if (D.get(v).length === 0) {\n        Q.push(v);\n      }\n    });\n  }\n\n  return S;\n}"
      }
    ]
  ],
  "assignments": [],
  "tests": [
    {
      "text": "<p><code>topologicalSort</code> should be a function.</p>",
      "testString": "assert(typeof topologicalSort === 'function');"
    },
    {
      "text": "<p><code>topologicalSort(libsSimple)</code> should return an array.</p>",
      "testString": "assert(Array.isArray(topologicalSort(libsSimple)));"
    },
    {
      "text": "<p><code>topologicalSort(libsSimple)</code> should return <code>['bbb', 'aaa']</code>.</p>",
      "testString": "assert.deepEqual(topologicalSort(libsSimple), ['bbb', 'aaa']);"
    },
    {
      "text": "<p><code>topologicalSort(libsVHDL)</code> should return <code>['ieee', 'std_cell_lib', 'gtech', 'dware', 'dw07', 'dw06', 'dw05', 'dw02', 'dw01', 'dw04', 'std', 'ramlib', 'synopsys', 'dw03', 'des_system_lib']</code>.</p>",
      "testString": "assert.deepEqual(topologicalSort(libsVHDL), ['ieee', 'std_cell_lib', 'gtech', 'dware', 'dw07', 'dw06', 'dw05', 'dw02', 'dw01', 'dw04', 'std', 'ramlib', 'synopsys', 'dw03', 'des_system_lib']);"
    },
    {
      "text": "<p><code>topologicalSort(libsCustom)</code> should return <code>['base', 'c', 'd', 'b', 'a']</code>.</p>",
      "testString": "assert.deepEqual(topologicalSort(libsCustom), ['base', 'c', 'd', 'b', 'a']);"
    },
    {
      "text": "<p><code>topologicalSort</code> should ignore unorderable dependencies.</p>",
      "testString": "assert.deepEqual(topologicalSort(libsUnorderable), ['Base']);"
    }
  ],
  "description": "<section id=\"description\">\n<p>Given a mapping between items, and items they depend on, a topological sort orders items so that no item precedes an item it depends upon. There are two popular algorithms for topological sorting: Kahn's (1962) topological sort and depth-first search.</p>\n</section>",
  "instructions": "<section id=\"instructions\">\n<p>Write a function that will return a list with valid compile order of libraries from their dependencies.</p>\n<ul>\n<li>Assume library names are single words.</li>\n<li>Items mentioned as only dependents have no dependents of their own, but their order of compiling must be given.</li>\n<li>Any self dependencies should be ignored.</li>\n<li>Any un-orderable dependencies should be ignored.</li>\n</ul>\n<p>Use the following data as an example:</p>\n<pre>\nLIBRARY          LIBRARY DEPENDENCIES\n=======          ====================\ndes_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\ndw01             ieee dw01 dware gtech\ndw02             ieee dw02 dware\ndw03             std synopsys dware dw03 dw02 dw01 ieee gtech\ndw04             dw04 ieee dw01 dware gtech\ndw05             dw05 ieee dware\ndw06             dw06 ieee dware\ndw07             ieee dware\ndware            ieee dware\ngtech            ieee gtech\nramlib           std ieee\nstd_cell_lib     ieee std_cell_lib\nsynopsys\n</pre>\n<p>The compiling of a library in the VHDL language has the constraint that a library must be compiled after any library it depends on. The above data would be un-orderable if, for example, <code>dw04</code> is added to the list of dependencies of <code>dw01</code>.</p>\n<p>The input of the function will be a multiline string, each line will consist of the name of the library, followed by its dependencies (if exist).</p>\n<p>For example:</p>\n<pre><code class=\"language-js\">const libsSimple =\n  `aaa bbb\n  bbb`;\n</code></pre>\n</section>",
  "translationPending": false,
  "block": "rosetta-code-challenges",
  "hasEditableBoundaries": false,
  "order": 0,
  "superOrder": 17,
  "certification": "rosetta-code",
  "superBlock": "rosetta-code",
  "challengeOrder": 149,
  "required": [],
  "helpCategory": "Rosetta",
  "usesMultifileEditor": false,
  "disableLoopProtectTests": true,
  "disableLoopProtectPreview": false
}