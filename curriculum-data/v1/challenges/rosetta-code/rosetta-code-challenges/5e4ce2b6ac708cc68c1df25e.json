{
  "id": "5e4ce2b6ac708cc68c1df25e",
  "title": "Last letter-first letter",
  "challengeType": 1,
  "forumTopicId": 385256,
  "dashedName": "last-letter-first-letter",
  "challengeFiles": [
    {
      "head": "",
      "tail": "",
      "id": "",
      "editableRegionBoundaries": [],
      "history": [
        "script.js"
      ],
      "name": "script",
      "ext": "js",
      "path": "script.js",
      "fileKey": "scriptjs",
      "contents": "function findLongestChain(items) {\n\n}",
      "error": null,
      "seed": "function findLongestChain(items) {\n\n}"
    }
  ],
  "solutions": [
    [
      {
        "head": "",
        "tail": "",
        "id": "",
        "history": [
          "script.js"
        ],
        "name": "script",
        "ext": "js",
        "path": "script.js",
        "fileKey": "scriptjs",
        "contents": "function findLongestChain(items) {\n  function Ref(index, first_char, last_char) {\n    this.index = index;\n    this.first_char = first_char;\n    this.last_char = last_char;\n  }\n\n  var items_len = items.length\n  var refs_len = items_len;\n  var refs = []\n\n  // enough space for all items\n  var longest_path_refs_len = 0;\n  var longest_path_refs = new Array(items_len);\n\n  function search(curr_len) {\n    if (curr_len > longest_path_refs_len) {\n      longest_path_refs_len = curr_len;\n\n      for (var i = 0; i < curr_len; i++) {\n        longest_path_refs[i] = refs[i];\n      }\n    }\n\n    // recursive search\n    var last_char = refs[curr_len - 1].last_char;\n    for (var i = curr_len; i < refs_len; i++)\n      if (refs[i].first_char == last_char) {\n        var aux = refs[curr_len];\n        refs[curr_len] = refs[i];\n        refs[i] = aux;\n        search(curr_len + 1);\n        refs[i] = refs[curr_len];\n        refs[curr_len] = aux;\n      }\n  }\n\n  for (var i = 0; i < items_len; i++) {\n    var itemsi_len = items[i].length;\n    refs.push(new Ref(i, items[i][0], items[i][itemsi_len - 1]));\n  }\n\n  // try each item as possible start\n  for (var i = 0; i < items_len; i++) {\n    var aux = refs[0];\n    refs[0] = refs[i];\n    refs[i] = aux;\n    search(1);\n    refs[i] = refs[0];\n    refs[0] = aux;\n  }\n\n  var longest_path_len = longest_path_refs_len;\n  var longest_path = new Array(longest_path_len);\n\n  for (var i = 0; i < longest_path_len; i++)\n    longest_path[i] = items[longest_path_refs[i].index];\n\n  return longest_path;\n}",
        "error": null,
        "seed": "function findLongestChain(items) {\n  function Ref(index, first_char, last_char) {\n    this.index = index;\n    this.first_char = first_char;\n    this.last_char = last_char;\n  }\n\n  var items_len = items.length\n  var refs_len = items_len;\n  var refs = []\n\n  // enough space for all items\n  var longest_path_refs_len = 0;\n  var longest_path_refs = new Array(items_len);\n\n  function search(curr_len) {\n    if (curr_len > longest_path_refs_len) {\n      longest_path_refs_len = curr_len;\n\n      for (var i = 0; i < curr_len; i++) {\n        longest_path_refs[i] = refs[i];\n      }\n    }\n\n    // recursive search\n    var last_char = refs[curr_len - 1].last_char;\n    for (var i = curr_len; i < refs_len; i++)\n      if (refs[i].first_char == last_char) {\n        var aux = refs[curr_len];\n        refs[curr_len] = refs[i];\n        refs[i] = aux;\n        search(curr_len + 1);\n        refs[i] = refs[curr_len];\n        refs[curr_len] = aux;\n      }\n  }\n\n  for (var i = 0; i < items_len; i++) {\n    var itemsi_len = items[i].length;\n    refs.push(new Ref(i, items[i][0], items[i][itemsi_len - 1]));\n  }\n\n  // try each item as possible start\n  for (var i = 0; i < items_len; i++) {\n    var aux = refs[0];\n    refs[0] = refs[i];\n    refs[i] = aux;\n    search(1);\n    refs[i] = refs[0];\n    refs[0] = aux;\n  }\n\n  var longest_path_len = longest_path_refs_len;\n  var longest_path = new Array(longest_path_len);\n\n  for (var i = 0; i < longest_path_len; i++)\n    longest_path[i] = items[longest_path_refs[i].index];\n\n  return longest_path;\n}"
      }
    ]
  ],
  "assignments": [],
  "tests": [
    {
      "text": "<p><code>findLongestChain</code> should be a function.</p>",
      "testString": "assert(typeof findLongestChain == 'function');"
    },
    {
      "text": "<p><code>findLongestChain([\"certain\", \"each\", \"game\", \"involves\", \"starting\", \"with\", \"word\"])</code> should return an array.</p>",
      "testString": "assert(\n  Array.isArray(\n    findLongestChain([\n      'certain',\n      'each',\n      'game',\n      'involves',\n      'starting',\n      'with',\n      'word'\n    ])\n  )\n);"
    },
    {
      "text": "<p><code>findLongestChain([\"certain\", \"each\", \"game\", \"involves\", \"starting\", \"with\", \"word\"])</code> should return <code>[\"involves\", \"starting\", \"game\", \"each\"]</code>.</p>",
      "testString": "assert.deepEqual(\n  findLongestChain([\n    'certain',\n    'each',\n    'game',\n    'involves',\n    'starting',\n    'with',\n    'word'\n  ]),\n  ['involves', 'starting', 'game', 'each']\n);"
    },
    {
      "text": "<p><code>findLongestChain([\"audino\", \"bagon\", \"kangaskhan\", \"banette\", \"bidoof\", \"braviary\", \"exeggcute\", \"yamask\"])</code> should return <code>[\"braviary\", \"yamask\", \"kangaskhan\"]</code></p>",
      "testString": "assert.deepEqual(\n  findLongestChain([\n    'audino',\n    'bagon',\n    'kangaskhan',\n    'banette',\n    'bidoof',\n    'braviary',\n    'exeggcute',\n    'yamask'\n  ]),\n  ['braviary', 'yamask', 'kangaskhan']\n);"
    },
    {
      "text": "<p><code>findLongestChain([\"harp\", \"poliwrath\", \"poochyena\", \"porygon2\", \"porygonz\", \"archana\"])</code> should return <code>[\"poliwrath\", \"harp\", \"poochyena\", \"archana\"]</code>.</p>",
      "testString": "assert.deepEqual(\n  findLongestChain([\n    'harp',\n    'poliwrath',\n    'poochyena',\n    'porygon2',\n    'porygonz',\n    'archana'\n  ]),\n  ['poliwrath', 'harp', 'poochyena', 'archana']\n);"
    },
    {
      "text": "<p><code>findLongestChain([\"scolipede\", \"elephant\", \"zeaking\", \"sealeo\", \"silcoon\", \"tigers\"])</code> should return <code>[\"scolipede\", \"elephant\", \"tigers\", \"sealeo\"]</code>.</p>",
      "testString": "assert.deepEqual(\n  findLongestChain([\n    'scolipede',\n    'elephant',\n    'zeaking',\n    'sealeo',\n    'silcoon',\n    'tigers'\n  ]),\n  ['scolipede', 'elephant', 'tigers', 'sealeo']\n);"
    },
    {
      "text": "<p><code>findLongestChain([\"loudred\", \"lumineon\", \"lunatone\", \"machamp\", \"magnezone\", \"nosepass\", \"petilil\", \"pidgeotto\", \"pikachu\"])</code> should return <code>[\"machamp\", \"petilil\", \"lumineon\", \"nosepass\"]</code>.</p>",
      "testString": "assert.deepEqual(\n  findLongestChain([\n    'loudred',\n    'lumineon',\n    'lunatone',\n    'machamp',\n    'magnezone',\n    'nosepass',\n    'petilil',\n    'pidgeotto',\n    'pikachu'\n  ]),\n  ['machamp', 'petilil', 'lumineon', 'nosepass']\n);"
    }
  ],
  "description": "<section id=\"description\">\n<p>A certain children's game involves starting with a word in a particular category. Each participant in turn says a word, but that word must begin with the final letter of the previous word. Once a word has been given, it cannot be repeated. If an opponent cannot give a word in the category, they fall out of the game.</p>\n<p>For example, with \"animals\" as the category,</p>\n<pre>Child 1: dog\nChild 2: goldfish\nChild 1: hippopotamus\nChild 2: snake\n...\n</pre>\n</section>",
  "instructions": "<section id=\"instructions\">\n<p>Write a function that takes an input array of words. The function should return an array of words where the first letter of each word is the same as the last letter of the previous word. Only use the words in the input array, and once a word is used it cannot be repeated. The words in the return array should be selected and sequenced so that that its length is maximized.</p>\n</section>",
  "translationPending": false,
  "block": "rosetta-code-challenges",
  "hasEditableBoundaries": false,
  "order": 0,
  "superOrder": 17,
  "certification": "rosetta-code",
  "superBlock": "rosetta-code",
  "challengeOrder": 85,
  "required": [],
  "helpCategory": "Rosetta",
  "usesMultifileEditor": false,
  "disableLoopProtectTests": true,
  "disableLoopProtectPreview": false
}