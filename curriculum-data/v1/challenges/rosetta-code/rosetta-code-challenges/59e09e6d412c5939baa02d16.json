{
  "id": "59e09e6d412c5939baa02d16",
  "title": "Execute a Markov algorithm",
  "challengeType": 1,
  "forumTopicId": 302260,
  "dashedName": "execute-a-markov-algorithm",
  "challengeFiles": [
    {
      "head": "",
      "tail": "\nlet rules=[[\"A -> apple\",\"B -> bag\",\"S -> shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\n            [\"A -> apple\",\"B -> bag\",\"S -> .shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\n            [\"A -> apple\",\"WWWW -> with\",\"Bgage -> ->.*\",\"B -> bag\",\"->.* -> money\",\"W -> WW\",\"S -> .shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\n            [\"_+1 -> _1+\",\"1+1 -> 11+\",\"1! -> !1\",\",! -> !+\",\"_! -> _\",\"1*1 -> x,@y\",\"1x -> xX\",\"X, -> 1,1\",\"X1 -> 1X\",\"_x -> _X\",\",x -> ,X\",\"y1 -> 1y\",\"y_ -> _\",\"1@1 -> x,@y\",\"1@_ -> @_\",\",@_ -> !_\",\"++ -> +\",\"_1 -> 1\",\"1+_ -> 1\",\"_+_ -> \"],\n            [\"A0 -> 1B\",\"0A1 -> C01\",\"1A1 -> C11\",\"0B0 -> A01\",\"1B0 -> A11\",\"B1 -> 1B\",\"0C0 -> B01\",\"1C0 -> B11\",\"0C1 -> H01\",\"1C1 -> H11\"]];\nlet datas=[\"I bought a B of As from T S.\",\n            \"I bought a B of As from T S.\",\n            \"I bought a B of As W my Bgage from T S.\",\n            \"_1111*11111_\",\n            \"000000A000000\"];\nlet outputs=[\"I bought a bag of apples from my brother.\",\n            \"I bought a bag of apples from T shop.\",\n            \"I bought a bag of apples with my money from T shop.\",\n            \"11111111111111111111\",\n            \"00011H1111000\"]\n",
      "id": "",
      "editableRegionBoundaries": [],
      "history": [
        "script.js"
      ],
      "name": "script",
      "ext": "js",
      "path": "script.js",
      "fileKey": "scriptjs",
      "contents": "function markov(rules,data) {\n\n}",
      "error": null,
      "seed": "function markov(rules,data) {\n\n}"
    }
  ],
  "solutions": [
    [
      {
        "head": "",
        "tail": "",
        "id": "",
        "history": [
          "script.js"
        ],
        "name": "script",
        "ext": "js",
        "path": "script.js",
        "fileKey": "scriptjs",
        "contents": "function markov(rules,data) {\n    let pattern = new RegExp(\"^([^#]*?)\\\\s+->\\\\s+(\\\\.?)(.*)\");\n    let origData = data;\n\n    let captures = [];\n\n    rules.forEach(function(rule){\n        let m = pattern.exec(rule);\n        for (let j = 0; j < m.length; j++)\n            m[j] = m[j + 1];\n        captures.push(m);\n    });\n\n    data = origData;\n    let copy = data;\n    for (let j = 0; j < captures.length; j++) {\n        let c = captures[j];\n        data = data.replace(c[0], c[2]);\n        if (c[1]==\".\")\n            break;\n        if (data!=copy) {\n            j = -1;\n            copy = data;\n        }\n    }\n    return data;\n}",
        "error": null,
        "seed": "function markov(rules,data) {\n    let pattern = new RegExp(\"^([^#]*?)\\\\s+->\\\\s+(\\\\.?)(.*)\");\n    let origData = data;\n\n    let captures = [];\n\n    rules.forEach(function(rule){\n        let m = pattern.exec(rule);\n        for (let j = 0; j < m.length; j++)\n            m[j] = m[j + 1];\n        captures.push(m);\n    });\n\n    data = origData;\n    let copy = data;\n    for (let j = 0; j < captures.length; j++) {\n        let c = captures[j];\n        data = data.replace(c[0], c[2]);\n        if (c[1]==\".\")\n            break;\n        if (data!=copy) {\n            j = -1;\n            copy = data;\n        }\n    }\n    return data;\n}"
      }
    ]
  ],
  "assignments": [],
  "tests": [
    {
      "text": "<p><code>markov</code> should be a function.</p>",
      "testString": "assert(typeof markov === 'function');"
    },
    {
      "text": "<p><code>markov([\"A -> apple\",\"B -> bag\",\"S -> shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\"I bought a B of As from T S.\")</code> should return the string <code>I bought a bag of apples from my brother.</code>.</p>",
      "testString": "assert.deepEqual(markov(rules[0], datas[0]), outputs[0]);"
    },
    {
      "text": "<p><code>markov([\"A -> apple\",\"B -> bag\",\"S -> .shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\"I bought a B of As from T S.\")</code> should return the string <code>I bought a bag of apples from T shop.</code>.</p>",
      "testString": "assert.deepEqual(markov(rules[1], datas[1]), outputs[1]);"
    },
    {
      "text": "<p><code>markov([\"A -> apple\",\"WWWW -> with\",\"Bgage -> ->.*\",\"B -> bag\",\"->.* -> money\",\"W -> WW\",\"S -> .shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\"I bought a B of As W my Bgage from T S.\")</code> should return the string <code>I bought a bag of apples with my money from T shop.</code>.</p>",
      "testString": "assert.deepEqual(markov(rules[2], datas[2]), outputs[2]);"
    },
    {
      "text": "<p><code>markov([\"_+1 -> _1+\",\"1+1 -> 11+\",\"1! -> !1\",\",! -> !+\",\"_! -> _\",\"1*1 -> x,@y\",\"1x -> xX\",\"X, -> 1,1\",\"X1 -> 1X\",\"_x -> _X\",\",x -> ,X\",\"y1 -> 1y\",\"y_ -> _\",\"1@1 -> x,@y\",\"1@_ -> @_\",\",@_ -> !_\",\"++ -> +\",\"_1 -> 1\",\"1+_ -> 1\",\"_+_ -> \"],\"_1111*11111_\")</code> should return the string <code>11111111111111111111</code>.</p>",
      "testString": "assert.deepEqual(markov(rules[3], datas[3]), outputs[3]);"
    },
    {
      "text": "<p><code>markov([\"A0 -> 1B\",\"0A1 -> C01\",\"1A1 -> C11\",\"0B0 -> A01\",\"1B0 -> A11\",\"B1 -> 1B\",\"0C0 -> B01\",\"1C0 -> B11\",\"0C1 -> H01\",\"1C1 -> H11\"],\"\")</code> should return the string <code>00011H1111000</code>.</p>",
      "testString": "assert.deepEqual(markov(rules[4], datas[4]), outputs[4]);"
    }
  ],
  "description": "<section id=\"description\">\n<p>Markov Concepts are used in machine learning, because of its simple approach in data manipulation. With a set number of <code>rules</code> you can manipulate given <code>data</code> to create a desired <code>output</code>.</p>\n<p>We have added in the background:</p>\n<p>The <code>rules</code> in the form of nested array, and the <code>data</code> in the form of array, too. And the desired <code>outputs</code>.</p>\n<p>The <code>rules</code>:</p>\n<pre><code class=\"language-js\">let rules=[\n[\n\"A -> apple\",\"B -> bag\",\"S -> shop\",\"T -> the\",\n\"the shop -> my brother\",\"a never used -> .terminating rule\"\n],\n\n[\n \"A -> apple\",\"B -> bag\",\"S -> .shop\",\"T -> the\",\n \"the shop -> my brother\",\"a never used -> .terminating rule\"\n],\n\n[\n \"A -> apple\",\"WWWW -> with\",\"Bgage -> ->.*\",\"B -> bag\",\n \"->.* -> money\",\"W -> WW\",\"S -> .shop\",\"T -> the\",\n \"the shop -> my brother\",\"a never used -> .terminating rule\"\n],\n\n[\n \"_+1 -> _1+\",\"1+1 -> 11+\",\"1! -> !1\",\",! -> !+\",\"_! -> _\",\"1*1 -> x,@y\",\"1x -> xX\",\n \"X, -> 1,1\",\"X1 -> 1X\",\"_x -> _X\",\",x -> ,X\",\"y1 -> 1y\",\"y_ -> _\",\"1@1 -> x,@y\",\n \"1@_ -> @_\",\",@_ -> !_\",\"++ -> +\",\"_1 -> 1\",\"1+_ -> 1\",\"_+_ -> \"\n],\n\n[\n\"A0 -> 1B\",\"0A1 -> C01\",\"1A1 -> C11\",\"0B0 -> A01\",\"1B0 -> A11\",\n\"B1 -> 1B\",\"0C0 -> B01\",\"1C0 -> B11\",\"0C1 -> H01\",\"1C1 -> H11\"\n]\n\n];\n</code></pre>\n<p>The <code>data</code>:</p>\n<pre><code class=\"language-js\">let data=[\n        \"I bought a B of As from T S.\",\n        \"I bought a B of As from T S.\",\n        \"I bought a B of As W my Bgage from T S.\",\n        \"_1111*11111_\",\n        \"000000A000000\"\n        ];\n</code></pre>\n<p>The <code>outputs</code>:</p>\n<pre><code class=\"language-js\">let outputs=[\n    \"I bought a bag of apples from my brother.\",\n    \"I bought a bag of apples from T shop.\",\n    \"I bought a bag of apples with my money from T shop.\",\n    \"11111111111111111111\",\n    \"00011H1111000\"\n    ]\n</code></pre>\n<p>Using Markov Algorithm, change the <code>data</code> into the desired <code>outputs</code> using the <code>rules</code> provided for you.</p>\n</section>",
  "translationPending": false,
  "block": "rosetta-code-challenges",
  "hasEditableBoundaries": false,
  "order": 0,
  "superOrder": 17,
  "certification": "rosetta-code",
  "superBlock": "rosetta-code",
  "challengeOrder": 42,
  "required": [],
  "helpCategory": "Rosetta",
  "usesMultifileEditor": false,
  "disableLoopProtectTests": true,
  "disableLoopProtectPreview": false
}