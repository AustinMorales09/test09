{
  "id": "5a23c84252665b21eecc7ecb",
  "title": "K-d tree",
  "challengeType": 1,
  "forumTopicId": 302295,
  "dashedName": "k-d-tree",
  "challengeFiles": [
    {
      "head": "",
      "tail": "",
      "id": "",
      "editableRegionBoundaries": [],
      "history": [
        "script.js"
      ],
      "name": "script",
      "ext": "js",
      "path": "script.js",
      "fileKey": "scriptjs",
      "contents": "function kdNN(fpoints, fpoint) {\n\n}",
      "error": null,
      "seed": "function kdNN(fpoints, fpoint) {\n\n}"
    }
  ],
  "solutions": [
    [
      {
        "head": "",
        "tail": "",
        "id": "",
        "history": [
          "script.js"
        ],
        "name": "script",
        "ext": "js",
        "path": "script.js",
        "fileKey": "scriptjs",
        "contents": "function kdNN(fpoints, fpoint) {\n  function Node(obj, dimension, parent) {\n    this.obj = obj;\n    this.left = null;\n    this.right = null;\n    this.parent = parent;\n    this.dimension = dimension;\n  }\n\n  function kdTree(points, metric, dimensions) {\n    var self = this;\n\n    function buildTree(points, depth, parent) {\n      var dim = depth % dimensions.length,\n        median,\n        node;\n\n      if (points.length === 0) {\n        return null;\n      }\n      if (points.length === 1) {\n        return new Node(points[0], dim, parent);\n      }\n\n      points.sort(function(a, b) {\n        return a[dimensions[dim]] - b[dimensions[dim]];\n      });\n\n      median = Math.floor(points.length / 2);\n      node = new Node(points[median], dim, parent);\n      node.left = buildTree(points.slice(0, median), depth + 1, node);\n      node.right = buildTree(points.slice(median + 1), depth + 1, node);\n\n      return node;\n    }\n\n    this.root = buildTree(points, 0, null);\n\n    this.insert = function(point) {\n      function innerSearch(node, parent) {\n        if (node === null) {\n          return parent;\n        }\n\n        var dimension = dimensions[node.dimension];\n        if (point[dimension] < node.obj[dimension]) {\n          return innerSearch(node.left, node);\n        } else {\n          return innerSearch(node.right, node);\n        }\n      }\n\n      var insertPosition = innerSearch(this.root, null),\n        newNode,\n        dimension;\n\n      if (insertPosition === null) {\n        this.root = new Node(point, 0, null);\n        return;\n      }\n\n      newNode = new Node(\n        point,\n        (insertPosition.dimension + 1) % dimensions.length,\n        insertPosition\n      );\n      dimension = dimensions[insertPosition.dimension];\n\n      if (point[dimension] < insertPosition.obj[dimension]) {\n        insertPosition.left = newNode;\n      } else {\n        insertPosition.right = newNode;\n      }\n    };\n\n    this.nearest = function(point, maxNodes, maxDistance) {\n      var i, result, bestNodes;\n\n      bestNodes = new BinaryHeap(function(e) {\n        return -e[1];\n      });\n\n      function nearestSearch(node) {\n        var bestChild,\n          dimension = dimensions[node.dimension],\n          ownDistance = metric(point, node.obj),\n          linearPoint = {},\n          linearDistance,\n          otherChild,\n          i;\n\n        function saveNode(node, distance) {\n          bestNodes.push([node, distance]);\n          if (bestNodes.size() > maxNodes) {\n            bestNodes.pop();\n          }\n        }\n\n        for (i = 0; i < dimensions.length; i += 1) {\n          if (i === node.dimension) {\n            linearPoint[dimensions[i]] = point[dimensions[i]];\n          } else {\n            linearPoint[dimensions[i]] = node.obj[dimensions[i]];\n          }\n        }\n\n        linearDistance = metric(linearPoint, node.obj);\n\n        if (node.right === null && node.left === null) {\n          if (\n            bestNodes.size() < maxNodes ||\n            ownDistance < bestNodes.peek()[1]\n          ) {\n            saveNode(node, ownDistance);\n          }\n          return;\n        }\n\n        if (node.right === null) {\n          bestChild = node.left;\n        } else if (node.left === null) {\n          bestChild = node.right;\n        } else {\n          if (point[dimension] < node.obj[dimension]) {\n            bestChild = node.left;\n          } else {\n            bestChild = node.right;\n          }\n        }\n\n        nearestSearch(bestChild);\n\n        if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {\n          saveNode(node, ownDistance);\n        }\n\n        if (\n          bestNodes.size() < maxNodes ||\n          Math.abs(linearDistance) < bestNodes.peek()[1]\n        ) {\n          if (bestChild === node.left) {\n            otherChild = node.right;\n          } else {\n            otherChild = node.left;\n          }\n          if (otherChild !== null) {\n            nearestSearch(otherChild);\n          }\n        }\n      }\n\n      if (maxDistance) {\n        for (i = 0; i < maxNodes; i += 1) {\n          bestNodes.push([null, maxDistance]);\n        }\n      }\n\n      if (self.root) nearestSearch(self.root);\n\n      result = [];\n\n      for (i = 0; i < Math.min(maxNodes, bestNodes.content.length); i += 1) {\n        if (bestNodes.content[i][0]) {\n          result.push([bestNodes.content[i][0].obj, bestNodes.content[i][1]]);\n        }\n      }\n      return result;\n    };\n  }\n\n  function BinaryHeap(scoreFunction) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  BinaryHeap.prototype = {\n    push: function(element) {\n      // Add the new element to the end of the array.\n      this.content.push(element);\n      // Allow it to bubble up.\n      this.bubbleUp(this.content.length - 1);\n    },\n\n    pop: function() {\n      // Store the first element so we can return it later.\n      var result = this.content[0];\n      // Get the element at the end of the array.\n      var end = this.content.pop();\n      // If there are any elements left, put the end element at the\n      // start, and let it sink down.\n      if (this.content.length > 0) {\n        this.content[0] = end;\n        this.sinkDown(0);\n      }\n      return result;\n    },\n\n    peek: function() {\n      return this.content[0];\n    },\n\n    size: function() {\n      return this.content.length;\n    },\n\n    bubbleUp: function(n) {\n      // Fetch the element that has to be moved.\n      var element = this.content[n];\n      // When at 0, an element can not go up any further.\n      while (n > 0) {\n        // Compute the parent element's index, and fetch it.\n        var parentN = Math.floor((n + 1) / 2) - 1,\n          parent = this.content[parentN];\n        // Swap the elements if the parent is greater.\n        if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n          this.content[parentN] = element;\n          this.content[n] = parent;\n          // Update 'n' to continue at the new position.\n          n = parentN;\n        }\n        // Found a parent that is less, no need to move it further.\n        else {\n          break;\n        }\n      }\n    },\n\n    sinkDown: function(n) {\n      // Look up the target element and its score.\n      var length = this.content.length,\n        element = this.content[n],\n        elemScore = this.scoreFunction(element);\n\n      while (true) {\n        // Compute the indices of the child elements.\n        var child2N = (n + 1) * 2,\n          child1N = child2N - 1;\n        // This is used to store the new position of the element,\n        // if any.\n        var swap = null;\n        // If the first child exists (is inside the array)...\n        if (child1N < length) {\n          // Look it up and compute its score.\n          var child1 = this.content[child1N],\n            child1Score = this.scoreFunction(child1);\n          // If the score is less than our element's, we need to swap.\n          if (child1Score < elemScore) swap = child1N;\n        }\n        // Do the same checks for the other child.\n        if (child2N < length) {\n          var child2 = this.content[child2N],\n            child2Score = this.scoreFunction(child2);\n          if (child2Score < (swap == null ? elemScore : child1Score)) {\n            swap = child2N;\n          }\n        }\n\n        // If the element needs to be moved, swap it, and continue.\n        if (swap != null) {\n          this.content[n] = this.content[swap];\n          this.content[swap] = element;\n          n = swap;\n        }\n        // Otherwise, we are done.\n        else {\n          break;\n        }\n      }\n    }\n  };\n\n  var dims = [];\n\n  for (var i = 0; i < fpoint.length; i++) dims.push(i);\n\n  var tree = new kdTree(\n    fpoints,\n    function(e1, e2) {\n      var d = 0;\n      var e3 = e1;\n      if (!Array.isArray(e1)) {\n        e3 = [];\n        for (var key in e1) e3.push(e1[key]);\n\n        e1 = e3;\n      }\n      e1.forEach(function(e, i) {\n        var sqd = e1[i] - e2[i];\n        d += sqd * sqd;\n      });\n      return d;\n    },\n    dims\n  );\n\n  return tree.nearest(fpoint, 1, 1000)[0][0];\n}",
        "error": null,
        "seed": "function kdNN(fpoints, fpoint) {\n  function Node(obj, dimension, parent) {\n    this.obj = obj;\n    this.left = null;\n    this.right = null;\n    this.parent = parent;\n    this.dimension = dimension;\n  }\n\n  function kdTree(points, metric, dimensions) {\n    var self = this;\n\n    function buildTree(points, depth, parent) {\n      var dim = depth % dimensions.length,\n        median,\n        node;\n\n      if (points.length === 0) {\n        return null;\n      }\n      if (points.length === 1) {\n        return new Node(points[0], dim, parent);\n      }\n\n      points.sort(function(a, b) {\n        return a[dimensions[dim]] - b[dimensions[dim]];\n      });\n\n      median = Math.floor(points.length / 2);\n      node = new Node(points[median], dim, parent);\n      node.left = buildTree(points.slice(0, median), depth + 1, node);\n      node.right = buildTree(points.slice(median + 1), depth + 1, node);\n\n      return node;\n    }\n\n    this.root = buildTree(points, 0, null);\n\n    this.insert = function(point) {\n      function innerSearch(node, parent) {\n        if (node === null) {\n          return parent;\n        }\n\n        var dimension = dimensions[node.dimension];\n        if (point[dimension] < node.obj[dimension]) {\n          return innerSearch(node.left, node);\n        } else {\n          return innerSearch(node.right, node);\n        }\n      }\n\n      var insertPosition = innerSearch(this.root, null),\n        newNode,\n        dimension;\n\n      if (insertPosition === null) {\n        this.root = new Node(point, 0, null);\n        return;\n      }\n\n      newNode = new Node(\n        point,\n        (insertPosition.dimension + 1) % dimensions.length,\n        insertPosition\n      );\n      dimension = dimensions[insertPosition.dimension];\n\n      if (point[dimension] < insertPosition.obj[dimension]) {\n        insertPosition.left = newNode;\n      } else {\n        insertPosition.right = newNode;\n      }\n    };\n\n    this.nearest = function(point, maxNodes, maxDistance) {\n      var i, result, bestNodes;\n\n      bestNodes = new BinaryHeap(function(e) {\n        return -e[1];\n      });\n\n      function nearestSearch(node) {\n        var bestChild,\n          dimension = dimensions[node.dimension],\n          ownDistance = metric(point, node.obj),\n          linearPoint = {},\n          linearDistance,\n          otherChild,\n          i;\n\n        function saveNode(node, distance) {\n          bestNodes.push([node, distance]);\n          if (bestNodes.size() > maxNodes) {\n            bestNodes.pop();\n          }\n        }\n\n        for (i = 0; i < dimensions.length; i += 1) {\n          if (i === node.dimension) {\n            linearPoint[dimensions[i]] = point[dimensions[i]];\n          } else {\n            linearPoint[dimensions[i]] = node.obj[dimensions[i]];\n          }\n        }\n\n        linearDistance = metric(linearPoint, node.obj);\n\n        if (node.right === null && node.left === null) {\n          if (\n            bestNodes.size() < maxNodes ||\n            ownDistance < bestNodes.peek()[1]\n          ) {\n            saveNode(node, ownDistance);\n          }\n          return;\n        }\n\n        if (node.right === null) {\n          bestChild = node.left;\n        } else if (node.left === null) {\n          bestChild = node.right;\n        } else {\n          if (point[dimension] < node.obj[dimension]) {\n            bestChild = node.left;\n          } else {\n            bestChild = node.right;\n          }\n        }\n\n        nearestSearch(bestChild);\n\n        if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {\n          saveNode(node, ownDistance);\n        }\n\n        if (\n          bestNodes.size() < maxNodes ||\n          Math.abs(linearDistance) < bestNodes.peek()[1]\n        ) {\n          if (bestChild === node.left) {\n            otherChild = node.right;\n          } else {\n            otherChild = node.left;\n          }\n          if (otherChild !== null) {\n            nearestSearch(otherChild);\n          }\n        }\n      }\n\n      if (maxDistance) {\n        for (i = 0; i < maxNodes; i += 1) {\n          bestNodes.push([null, maxDistance]);\n        }\n      }\n\n      if (self.root) nearestSearch(self.root);\n\n      result = [];\n\n      for (i = 0; i < Math.min(maxNodes, bestNodes.content.length); i += 1) {\n        if (bestNodes.content[i][0]) {\n          result.push([bestNodes.content[i][0].obj, bestNodes.content[i][1]]);\n        }\n      }\n      return result;\n    };\n  }\n\n  function BinaryHeap(scoreFunction) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  BinaryHeap.prototype = {\n    push: function(element) {\n      // Add the new element to the end of the array.\n      this.content.push(element);\n      // Allow it to bubble up.\n      this.bubbleUp(this.content.length - 1);\n    },\n\n    pop: function() {\n      // Store the first element so we can return it later.\n      var result = this.content[0];\n      // Get the element at the end of the array.\n      var end = this.content.pop();\n      // If there are any elements left, put the end element at the\n      // start, and let it sink down.\n      if (this.content.length > 0) {\n        this.content[0] = end;\n        this.sinkDown(0);\n      }\n      return result;\n    },\n\n    peek: function() {\n      return this.content[0];\n    },\n\n    size: function() {\n      return this.content.length;\n    },\n\n    bubbleUp: function(n) {\n      // Fetch the element that has to be moved.\n      var element = this.content[n];\n      // When at 0, an element can not go up any further.\n      while (n > 0) {\n        // Compute the parent element's index, and fetch it.\n        var parentN = Math.floor((n + 1) / 2) - 1,\n          parent = this.content[parentN];\n        // Swap the elements if the parent is greater.\n        if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n          this.content[parentN] = element;\n          this.content[n] = parent;\n          // Update 'n' to continue at the new position.\n          n = parentN;\n        }\n        // Found a parent that is less, no need to move it further.\n        else {\n          break;\n        }\n      }\n    },\n\n    sinkDown: function(n) {\n      // Look up the target element and its score.\n      var length = this.content.length,\n        element = this.content[n],\n        elemScore = this.scoreFunction(element);\n\n      while (true) {\n        // Compute the indices of the child elements.\n        var child2N = (n + 1) * 2,\n          child1N = child2N - 1;\n        // This is used to store the new position of the element,\n        // if any.\n        var swap = null;\n        // If the first child exists (is inside the array)...\n        if (child1N < length) {\n          // Look it up and compute its score.\n          var child1 = this.content[child1N],\n            child1Score = this.scoreFunction(child1);\n          // If the score is less than our element's, we need to swap.\n          if (child1Score < elemScore) swap = child1N;\n        }\n        // Do the same checks for the other child.\n        if (child2N < length) {\n          var child2 = this.content[child2N],\n            child2Score = this.scoreFunction(child2);\n          if (child2Score < (swap == null ? elemScore : child1Score)) {\n            swap = child2N;\n          }\n        }\n\n        // If the element needs to be moved, swap it, and continue.\n        if (swap != null) {\n          this.content[n] = this.content[swap];\n          this.content[swap] = element;\n          n = swap;\n        }\n        // Otherwise, we are done.\n        else {\n          break;\n        }\n      }\n    }\n  };\n\n  var dims = [];\n\n  for (var i = 0; i < fpoint.length; i++) dims.push(i);\n\n  var tree = new kdTree(\n    fpoints,\n    function(e1, e2) {\n      var d = 0;\n      var e3 = e1;\n      if (!Array.isArray(e1)) {\n        e3 = [];\n        for (var key in e1) e3.push(e1[key]);\n\n        e1 = e3;\n      }\n      e1.forEach(function(e, i) {\n        var sqd = e1[i] - e2[i];\n        d += sqd * sqd;\n      });\n      return d;\n    },\n    dims\n  );\n\n  return tree.nearest(fpoint, 1, 1000)[0][0];\n}"
      }
    ]
  ],
  "assignments": [],
  "tests": [
    {
      "text": "<p><code>kdNN</code> should be a function.</p>",
      "testString": "assert(typeof kdNN == 'function');"
    },
    {
      "text": "<p><code>kdNN([[[2, 3], [5, 4], [9, 6], [4, 7], [8, 1], [7, 2]], [9, 2])</code> should return an array.</p>",
      "testString": "assert(\n  Array.isArray(\n    kdNN(\n      [\n        [2, 3],\n        [5, 4],\n        [9, 6],\n        [4, 7],\n        [8, 1],\n        [7, 2]\n      ],\n      [9, 2]\n    )\n  )\n);"
    },
    {
      "text": "<p><code>kdNN([[[2, 3], [5, 4], [9, 6], [4, 7], [8, 1], [7, 2]], [9, 2])</code> should return <code>[ 8, 1 ]</code>.</p>",
      "testString": "assert.deepEqual(\n  kdNN(\n    [\n      [2, 3],\n      [5, 4],\n      [9, 6],\n      [4, 7],\n      [8, 1],\n      [7, 2]\n    ],\n    [9, 2]\n  ),\n  [8, 1]\n);"
    },
    {
      "text": "<p><code>kdNN([[[2, 3], [5, 4], [9, 6], [4, 7], [8, 1], [7, 2]], [7, 1])</code> should return <code>[ 8, 1 ]</code>.</p>",
      "testString": "assert.deepEqual(\n  kdNN(\n    [\n      [2, 3],\n      [5, 4],\n      [9, 6],\n      [4, 7],\n      [8, 1],\n      [7, 2]\n    ],\n    [7, 1]\n  ),\n  [8, 1]\n);"
    },
    {
      "text": "<p><code>kdNN([[[2, 3], [5, 4], [9, 6], [4, 7], [8, 1], [7, 2]], [3, 2])</code> should return <code>[ 2, 3 ]</code>.</p>",
      "testString": "assert.deepEqual(\n  kdNN(\n    [\n      [2, 3],\n      [5, 4],\n      [9, 6],\n      [4, 7],\n      [8, 1],\n      [7, 2]\n    ],\n    [3, 2]\n  ),\n  [2, 3]\n);"
    },
    {
      "text": "<p><code>kdNN([[2, 3, 1], [9, 4, 5], [4, 6, 7], [1, 2, 5], [7, 8, 9], [3, 6, 1]], [1, 2, 3])</code> should return <code>[ 1, 2, 5 ]</code>.</p>",
      "testString": "assert.deepEqual(\n  kdNN(\n    [\n      [2, 3, 1],\n      [9, 4, 5],\n      [4, 6, 7],\n      [1, 2, 5],\n      [7, 8, 9],\n      [3, 6, 1]\n    ],\n    [1, 2, 3]\n  ),\n  [1, 2, 5]\n);"
    },
    {
      "text": "<p><code>kdNN([[2, 3, 1], [9, 4, 5], [4, 6, 7], [1, 2, 5], [7, 8, 9], [3, 6, 1]], [4, 5, 6])</code> should return <code>[ 4, 6, 7 ]</code>.</p>",
      "testString": "assert.deepEqual(\n  kdNN(\n    [\n      [2, 3, 1],\n      [9, 4, 5],\n      [4, 6, 7],\n      [1, 2, 5],\n      [7, 8, 9],\n      [3, 6, 1]\n    ],\n    [4, 5, 6]\n  ),\n  [4, 6, 7]\n);"
    },
    {
      "text": "<p><code>kdNN([[2, 3, 1], [9, 4, 5], [4, 6, 7], [1, 2, 5], [7, 8, 9], [3, 6, 1]], [8, 8, 8])</code> should return <code>[ 7, 8, 9 ]</code>.</p>",
      "testString": "assert.deepEqual(\n  kdNN(\n    [\n      [2, 3, 1],\n      [9, 4, 5],\n      [4, 6, 7],\n      [1, 2, 5],\n      [7, 8, 9],\n      [3, 6, 1]\n    ],\n    [8, 8, 8]\n  ),\n  [7, 8, 9]\n);"
    }
  ],
  "description": "<section id=\"description\">\n<p>A k-d tree (short for <em>k</em>-dimensional tree) is a space-partitioning data structure for organizing points in a k-dimensional space. k-d trees are a useful data structure for several applications, such as searches involving a multidimensional search key (e.g. range searches and nearest neighbor searches). k-d trees are a special case of binary space partitioning trees. k-d trees are not suitable, however, for efficiently finding the nearest neighbor in high dimensional spaces. As a general rule, if the dimensionality is <em>k</em>, the number of points in the data, <em>N</em>, should be <em>N</em> ≫ 2<sup><i>k</i></sup>. Otherwise, when k-d trees are used with high-dimensional data, most of the points in the tree will be evaluated and the efficiency is no better than exhaustive search, and other methods such as approximate nearest-neighbor are used instead.</p>\n</section>",
  "instructions": "<section id=\"instructions\">\n<p>Write a function to perform a nearest neighbour search using k-d tree. The function takes two parameters: an array of k-dimensional points, and a single k-dimensional point whose nearest neighbour should be returned by the function. A k-dimensional point will be given as an array of k elements.</p>\n</section>",
  "translationPending": false,
  "block": "rosetta-code-challenges",
  "hasEditableBoundaries": false,
  "order": 0,
  "superOrder": 17,
  "certification": "rosetta-code",
  "superBlock": "rosetta-code",
  "challengeOrder": 77,
  "required": [],
  "helpCategory": "Rosetta",
  "usesMultifileEditor": false,
  "disableLoopProtectTests": true,
  "disableLoopProtectPreview": false
}