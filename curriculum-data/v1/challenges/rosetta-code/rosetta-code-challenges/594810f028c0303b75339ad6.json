{
  "id": "594810f028c0303b75339ad6",
  "title": "Zeckendorf number representation",
  "challengeType": 1,
  "forumTopicId": 302346,
  "dashedName": "zeckendorf-number-representation",
  "challengeFiles": [
    {
      "head": "",
      "tail": "",
      "id": "",
      "editableRegionBoundaries": [],
      "history": [
        "script.js"
      ],
      "name": "script",
      "ext": "js",
      "path": "script.js",
      "fileKey": "scriptjs",
      "contents": "function zeckendorf(n) {\n\n}",
      "error": null,
      "seed": "function zeckendorf(n) {\n\n}"
    }
  ],
  "solutions": [
    [
      {
        "head": "",
        "tail": "",
        "id": "",
        "history": [
          "script.js"
        ],
        "name": "script",
        "ext": "js",
        "path": "script.js",
        "fileKey": "scriptjs",
        "contents": "// zeckendorf :: Int -> Int\nfunction zeckendorf(n) {\n  const f = (m, x) => (m < x ? [m, 0] : [m - x, 1]);\n  return parseInt((n === 0 ? ([0]) :\n    mapAccumL(f, n, reverse(\n      tail(fibUntil(n))\n    ))[1]).join(''));\n}\n\n// fibUntil :: Int -> [Int]\nlet fibUntil = n => {\n  const xs = [];\n  until(\n      ([a]) => a > n,\n      ([a, b]) => (xs.push(a), [b, a + b]), [1, 1]\n  );\n  return xs;\n};\n\nlet mapAccumL = (f, acc, xs) => (\n  xs.reduce((a, x) => {\n    const pair = f(a[0], x);\n\n    return [pair[0], a[1].concat(pair[1])];\n  }, [acc, []])\n);\n\nlet until = (p, f, x) => {\n  let v = x;\n  while (!p(v)) v = f(v);\n  return v;\n};\n\nconst tail = xs => (\n   xs.length ? xs.slice(1) : undefined\n);\n\nconst reverse = xs => xs.slice(0).reverse();",
        "error": null,
        "seed": "// zeckendorf :: Int -> Int\nfunction zeckendorf(n) {\n  const f = (m, x) => (m < x ? [m, 0] : [m - x, 1]);\n  return parseInt((n === 0 ? ([0]) :\n    mapAccumL(f, n, reverse(\n      tail(fibUntil(n))\n    ))[1]).join(''));\n}\n\n// fibUntil :: Int -> [Int]\nlet fibUntil = n => {\n  const xs = [];\n  until(\n      ([a]) => a > n,\n      ([a, b]) => (xs.push(a), [b, a + b]), [1, 1]\n  );\n  return xs;\n};\n\nlet mapAccumL = (f, acc, xs) => (\n  xs.reduce((a, x) => {\n    const pair = f(a[0], x);\n\n    return [pair[0], a[1].concat(pair[1])];\n  }, [acc, []])\n);\n\nlet until = (p, f, x) => {\n  let v = x;\n  while (!p(v)) v = f(v);\n  return v;\n};\n\nconst tail = xs => (\n   xs.length ? xs.slice(1) : undefined\n);\n\nconst reverse = xs => xs.slice(0).reverse();"
      }
    ]
  ],
  "assignments": [],
  "tests": [
    {
      "text": "<p><code>zeckendorf</code> should be a function.</p>",
      "testString": "assert.equal(typeof zeckendorf, 'function');"
    },
    {
      "text": "<p><code>zeckendorf(0)</code> should return <code>0</code>.</p>",
      "testString": "assert.equal(zeckendorf(0), 0);\n"
    },
    {
      "text": "<p><code>zeckendorf(1)</code> should return <code>1</code>.</p>",
      "testString": "assert.equal(zeckendorf(1), 1);"
    },
    {
      "text": "<p><code>zeckendorf(2)</code> should return <code>10</code>.</p>",
      "testString": "assert.equal(zeckendorf(2), 10);"
    },
    {
      "text": "<p><code>zeckendorf(3)</code> should return <code>100</code>.</p>",
      "testString": "assert.equal(zeckendorf(3), 100);"
    },
    {
      "text": "<p><code>zeckendorf(4)</code> should return <code>101</code>.</p>",
      "testString": "assert.equal(zeckendorf(4), 101);"
    },
    {
      "text": "<p><code>zeckendorf(5)</code> should return <code>1000</code>.</p>",
      "testString": "assert.equal(zeckendorf(5), 1000);"
    },
    {
      "text": "<p><code>zeckendorf(6)</code> should return <code>1001</code>.</p>",
      "testString": "assert.equal(zeckendorf(6), 1001);"
    },
    {
      "text": "<p><code>zeckendorf(7)</code> should return <code>1010</code>.</p>",
      "testString": "assert.equal(zeckendorf(7), 1010);"
    },
    {
      "text": "<p><code>zeckendorf(8)</code> should return <code>10000</code>.</p>",
      "testString": "assert.equal(zeckendorf(8), 10000);"
    },
    {
      "text": "<p><code>zeckendorf(9)</code> should return <code>10001</code>.</p>",
      "testString": "assert.equal(zeckendorf(9), 10001);"
    },
    {
      "text": "<p><code>zeckendorf(10)</code> should return <code>10010</code>.</p>",
      "testString": "assert.equal(zeckendorf(10), 10010);"
    },
    {
      "text": "<p><code>zeckendorf(11)</code> should return <code>10100</code>.</p>",
      "testString": "assert.equal(zeckendorf(11), 10100);"
    },
    {
      "text": "<p><code>zeckendorf(12)</code> should return <code>10101</code>.</p>",
      "testString": "assert.equal(zeckendorf(12), 10101);"
    },
    {
      "text": "<p><code>zeckendorf(13)</code> should return <code>100000</code>.</p>",
      "testString": "assert.equal(zeckendorf(13), 100000);"
    },
    {
      "text": "<p><code>zeckendorf(14)</code> should return <code>100001</code>.</p>",
      "testString": "assert.equal(zeckendorf(14), 100001);"
    },
    {
      "text": "<p><code>zeckendorf(15)</code> should return <code>100010</code>.</p>",
      "testString": "assert.equal(zeckendorf(15), 100010);"
    },
    {
      "text": "<p><code>zeckendorf(16)</code> should return <code>100100</code>.</p>",
      "testString": "assert.equal(zeckendorf(16), 100100);"
    },
    {
      "text": "<p><code>zeckendorf(17)</code> should return <code>100101</code>.</p>",
      "testString": "assert.equal(zeckendorf(17), 100101);"
    },
    {
      "text": "<p><code>zeckendorf(18)</code> should return <code>101000</code>.</p>",
      "testString": "assert.equal(zeckendorf(18), 101000);"
    },
    {
      "text": "<p><code>zeckendorf(19)</code> should return <code>101001</code>.</p>",
      "testString": "assert.equal(zeckendorf(19), 101001);"
    },
    {
      "text": "<p><code>zeckendorf(20)</code> should return <code>101010</code>.</p>",
      "testString": "assert.equal(zeckendorf(20), 101010);"
    }
  ],
  "description": "<section id=\"description\">\n<p>Just as numbers can be represented in a positional notation as sums of multiples of the powers of ten (decimal) or two (binary); all the positive integers can be represented as the sum of one or zero times the distinct members of the Fibonacci series. Recall that the first six distinct Fibonacci numbers are: <code>1, 2, 3, 5, 8, 13</code>.</p>\n<p>The decimal number eleven can be written as <code>0*13 + 1*8 + 0*5 + 1*3 + 0*2 + 0*1</code> or <code>010100</code> in positional notation where the columns represent multiplication by a particular member of the sequence. Leading zeroes are dropped so that 11 decimal becomes <code>10100</code>. 10100 is not the only way to make 11 from the Fibonacci numbers however <code>0*13 + 1*8 + 0*5 + 0*3 + 1*2 + 1*1</code> or 010011 would also represent decimal 11. For a true Zeckendorf number there is the added restriction that <em>no two consecutive Fibonacci numbers can be used</em> which leads to the former unique solution.</p>\n</section>",
  "instructions": "<section id=\"instructions\">\n<p>Write a function that generates and returns the Zeckendorf number representation of <code>n</code>.</p>\n</section>",
  "translationPending": false,
  "block": "rosetta-code-challenges",
  "hasEditableBoundaries": false,
  "order": 0,
  "superOrder": 17,
  "certification": "rosetta-code",
  "superBlock": "rosetta-code",
  "challengeOrder": 157,
  "required": [],
  "helpCategory": "Rosetta",
  "usesMultifileEditor": false,
  "disableLoopProtectTests": true,
  "disableLoopProtectPreview": false
}