{
  "id": "5951a53863c8a34f02bf1bdc",
  "title": "Closest-pair problem",
  "challengeType": 1,
  "forumTopicId": 302232,
  "dashedName": "closest-pair-problem",
  "challengeFiles": [
    {
      "head": "",
      "tail": "const points1 = [\n    new Point(0.748501, 4.09624),\n    new Point(3.00302, 5.26164),\n    new Point(3.61878,  9.52232),\n    new Point(7.46911,  4.71611),\n    new Point(5.7819,   2.69367),\n    new Point(2.34709,  8.74782),\n    new Point(2.87169,  5.97774),\n    new Point(6.33101,  0.463131),\n    new Point(7.46489,  4.6268),\n    new Point(1.45428,  0.087596)\n];\n\nconst answer1 = {\n  distance: 0.0894096443343775,\n  pair: [\n    {\n      x: 7.46489,\n      y: 4.6268\n    },\n    {\n      x: 7.46911,\n      y: 4.71611\n    }\n  ]\n};\n\nconst points2 = [\n  new Point(37100, 13118),\n  new Point(37134, 1963),\n  new Point(37181, 2008),\n  new Point(37276, 21611),\n  new Point(37307, 9320)\n];\n\nconst answer2 = {\n  distance: 65.06919393998976,\n  pair: [\n    {\n      x: 37134,\n      y: 1963\n    },\n    {\n      x: 37181,\n      y: 2008\n    }\n  ]\n};\n\nconst points3 = [\n  new Point(16910, 54699),\n  new Point(14773, 61107),\n  new Point(95547, 45344),\n  new Point(95951, 17573),\n  new Point(5824, 41072),\n  new Point(8769, 52562),\n  new Point(21182, 41881),\n  new Point(53226, 45749),\n  new Point(68180, 887),\n  new Point(29322, 44017),\n  new Point(46817, 64975),\n  new Point(10501, 483),\n  new Point(57094, 60703),\n  new Point(23318, 35472),\n  new Point(72452, 88070),\n  new Point(67775, 28659),\n  new Point(19450, 20518),\n  new Point(17314, 26927),\n  new Point(98088, 11164),\n  new Point(25050, 56835),\n  new Point(8364, 6892),\n  new Point(37868, 18382),\n  new Point(23723, 7701),\n  new Point(55767, 11569),\n  new Point(70721, 66707),\n  new Point(31863, 9837),\n  new Point(49358, 30795),\n  new Point(13041, 39744),\n  new Point(59635, 26523),\n  new Point(25859, 1292),\n  new Point(1551, 53890),\n  new Point(70316, 94479),\n  new Point(48549, 86338),\n  new Point(46413, 92747),\n  new Point(27186, 50426),\n  new Point(27591, 22655),\n  new Point(10905, 46153),\n  new Point(40408, 84202),\n  new Point(52821, 73520),\n  new Point(84865, 77388),\n  new Point(99819, 32527),\n  new Point(34404, 75657),\n  new Point(78457, 96615),\n  new Point(42140, 5564),\n  new Point(62175, 92342),\n  new Point(54958, 67112),\n  new Point(4092, 19709),\n  new Point(99415, 60298),\n  new Point(51090, 52158),\n  new Point(48953, 58567)\n];\n\nconst answer3 = {\n  distance: 6754.625082119658,\n  pair: [\n    {\n      x: 46817,\n      y: 64975\n    },\n    {\n      x: 48953,\n      y: 58567\n    }\n  ]\n}",
      "id": "",
      "editableRegionBoundaries": [],
      "history": [
        "script.js"
      ],
      "name": "script",
      "ext": "js",
      "path": "script.js",
      "fileKey": "scriptjs",
      "contents": "const Point = function(x, y) {\n  this.x = x;\n  this.y = y;\n};\nPoint.prototype.getX = function() {\n  return this.x;\n};\nPoint.prototype.getY = function() {\n  return this.y;\n};\n\nfunction getClosestPair(pointsArr) {\n\n  return true;\n}",
      "error": null,
      "seed": "const Point = function(x, y) {\n  this.x = x;\n  this.y = y;\n};\nPoint.prototype.getX = function() {\n  return this.x;\n};\nPoint.prototype.getY = function() {\n  return this.y;\n};\n\nfunction getClosestPair(pointsArr) {\n\n  return true;\n}"
    }
  ],
  "solutions": [
    [
      {
        "head": "",
        "tail": "",
        "id": "",
        "history": [
          "script.js"
        ],
        "name": "script",
        "ext": "js",
        "path": "script.js",
        "fileKey": "scriptjs",
        "contents": "const Point = function(x, y) {\n  this.x = x;\n  this.y = y;\n};\nPoint.prototype.getX = function() {\n  return this.x;\n};\nPoint.prototype.getY = function() {\n  return this.y;\n};\n\nconst mergeSort = function mergeSort(points, comp) {\n    if(points.length < 2) return points;\n\n    var n = points.length,\n        i = 0,\n        j = 0,\n        leftN = Math.floor(n / 2),\n        rightN = leftN;\n\n    var leftPart = mergeSort( points.slice(0, leftN), comp),\n        rightPart = mergeSort( points.slice(rightN), comp );\n\n    var sortedPart = [];\n\n    while((i < leftPart.length) && (j < rightPart.length)) {\n        if(comp(leftPart[i], rightPart[j]) < 0) {\n            sortedPart.push(leftPart[i]);\n            i += 1;\n        }\n        else {\n            sortedPart.push(rightPart[j]);\n            j += 1;\n        }\n    }\n    while(i < leftPart.length) {\n        sortedPart.push(leftPart[i]);\n        i += 1;\n    }\n    while(j < rightPart.length) {\n        sortedPart.push(rightPart[j]);\n        j += 1;\n    }\n    return sortedPart;\n};\n\nconst closestPair = function _closestPair(Px, Py) {\n    if(Px.length < 2) return { distance: Infinity, pair: [ new Point(0, 0), new Point(0, 0) ] };\n    if(Px.length < 3) {\n        //find euclid distance\n        var d = Math.sqrt( Math.pow(Math.abs(Px[1].x - Px[0].x), 2) + Math.pow(Math.abs(Px[1].y - Px[0].y), 2) );\n        return {\n            distance: d,\n            pair: [ Px[0], Px[1] ]\n        };\n    }\n\n    var n = Px.length,\n        leftN = Math.floor(n / 2),\n        rightN = leftN;\n\n    var Xl = Px.slice(0, leftN),\n        Xr = Px.slice(rightN),\n        Xm = Xl[leftN - 1],\n        Yl = [],\n        Yr = [];\n    //separate Py\n    for(var i = 0; i < Py.length; i += 1) {\n        if(Py[i].x <= Xm.x)\n            Yl.push(Py[i]);\n        else\n            Yr.push(Py[i]);\n    }\n\n    var dLeft = _closestPair(Xl, Yl),\n        dRight = _closestPair(Xr, Yr);\n\n    var minDelta = dLeft.distance,\n        closestPair = dLeft.pair;\n    if(dLeft.distance > dRight.distance) {\n        minDelta = dRight.distance;\n        closestPair = dRight.pair;\n    }\n\n    //filter points around Xm within delta (minDelta)\n    var closeY = [];\n    for(i = 0; i < Py.length; i += 1) {\n        if(Math.abs(Py[i].x - Xm.x) < minDelta) closeY.push(Py[i]);\n    }\n    //find min within delta. 8 steps max\n    for(i = 0; i < closeY.length; i += 1) {\n        for(var j = i + 1; j < Math.min( (i + 8), closeY.length ); j += 1) {\n            var d = Math.sqrt( Math.pow(Math.abs(closeY[j].x - closeY[i].x), 2) + Math.pow(Math.abs(closeY[j].y - closeY[i].y), 2) );\n            if(d < minDelta) {\n                minDelta = d;\n                closestPair = [ closeY[i], closeY[j] ]\n            }\n        }\n    }\n\n    return {\n        distance: minDelta,\n        pair: closestPair.sort((pointA, pointB) => pointA.x - pointB.x)\n    };\n};\n\nfunction getClosestPair(points) {\n  const sortX = function(a, b) { return (a.x < b.x) ? -1 : ((a.x > b.x) ? 1 : 0); }\n  const sortY = function(a, b) { return (a.y < b.y) ? -1 : ((a.y > b.y) ? 1 : 0); }\n\n  const Px = mergeSort(points, sortX);\n  const Py = mergeSort(points, sortY);\n\n  return closestPair(Px, Py);\n}",
        "error": null,
        "seed": "const Point = function(x, y) {\n  this.x = x;\n  this.y = y;\n};\nPoint.prototype.getX = function() {\n  return this.x;\n};\nPoint.prototype.getY = function() {\n  return this.y;\n};\n\nconst mergeSort = function mergeSort(points, comp) {\n    if(points.length < 2) return points;\n\n    var n = points.length,\n        i = 0,\n        j = 0,\n        leftN = Math.floor(n / 2),\n        rightN = leftN;\n\n    var leftPart = mergeSort( points.slice(0, leftN), comp),\n        rightPart = mergeSort( points.slice(rightN), comp );\n\n    var sortedPart = [];\n\n    while((i < leftPart.length) && (j < rightPart.length)) {\n        if(comp(leftPart[i], rightPart[j]) < 0) {\n            sortedPart.push(leftPart[i]);\n            i += 1;\n        }\n        else {\n            sortedPart.push(rightPart[j]);\n            j += 1;\n        }\n    }\n    while(i < leftPart.length) {\n        sortedPart.push(leftPart[i]);\n        i += 1;\n    }\n    while(j < rightPart.length) {\n        sortedPart.push(rightPart[j]);\n        j += 1;\n    }\n    return sortedPart;\n};\n\nconst closestPair = function _closestPair(Px, Py) {\n    if(Px.length < 2) return { distance: Infinity, pair: [ new Point(0, 0), new Point(0, 0) ] };\n    if(Px.length < 3) {\n        //find euclid distance\n        var d = Math.sqrt( Math.pow(Math.abs(Px[1].x - Px[0].x), 2) + Math.pow(Math.abs(Px[1].y - Px[0].y), 2) );\n        return {\n            distance: d,\n            pair: [ Px[0], Px[1] ]\n        };\n    }\n\n    var n = Px.length,\n        leftN = Math.floor(n / 2),\n        rightN = leftN;\n\n    var Xl = Px.slice(0, leftN),\n        Xr = Px.slice(rightN),\n        Xm = Xl[leftN - 1],\n        Yl = [],\n        Yr = [];\n    //separate Py\n    for(var i = 0; i < Py.length; i += 1) {\n        if(Py[i].x <= Xm.x)\n            Yl.push(Py[i]);\n        else\n            Yr.push(Py[i]);\n    }\n\n    var dLeft = _closestPair(Xl, Yl),\n        dRight = _closestPair(Xr, Yr);\n\n    var minDelta = dLeft.distance,\n        closestPair = dLeft.pair;\n    if(dLeft.distance > dRight.distance) {\n        minDelta = dRight.distance;\n        closestPair = dRight.pair;\n    }\n\n    //filter points around Xm within delta (minDelta)\n    var closeY = [];\n    for(i = 0; i < Py.length; i += 1) {\n        if(Math.abs(Py[i].x - Xm.x) < minDelta) closeY.push(Py[i]);\n    }\n    //find min within delta. 8 steps max\n    for(i = 0; i < closeY.length; i += 1) {\n        for(var j = i + 1; j < Math.min( (i + 8), closeY.length ); j += 1) {\n            var d = Math.sqrt( Math.pow(Math.abs(closeY[j].x - closeY[i].x), 2) + Math.pow(Math.abs(closeY[j].y - closeY[i].y), 2) );\n            if(d < minDelta) {\n                minDelta = d;\n                closestPair = [ closeY[i], closeY[j] ]\n            }\n        }\n    }\n\n    return {\n        distance: minDelta,\n        pair: closestPair.sort((pointA, pointB) => pointA.x - pointB.x)\n    };\n};\n\nfunction getClosestPair(points) {\n  const sortX = function(a, b) { return (a.x < b.x) ? -1 : ((a.x > b.x) ? 1 : 0); }\n  const sortY = function(a, b) { return (a.y < b.y) ? -1 : ((a.y > b.y) ? 1 : 0); }\n\n  const Px = mergeSort(points, sortX);\n  const Py = mergeSort(points, sortY);\n\n  return closestPair(Px, Py);\n}"
      }
    ]
  ],
  "assignments": [],
  "tests": [
    {
      "text": "<p><code>getClosestPair</code> should be a function.</p>",
      "testString": "assert(typeof getClosestPair === 'function');"
    },
    {
      "text": "<p><code>getClosestPair(points1).distance</code> should be <code>0.0894096443343775</code>.</p>",
      "testString": "assert.equal(getClosestPair(points1).distance, answer1.distance);"
    },
    {
      "text": "<p><code>getClosestPair(points1).pair</code> should be <code>[ { x: 7.46489, y: 4.6268 }, { x: 7.46911, y: 4.71611 } ]</code>.</p>",
      "testString": "assert.deepEqual(\n  JSON.parse(JSON.stringify(getClosestPair(points1))).pair,\n  answer1.pair\n);"
    },
    {
      "text": "<p><code>getClosestPair(points2).distance</code> should be <code>65.06919393998976</code>.</p>",
      "testString": "assert.equal(getClosestPair(points2).distance, answer2.distance);"
    },
    {
      "text": "<p><code>getClosestPair(points2).pair</code> should be <code>[ { x: 37134, y: 1963 }, { x: 37181, y: 2008 } ]</code>.</p>",
      "testString": "assert.deepEqual(\n  JSON.parse(JSON.stringify(getClosestPair(points2))).pair,\n  answer2.pair\n);"
    },
    {
      "text": "<p><code>getClosestPair(points3).distance</code> should be <code>6754.625082119658</code>.</p>",
      "testString": "assert.equal(getClosestPair(points3).distance, answer3.distance);"
    },
    {
      "text": "<p><code>getClosestPair(points3).pair</code> should be <code>[ { x: 46817, y: 64975 }, { x: 48953, y: 58567 } ]</code>.</p>",
      "testString": "assert.deepEqual(\n  JSON.parse(JSON.stringify(getClosestPair(points3))).pair,\n  answer3.pair\n);"
    }
  ],
  "description": "<section id=\"description\">\n<p>Provide a function to find the closest two points among a set of given points in two dimensions.</p>\n<p>The straightforward solution is a $O(n^2)$ algorithm (which we can call <em>brute-force algorithm</em>); the pseudo-code (using indexes) could be simply:</p>\n<pre><strong>bruteForceClosestPair</strong> of P(1), P(2), ... P(N)\n<strong>if</strong> N &#x3C; 2 <strong>then</strong>\n  <strong>return</strong> ∞\n<strong>else</strong>\n  minDistance ← |P(1) - P(2)|\n  minPoints ← { P(1), P(2) }\n  <strong>foreach</strong> i ∈ [1, N-1]\n    <strong>foreach</strong> j ∈ [i+1, N]\n      <strong>if</strong> |P(i) - P(j)| &#x3C; minDistance <strong>then</strong>\n        minDistance ← |P(i) - P(j)|\n        minPoints ← { P(i), P(j) }\n      <strong>endif</strong>\n    <strong>endfor</strong>\n  <strong>endfor</strong>\n  <strong>return</strong> minDistance, minPoints\n<strong>endif</strong>\n</pre>\n<p>A better algorithm is based on the recursive divide and conquer approach, which is $O(n\\log n)$ a pseudo-code could be:</p>\n<pre><strong>closestPair</strong> of (xP, yP)\n  where xP is P(1) .. P(N) sorted by x coordinate, and\n  yP is P(1) .. P(N) sorted by y coordinate (ascending order)\n<strong>if</strong> N ≤ 3 <strong>then</strong>\n  <strong>return</strong> closest points of xP using brute-force algorithm\n<strong>else</strong>\n  xL ← points of xP from 1 to ⌈N/2⌉\n  xR ← points of xP from ⌈N/2⌉+1 to N\n  xm ← xP(⌈N/2⌉)<sub>x</sub>\n  yL ← { p ∈ yP : p<sub>x</sub> ≤ xm }\n  yR ← { p ∈ yP : p<sub>x</sub> > xm }\n  (dL, pairL) ← closestPair of (xL, yL)\n  (dR, pairR) ← closestPair of (xR, yR)\n  (dmin, pairMin) ← (dR, pairR)\n  <strong>if</strong> dL &#x3C; dR <strong>then</strong>\n    (dmin, pairMin) ← (dL, pairL)\n  <strong>endif</strong>\n  yS ← { p ∈ yP : |xm - p<sub>x</sub>| &#x3C; dmin }\n  nS ← number of points in yS\n  (closest, closestPair) ← (dmin, pairMin)\n  <strong>for</strong> i <strong>from</strong> 1 <strong>to</strong> nS - 1\n    k ← i + 1\n    <strong>while</strong> k ≤ nS <strong>and</strong> yS(k)<sub>y</sub> - yS(i)<sub>y</sub> &#x3C; dmin\n      <strong>if</strong> |yS(k) - yS(i)| &#x3C; closest <strong>then</strong>\n        (closest, closestPair) ← (|yS(k) - yS(i)|, {yS(k), yS(i)})\n      <strong>endif</strong>\n      k ← k + 1\n    <strong>endwhile</strong>\n  <strong>endfor</strong>\n  <strong>return</strong> closest, closestPair\n<strong>endif</strong>\n</pre>\n<p>For the input, expect the argument to be an array of <code>Point</code> objects with <code>x</code> and <code>y</code> members set to numbers. Return an object containing the key:value pairs for <code>distance</code> and <code>pair</code> (the pair of two closest points).</p>\n<p>For example <code>getClosestPair</code> with input array <code>points</code>:</p>\n<pre><code class=\"language-js\">const points = [\n  new Point(1, 2),\n  new Point(3, 3),\n  new Point(2, 2)\n];\n</code></pre>\n<p>Would return:</p>\n<pre><code class=\"language-js\">{\n  distance: 1,\n  pair: [\n    {\n      x: 1,\n      y: 2\n    },\n    {\n      x: 2,\n      y: 2\n    }\n  ]\n}\n</code></pre>\n<p><strong>Note:</strong> Sort the <code>pair</code> array by their <code>x</code> values in incrementing order.</p>\n</section>",
  "translationPending": false,
  "block": "rosetta-code-challenges",
  "hasEditableBoundaries": false,
  "order": 0,
  "superOrder": 17,
  "certification": "rosetta-code",
  "superBlock": "rosetta-code",
  "challengeOrder": 15,
  "required": [],
  "helpCategory": "Rosetta",
  "usesMultifileEditor": false,
  "disableLoopProtectTests": true,
  "disableLoopProtectPreview": false
}