{
  "id": "5a23c84252665b21eecc8024",
  "title": "State name puzzle",
  "challengeType": 1,
  "forumTopicId": 302323,
  "dashedName": "state-name-puzzle",
  "challengeFiles": [
    {
      "head": "",
      "tail": "",
      "id": "",
      "editableRegionBoundaries": [],
      "history": [
        "script.js"
      ],
      "name": "script",
      "ext": "js",
      "path": "script.js",
      "fileKey": "scriptjs",
      "contents": "function solve(input) {\n\n}",
      "error": null,
      "seed": "function solve(input) {\n\n}"
    }
  ],
  "solutions": [
    [
      {
        "head": "",
        "tail": "",
        "id": "",
        "history": [
          "script.js"
        ],
        "name": "script",
        "ext": "js",
        "path": "script.js",
        "fileKey": "scriptjs",
        "contents": "function solve(input) {\n  var orig = {};\n  input.forEach(function(e) {\n    orig[__helpers.removeWhiteSpace(e).toLowerCase()] = e;\n  });\n\n  input = Object.keys(orig);\n  var map = {};\n  for (var i = 0; i < input.length - 1; i++) {\n    var pair0 = input[i];\n    for (var j = i + 1; j < input.length; j++) {\n      var pair = [pair0, input[j]];\n      var s = pair0 + pair[1];\n      var key = s.split('').sort();\n\n      var val = map[key] ? map[key] : [];\n      val.push(pair);\n      map[key] = val;\n    }\n  }\n\n  var result = [];\n  Object.keys(map).forEach(key => {\n    for (var i = 0; i < map[key].length - 1; i++) {\n      var a = map[key][i];\n      for (var j = i + 1; j < map[key].length; j++) {\n        var b = map[key][j];\n\n        if (new Set([a[0], b[0], a[1], b[1]]).size < 4) continue;\n        var from = [orig[a[0]], orig[a[1]]].sort();\n        var to = [orig[b[0]], orig[b[1]]].sort();\n        result.push({\n          from,\n          to\n        });\n      }\n    }\n  });\n\n  return result;\n}",
        "error": null,
        "seed": "function solve(input) {\n  var orig = {};\n  input.forEach(function(e) {\n    orig[__helpers.removeWhiteSpace(e).toLowerCase()] = e;\n  });\n\n  input = Object.keys(orig);\n  var map = {};\n  for (var i = 0; i < input.length - 1; i++) {\n    var pair0 = input[i];\n    for (var j = i + 1; j < input.length; j++) {\n      var pair = [pair0, input[j]];\n      var s = pair0 + pair[1];\n      var key = s.split('').sort();\n\n      var val = map[key] ? map[key] : [];\n      val.push(pair);\n      map[key] = val;\n    }\n  }\n\n  var result = [];\n  Object.keys(map).forEach(key => {\n    for (var i = 0; i < map[key].length - 1; i++) {\n      var a = map[key][i];\n      for (var j = i + 1; j < map[key].length; j++) {\n        var b = map[key][j];\n\n        if (new Set([a[0], b[0], a[1], b[1]]).size < 4) continue;\n        var from = [orig[a[0]], orig[a[1]]].sort();\n        var to = [orig[b[0]], orig[b[1]]].sort();\n        result.push({\n          from,\n          to\n        });\n      }\n    }\n  });\n\n  return result;\n}"
      }
    ]
  ],
  "assignments": [],
  "tests": [
    {
      "text": "<p><code>solve</code> should be a function.</p>",
      "testString": "assert(typeof solve == 'function');"
    },
    {
      "text": "<p><code>solve([\"New Mexico\", \"New York\", \"North Carolina \", \"North Dakota\", \"Ohio\", \"Oklahoma\", \"Oregon\", \"Pennsylvania\", \"Rhode Island\", \"South Carolina\", \"South Dakota\"])</code> should return an array.</p>",
      "testString": "assert(\n  Array.isArray(\n    solve([\n      'New Mexico',\n      'New York',\n      'North Carolina ',\n      'North Dakota',\n      'Ohio',\n      'Oklahoma',\n      'Oregon',\n      'Pennsylvania',\n      'Rhode Island',\n      'South Carolina',\n      'South Dakota'\n    ])\n  )\n);"
    },
    {
      "text": "<p><code>solve([\"New Mexico\", \"New York\", \"North Carolina \", \"North Dakota\", \"Ohio\", \"Oklahoma\", \"Oregon\", \"Pennsylvania\", \"Rhode Island\", \"South Carolina\", \"South Dakota\"])</code> should return <code>[{ from: [\"North Carolina \", \"South Dakota\"], to: [\"North Dakota\", \"South Carolina\"] }]</code>.</p>",
      "testString": "assert.deepEqual(\n  solve([\n    'New Mexico',\n    'New York',\n    'North Carolina ',\n    'North Dakota',\n    'Ohio',\n    'Oklahoma',\n    'Oregon',\n    'Pennsylvania',\n    'Rhode Island',\n    'South Carolina',\n    'South Dakota'\n  ]),\n  [\n    {\n      from: ['North Carolina ', 'South Dakota'],\n      to: ['North Dakota', 'South Carolina']\n    }\n  ]\n);"
    },
    {
      "text": "<p><code>solve([\"New York\", \"New Kory\", \"Wen Kory\", \"York New\", \"Kory New\", \"New Kory\"])</code> should return <code>[{ from: [\"New Kory\", \"New York\"], to: [\"Wen Kory\", \"York New\"] }, { from: [\"New Kory\", \"New York\"], to: [\"Kory New\", \"Wen Kory\"] }, { from: [\"New Kory\", \"New York\"], to: [\"Kory New\", \"York New\"] }, { from: [\"New York\", \"Wen Kory\"], to: [\"New Kory\", \"York New\"] }, { from: [\"New York\", \"Wen Kory\"], to: [\"Kory New\", \"New Kory\"] }, { from: [\"New York\", \"Wen Kory\"], to: [\"Kory New\", \"York New\"] }, { from: [\"New York\", \"York New\"], to: [\"New Kory\", \"Wen Kory\"] }, { from: [\"New York\", \"York New\"], to: [\"Kory New\", \"New Kory\"] }, { from: [\"New York\", \"York New\"], to: [\"Kory New\", \"Wen Kory\"] }, { from: [\"Kory New\", \"New York\"], to: [\"New Kory\", \"Wen Kory\"] }, { from: [\"Kory New\", \"New York\"], to: [\"New Kory\", \"York New\"] }, { from: [\"Kory New\", \"New York\"], to: [\"Wen Kory\", \"York New\"] }, { from: [\"New Kory\", \"Wen Kory\"], to: [\"Kory New\", \"York New\"] }, { from: [\"New Kory\", \"York New\"], to: [\"Kory New\", \"Wen Kory\"] }, { from: [\"Kory New\", \"New Kory\"], to: [\"Wen Kory\", \"York New\"] }]</code>.</p>",
      "testString": "assert.deepEqual(\n  solve([\n    'New York',\n    'New Kory',\n    'Wen Kory',\n    'York New',\n    'Kory New',\n    'New Kory'\n  ]),\n  [\n    { from: ['New Kory', 'New York'], to: ['Wen Kory', 'York New'] },\n    { from: ['New Kory', 'New York'], to: ['Kory New', 'Wen Kory'] },\n    { from: ['New Kory', 'New York'], to: ['Kory New', 'York New'] },\n    { from: ['New York', 'Wen Kory'], to: ['New Kory', 'York New'] },\n    { from: ['New York', 'Wen Kory'], to: ['Kory New', 'New Kory'] },\n    { from: ['New York', 'Wen Kory'], to: ['Kory New', 'York New'] },\n    { from: ['New York', 'York New'], to: ['New Kory', 'Wen Kory'] },\n    { from: ['New York', 'York New'], to: ['Kory New', 'New Kory'] },\n    { from: ['New York', 'York New'], to: ['Kory New', 'Wen Kory'] },\n    { from: ['Kory New', 'New York'], to: ['New Kory', 'Wen Kory'] },\n    { from: ['Kory New', 'New York'], to: ['New Kory', 'York New'] },\n    { from: ['Kory New', 'New York'], to: ['Wen Kory', 'York New'] },\n    { from: ['New Kory', 'Wen Kory'], to: ['Kory New', 'York New'] },\n    { from: ['New Kory', 'York New'], to: ['Kory New', 'Wen Kory'] },\n    { from: ['Kory New', 'New Kory'], to: ['Wen Kory', 'York New'] }\n  ]\n);"
    }
  ],
  "description": "<section id=\"description\">\n<p><strong>State name</strong> is a <em>word puzzle</em> in which you take the letters from two U.S. state names and rearrange them to form the names of two different U.S. states.</p>\n</section>",
  "instructions": "<section id=\"instructions\">\n<p>Write a function to solve the challenge for a given array of actual U.S. state names, and for fictional state names.</p>\n<p>The function should return an array. Each element should be an object in this form: <code>{\"from\":[],\"to\":[]}</code>. The <code>from</code> array should contain the original names and the <code>to</code> array should contain the resultant names.</p>\n</section>",
  "translationPending": false,
  "block": "rosetta-code-challenges",
  "hasEditableBoundaries": false,
  "order": 0,
  "superOrder": 17,
  "certification": "rosetta-code",
  "superBlock": "rosetta-code",
  "challengeOrder": 133,
  "required": [],
  "helpCategory": "Rosetta",
  "usesMultifileEditor": false,
  "disableLoopProtectTests": true,
  "disableLoopProtectPreview": false
}