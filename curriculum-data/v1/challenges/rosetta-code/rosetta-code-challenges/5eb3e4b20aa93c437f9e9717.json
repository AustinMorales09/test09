{
  "id": "5eb3e4b20aa93c437f9e9717",
  "title": "Set of real numbers",
  "challengeType": 1,
  "forumTopicId": 385322,
  "dashedName": "set-of-real-numbers",
  "challengeFiles": [
    {
      "head": "",
      "tail": "",
      "id": "",
      "editableRegionBoundaries": [],
      "history": [
        "script.js"
      ],
      "name": "script",
      "ext": "js",
      "path": "script.js",
      "fileKey": "scriptjs",
      "contents": "function realSet(set1, set2, operation, values) {\n\n}",
      "error": null,
      "seed": "function realSet(set1, set2, operation, values) {\n\n}"
    }
  ],
  "solutions": [
    [
      {
        "head": "",
        "tail": "",
        "id": "",
        "history": [
          "script.js"
        ],
        "name": "script",
        "ext": "js",
        "path": "script.js",
        "fileKey": "scriptjs",
        "contents": "function realSet(set1, set2, operation, values) {\n  const RangeType = {\n    CLOSED: 0,\n    BOTH_OPEN: 1,\n    LEFT_OPEN: 2,\n    RIGHT_OPEN: 3\n  };\n\n  function Predicate(test) {\n    this.test = test;\n    this.or = function(other) {\n      return new Predicate(t => this.test(t) || other.test(t));\n    };\n    this.and = function(other) {\n      return new Predicate(t => this.test(t) && other.test(t));\n    };\n    this.negate = function() {\n      return new Predicate(t => !this.test(t));\n    };\n  }\n\n  function RealSet(start, end, rangeType, predF) {\n    this.low = start;\n    this.high = end;\n\n    if (predF) {\n      this.predicate = new Predicate(predF);\n    } else {\n      this.predicate = new Predicate(d => {\n        switch (rangeType) {\n          case RangeType.CLOSED:\n            return start <= d && d <= end;\n          case RangeType.BOTH_OPEN:\n            return start < d && d < end;\n          case RangeType.LEFT_OPEN:\n            return start < d && d <= end;\n          case RangeType.RIGHT_OPEN:\n            return start <= d && d < end;\n        }\n      });\n    }\n\n    this.contains = function(d) {\n      return this.predicate.test(d);\n    };\n\n    this.union = function(other) {\n      var low2 = Math.min(this.low, other.low);\n      var high2 = Math.max(this.high, other.high);\n      return new RealSet(low2, high2, null, d =>\n        this.predicate.or(other.predicate).test(d)\n      );\n    };\n\n    this.intersect = function(other) {\n      var low2 = Math.min(this.low, other.low);\n      var high2 = Math.max(this.high, other.high);\n      return new RealSet(low2, high2, null, d =>\n        this.predicate.and(other.predicate).test(d)\n      );\n    };\n\n    this.subtract = function(other) {\n      return new RealSet(this.low, this.high, null, d =>\n        this.predicate.and(other.predicate.negate()).test(d)\n      );\n    };\n  }\n  set1 = new RealSet(set1.low, set1.high, set1.rangeType);\n  set2 = new RealSet(set2.low, set2.high, set2.rangeType);\n  var result = [];\n  values.forEach(function(value) {\n    result.push(set1[operation](set2).contains(value));\n  });\n  return result;\n}",
        "error": null,
        "seed": "function realSet(set1, set2, operation, values) {\n  const RangeType = {\n    CLOSED: 0,\n    BOTH_OPEN: 1,\n    LEFT_OPEN: 2,\n    RIGHT_OPEN: 3\n  };\n\n  function Predicate(test) {\n    this.test = test;\n    this.or = function(other) {\n      return new Predicate(t => this.test(t) || other.test(t));\n    };\n    this.and = function(other) {\n      return new Predicate(t => this.test(t) && other.test(t));\n    };\n    this.negate = function() {\n      return new Predicate(t => !this.test(t));\n    };\n  }\n\n  function RealSet(start, end, rangeType, predF) {\n    this.low = start;\n    this.high = end;\n\n    if (predF) {\n      this.predicate = new Predicate(predF);\n    } else {\n      this.predicate = new Predicate(d => {\n        switch (rangeType) {\n          case RangeType.CLOSED:\n            return start <= d && d <= end;\n          case RangeType.BOTH_OPEN:\n            return start < d && d < end;\n          case RangeType.LEFT_OPEN:\n            return start < d && d <= end;\n          case RangeType.RIGHT_OPEN:\n            return start <= d && d < end;\n        }\n      });\n    }\n\n    this.contains = function(d) {\n      return this.predicate.test(d);\n    };\n\n    this.union = function(other) {\n      var low2 = Math.min(this.low, other.low);\n      var high2 = Math.max(this.high, other.high);\n      return new RealSet(low2, high2, null, d =>\n        this.predicate.or(other.predicate).test(d)\n      );\n    };\n\n    this.intersect = function(other) {\n      var low2 = Math.min(this.low, other.low);\n      var high2 = Math.max(this.high, other.high);\n      return new RealSet(low2, high2, null, d =>\n        this.predicate.and(other.predicate).test(d)\n      );\n    };\n\n    this.subtract = function(other) {\n      return new RealSet(this.low, this.high, null, d =>\n        this.predicate.and(other.predicate.negate()).test(d)\n      );\n    };\n  }\n  set1 = new RealSet(set1.low, set1.high, set1.rangeType);\n  set2 = new RealSet(set2.low, set2.high, set2.rangeType);\n  var result = [];\n  values.forEach(function(value) {\n    result.push(set1[operation](set2).contains(value));\n  });\n  return result;\n}"
      }
    ]
  ],
  "assignments": [],
  "tests": [
    {
      "text": "<p><code>realSet</code> should be a function.</p>",
      "testString": "assert(typeof realSet == 'function');"
    },
    {
      "text": "<p><code>realSet({\"low\":0, \"high\":1, \"rangeType\":2}, {\"low\":0, \"high\":2, \"rangeType\":3}, \"union\", [1, 2, 3])</code> should return a array.</p>",
      "testString": "assert(\n  Array.isArray(\n    realSet(\n      { low: 0, high: 1, rangeType: 2 },\n      { low: 0, high: 2, rangeType: 3 },\n      'union',\n      [1, 2, 3]\n    )\n  )\n);"
    },
    {
      "text": "<p><code>realSet({\"low\":0, \"high\":1, \"rangeType\":2}, {\"low\":0, \"high\":2, \"rangeType\":3}, \"union\", [1, 2, 3])</code> should return <code>[true, false, false]</code>.</p>",
      "testString": "assert.deepEqual(\n  realSet(\n    { low: 0, high: 1, rangeType: 2 },\n    { low: 0, high: 2, rangeType: 3 },\n    'union',\n    [1, 2, 3]\n  ),\n  [true, false, false]\n);"
    },
    {
      "text": "<p><code>realSet({\"low\":0, \"high\":2, \"rangeType\":3}, {\"low\":1, \"high\":2, \"rangeType\":2}, \"intersect\", [0, 1, 2])</code> should return <code>[false, false, false]</code>.</p>",
      "testString": "assert.deepEqual(\n  realSet(\n    { low: 0, high: 2, rangeType: 3 },\n    { low: 1, high: 2, rangeType: 2 },\n    'intersect',\n    [0, 1, 2]\n  ),\n  [false, false, false]\n);"
    },
    {
      "text": "<p><code>realSet({\"low\":0, \"high\":3, \"rangeType\":3}, {\"low\":0, \"high\":1, \"rangeType\":1}, \"subtract\", [0, 1, 2])</code> should return <code>[true, true, true]</code>.</p>",
      "testString": "assert.deepEqual(\n  realSet(\n    { low: 0, high: 3, rangeType: 3 },\n    { low: 0, high: 1, rangeType: 1 },\n    'subtract',\n    [0, 1, 2]\n  ),\n  [true, true, true]\n);"
    },
    {
      "text": "<p><code>realSet({\"low\":0, \"high\":3, \"rangeType\":3}, {\"low\":0, \"high\":1, \"rangeType\":0}, \"subtract\", [0, 1, 2])</code> should return <code>[false, false, true]</code>.</p>",
      "testString": "assert.deepEqual(\n  realSet(\n    { low: 0, high: 3, rangeType: 3 },\n    { low: 0, high: 1, rangeType: 0 },\n    'subtract',\n    [0, 1, 2]\n  ),\n  [false, false, true]\n);"
    },
    {
      "text": "<p><code>realSet({\"low\":0, \"high\":33, \"rangeType\":1}, {\"low\":30, \"high\":31, \"rangeType\":0}, \"intersect\", [30, 31, 32])</code> should return <code>[true, true, false]</code>.</p>",
      "testString": "assert.deepEqual(\n  realSet(\n    { low: 0, high: 33, rangeType: 1 },\n    { low: 30, high: 31, rangeType: 0 },\n    'intersect',\n    [30, 31, 32]\n  ),\n  [true, true, false]\n);"
    }
  ],
  "description": "<section id=\"description\">\n<p>All real numbers form the uncountable set ℝ. Among its subsets, relatively simple are the convex sets, each expressed as a range between two real numbers <em>a</em> and <em>b</em> where <em>a</em> ≤ <em>b</em>. There are actually four cases for the meaning of \"between\", depending on open or closed boundary:</p>\n<ul>\n  <li>[<i>a</i>, <i>b</i>]: {<i>x</i> | <i>a</i> ≤ <i>x</i> and <i>x</i> ≤ <i>b</i> }</li>\n  <li>(<i>a</i>, <i>b</i>): {<i>x</i> | <i>a</i> < <i>x</i> and <i>x</i> < <i>b</i> }</li>\n  <li>[<i>a</i>, <i>b</i>): {<i>x</i> | <i>a</i> ≤ <i>x</i> and <i>x</i> < <i>b</i> }</li>\n  <li>(<i>a</i>, <i>b</i>]: {<i>x</i> | <i>a</i> < <i>x</i> and <i>x</i> ≤ <i>b</i> }</li>\n</ul>\n<p>Note that if <em>a</em> = <em>b</em>, of the four only [<em>a</em>, <em>a</em>] would be non-empty.</p>\n<p><strong>Task</strong></p>\n<ul>\n  <li>Devise a way to represent any set of real numbers, for the definition of \"any\" in the implementation notes below.</li>\n  <li>Provide methods for these common set operations (<i>x</i> is a real number; <i>A</i> and <i>B</i> are sets):</li>\n  <ul>\n    <li>\n      <i>x</i> ∈ <i>A</i>: determine if <i>x</i> is an element of <i>A</i><br>\n      example: 1 is in [1, 2), while 2, 3, ... are not.\n    </li>\n    <li>\n      <i>A</i> ∪ <i>B</i>: union of <i>A</i> and <i>B</i>, i.e. {<i>x</i> | <i>x</i> ∈ <i>A</i> or <i>x</i> ∈ <i>B</i>}<br>\n      example: [0, 2) ∪ (1, 3) = [0, 3); [0, 1) ∪ (2, 3] = well, [0, 1) ∪ (2, 3]\n    </li>\n    <li>\n      <i>A</i> ∩ <i>B</i>: intersection of <i>A</i> and <i>B</i>, i.e. {<i>x</i> | <i>x</i> ∈ <i>A</i> and <i>x</i> ∈ <i>B</i>}<br>\n      example: [0, 2) ∩ (1, 3) = (1, 2); [0, 1) ∩ (2, 3] = empty set\n    </li>\n    <li>\n      <i>A</i> - <i>B</i>: difference between <i>A</i> and <i>B</i>, also written as <i>A</i> \\ <i>B</i>, i.e. {<i>x</i> | <i>x</i> ∈ <i>A</i> and <i>x</i> ∉ <i>B</i>}<br>\n      example: [0, 2) − (1, 3) = [0, 1]\n    </li>\n  </ul>\n</ul>\n</section>",
  "instructions": "<section id=\"instructions\">\n<p>Write a function that takes 2 objects, a string and an array as parameters. The objects represents the set and have attributes: <code>low</code>, <code>high</code> and <code>rangeType</code>.</p>\n<p>The <code>rangeType</code> can have values 0, 1, 2 and 3 for <code>CLOSED</code>, <code>BOTH_OPEN</code>, <code>LEFT_OPEN</code> and <code>RIGHT_OPEN</code>, respectively. The function should implement a set using this information.</p>\n<p>The string represents the operation to be performed on the sets. It can be: <code>\"union\"</code>, <code>\"intersect\"</code> and <code>\"subtract\"</code> (difference).</p>\n<p>After performing the operation, the function should check if the values in the array are present in the resultant set and store a corresponding boolean value to an array. The function should return this array.</p>\n</section>",
  "translationPending": false,
  "block": "rosetta-code-challenges",
  "hasEditableBoundaries": false,
  "order": 0,
  "superOrder": 17,
  "certification": "rosetta-code",
  "superBlock": "rosetta-code",
  "challengeOrder": 113,
  "required": [],
  "helpCategory": "Rosetta",
  "usesMultifileEditor": false,
  "disableLoopProtectTests": true,
  "disableLoopProtectPreview": false
}