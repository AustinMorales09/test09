{
  "id": "587d8257367417b2b2512c7c",
  "title": "Check if an Element is Present in a Binary Search Tree",
  "challengeType": 1,
  "forumTopicId": 301623,
  "dashedName": "check-if-an-element-is-present-in-a-binary-search-tree",
  "challengeFiles": [
    {
      "head": "",
      "tail": "BinarySearchTree.prototype = Object.assign(\n  BinarySearchTree.prototype,\n  {\n    add: function(value) {\n      var node = this.root;\n      if (node == null) {\n        this.root = new Node(value);\n        return;\n      } else {\n        function searchTree(node) {\n          if (value < node.value) {\n            if (node.left == null) {\n              node.left = new Node(value);\n              return;\n            } else if (node.left != null) {\n              return searchTree(node.left);\n            }\n          } else if (value > node.value) {\n            if (node.right == null) {\n              node.right = new Node(value);\n              return;\n            } else if (node.right != null) {\n              return searchTree(node.right);\n            }\n          } else {\n            return null;\n          }\n        }\n        return searchTree(node);\n      }\n    }\n  }\n);",
      "id": "",
      "editableRegionBoundaries": [],
      "history": [
        "script.js"
      ],
      "name": "script",
      "ext": "js",
      "path": "script.js",
      "fileKey": "scriptjs",
      "contents": "var displayTree = tree => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\nfunction BinarySearchTree() {\n  this.root = null;\n  // Only change code below this line\n  \n  // Only change code above this line\n}",
      "error": null,
      "seed": "var displayTree = tree => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\nfunction BinarySearchTree() {\n  this.root = null;\n  // Only change code below this line\n  \n  // Only change code above this line\n}"
    }
  ],
  "solutions": [
    [
      {
        "head": "",
        "tail": "",
        "id": "",
        "history": [
          "script.js"
        ],
        "name": "script",
        "ext": "js",
        "path": "script.js",
        "fileKey": "scriptjs",
        "contents": "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\nfunction BinarySearchTree() {\n  this.root = null;\n  this.isPresent = function (value) {\n    var current = this.root\n    while (current) {\n      if (value === current.value) {\n        return true;\n      }\n      current = value < current.value ? current.left : current.right;\n    }\n    return false;\n  }\n}",
        "error": null,
        "seed": "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\nfunction BinarySearchTree() {\n  this.root = null;\n  this.isPresent = function (value) {\n    var current = this.root\n    while (current) {\n      if (value === current.value) {\n        return true;\n      }\n      current = value < current.value ? current.left : current.right;\n    }\n    return false;\n  }\n}"
      }
    ]
  ],
  "assignments": [],
  "tests": [
    {
      "text": "<p>The <code>BinarySearchTree</code> data structure should exist.</p>",
      "testString": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    }\n    return typeof test == 'object';\n  })()\n);"
    },
    {
      "text": "<p>The binary search tree should have a method called <code>isPresent</code>.</p>",
      "testString": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    return typeof test.isPresent == 'function';\n  })()\n);"
    },
    {
      "text": "<p>The <code>isPresent</code> method should correctly check for the presence or absence of elements added to the tree.</p>",
      "testString": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.isPresent !== 'function') {\n      return false;\n    }\n    test.add(4);\n    test.add(7);\n    test.add(411);\n    test.add(452);\n    return (\n      test.isPresent(452) &&\n      test.isPresent(411) &&\n      test.isPresent(7) &&\n      !test.isPresent(100)\n    );\n  })()\n);"
    },
    {
      "text": "<p><code>isPresent</code> should handle cases where the tree is empty.</p>",
      "testString": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.isPresent !== 'function') {\n      return false;\n    }\n    return test.isPresent(5) == false;\n  })()\n);"
    }
  ],
  "description": "<section id=\"description\">\n<p>Now that we have a general sense of what a binary search tree is let's talk about it in a little more detail. Binary search trees provide logarithmic time for the common operations of lookup, insertion, and deletion in the average case, and linear time in the worst case. Why is this? Each of those basic operations requires us to find an item in the tree (or in the case of insertion to find where it should go) and because of the tree structure at each parent node we are branching left or right and effectively excluding half the size of the remaining tree. This makes the search proportional to the logarithm of the number of nodes in the tree, which creates logarithmic time for these operations in the average case. Ok, but what about the worst case? Well, consider constructing a tree from the following values, adding them left to right: <code>10</code>, <code>12</code>, <code>17</code>, <code>25</code>. Following our rules for a binary search tree, we will add <code>12</code> to the right of <code>10</code>, <code>17</code> to the right of this, and <code>25</code> to the right of this. Now our tree resembles a linked list and traversing it to find <code>25</code> would require us to traverse all the items in linear fashion. Hence, linear time in the worst case. The problem here is that the tree is unbalanced. We'll look a little more into what this means in the following challenges.</p>\n</section>",
  "instructions": "<section id=\"instructions\">\n<p>In this challenge, we will create a utility for our tree. Write a method <code>isPresent</code> which takes an integer value as input and returns a boolean value for the presence or absence of that value in the binary search tree.</p>\n</section>",
  "translationPending": false,
  "block": "data-structures",
  "hasEditableBoundaries": false,
  "order": 1,
  "superOrder": 15,
  "certification": "coding-interview-prep",
  "superBlock": "coding-interview-prep",
  "challengeOrder": 28,
  "required": [],
  "helpCategory": "JavaScript",
  "usesMultifileEditor": false,
  "disableLoopProtectTests": false,
  "disableLoopProtectPreview": false
}