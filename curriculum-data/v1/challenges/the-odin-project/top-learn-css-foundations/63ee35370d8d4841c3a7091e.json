{
  "id": "63ee35370d8d4841c3a7091e",
  "videoId": "LGQuIIv2RVA",
  "title": "CSS Foundations Question E",
  "challengeType": 15,
  "dashedName": "css-foundations-question-e",
  "solutions": [],
  "question": {
    "text": "<p>What does the descendant combinator do?</p>",
    "answers": [
      {
        "answer": "<p>It groups certain classes together which share the same declarations.</p>",
        "feedback": null
      },
      {
        "answer": "<p>It gives the ability to select an element that shares the same <code>class</code> and <code>id</code>.</p>",
        "feedback": null
      },
      {
        "answer": "<p>It allows you to select an element based on its relationship with its ancestor (parent, grandparent, and so on).</p>",
        "feedback": null
      }
    ],
    "solution": 3
  },
  "assignments": [],
  "tests": [],
  "description": "<section id=\"description\">\n<p>Combinators allow us to combine multiple selectors differently than either grouping or chaining them, as they show a relationship between the selectors. There are four types of combinators in total, but for right now we’re going to only show you the descendant combinator, which is represented in CSS by a single space between selectors. A descendant combinator will only cause elements that match the last selector to be selected if they also have an ancestor (parent, grandparent, etc) that matches the previous selector.</p>\n<p>So something like <code>.ancestor .child</code> would select an element with the class <code>child</code> if it has an ancestor with the class <code>ancestor</code>. Another way to think of it is child will only be selected if it is nested inside of <code>ancestor</code>, no matter how deep. Take a quick look at the example below and see if you can tell which elements would be selected based on the CSS rule provided:</p>\n<pre><code class=\"language-html\">&#x3C;!-- index.html -->\n\n&#x3C;div class=\"ancestor\"> &#x3C;!-- A -->\n  &#x3C;div class=\"contents\"> &#x3C;!-- B -->\n    &#x3C;div class=\"contents\"> &#x3C;!-- C -->\n    &#x3C;/div>\n  &#x3C;/div>\n&#x3C;/div>\n\n&#x3C;div class=\"contents\">&#x3C;/div> &#x3C;!-- D -->\n</code></pre>\n<pre><code class=\"language-css\">/* styles.css */\n\n.ancestor .contents {\n  /* some declarations */\n}\n</code></pre>\n<p>In the above example, the first two elements with the <code>contents</code> class (<code>B</code> and <code>C</code>) would be selected, but that last element (<code>D</code>) won’t be. Was your guess correct?</p>\n<p>There’s really no limit to how many combinators you can add to a rule, so <code>.one .two .three .four</code> would be totally valid. This would just select an element that has a class of <code>four</code> if it has an ancestor with a class of <code>three</code>, and if that ancestor has its own ancestor with a class of <code>two</code>, and so on. You generally want to avoid trying to select elements that need this level of nesting, though, as it can get pretty confusing and long, and it can cause issues when it comes to specificity.</p>\n</section>",
  "translationPending": false,
  "block": "top-learn-css-foundations",
  "hasEditableBoundaries": false,
  "order": 4,
  "superOrder": 14,
  "certification": "the-odin-project",
  "superBlock": "the-odin-project",
  "challengeOrder": 4,
  "required": [],
  "helpCategory": "Odin",
  "usesMultifileEditor": false,
  "disableLoopProtectTests": false,
  "disableLoopProtectPreview": false
}