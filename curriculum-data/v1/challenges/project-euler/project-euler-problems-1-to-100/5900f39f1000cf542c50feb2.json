{
  "id": "5900f39f1000cf542c50feb2",
  "title": "Problem 51: Prime digit replacements",
  "challengeType": 1,
  "forumTopicId": 302162,
  "dashedName": "problem-51-prime-digit-replacements",
  "challengeFiles": [
    {
      "head": "",
      "tail": "",
      "id": "",
      "editableRegionBoundaries": [],
      "history": [
        "script.js"
      ],
      "name": "script",
      "ext": "js",
      "path": "script.js",
      "fileKey": "scriptjs",
      "contents": "function primeDigitReplacements(n) {\n\n  return true;\n}\n\nprimeDigitReplacements(6);",
      "error": null,
      "seed": "function primeDigitReplacements(n) {\n\n  return true;\n}\n\nprimeDigitReplacements(6);"
    }
  ],
  "solutions": [
    [
      {
        "head": "",
        "tail": "",
        "id": "",
        "history": [
          "script.js"
        ],
        "name": "script",
        "ext": "js",
        "path": "script.js",
        "fileKey": "scriptjs",
        "contents": "class PrimeSeive {\n  constructor(num) {\n    const seive = Array(Math.floor((num - 1) / 2)).fill(true);\n    const upper = Math.floor((num - 1) / 2);\n    const sqrtUpper = Math.floor((Math.sqrt(num) - 1) / 2);\n\n    for (let i = 0; i <= sqrtUpper; i++) {\n      if (seive[i]) {\n        // Mark value in seive array\n        const prime = 2 * i + 3;\n        // Mark all multiples of this number as false (not prime)\n        const primeSquaredIndex = 2 * i ** 2 + 6 * i + 3;\n        for (let j = primeSquaredIndex; j < upper; j += prime) {\n          seive[j] = false;\n        }\n      }\n    }\n\n    this._seive = seive;\n  }\n\n  isPrime(num) {\n    return num === 2\n      ? true\n      : num % 2 === 0\n        ? false\n        : this.isOddPrime(num);\n  }\n\n  isOddPrime(num) {\n    return this._seive[(num - 3) / 2];\n  }\n};\n\nfunction primeDigitReplacements(n) {\n  const primeSeive = new PrimeSeive(n * n * n * 2000);\n\n  function isNFamily(number, n) {\n    const prime = number.toString();\n    const lastDigit = prime[prime.length - 1];\n    return doesReplacingMakeFamily(prime, '0', n) ||\n      doesReplacingMakeFamily(prime, '2', n) ||\n      (lastDigit !== '1' && doesReplacingMakeFamily(prime, '1', n));\n  }\n\n  function doesReplacingMakeFamily(prime, digitToReplace, family) {\n    let miss = 0;\n    const base = parseInt(\n      prime\n        .split('')\n        .map(digit => digit == digitToReplace ? '0' : digit)\n        .join('')\n    );\n    const replacements = parseInt(\n      prime\n        .split('')\n        .map(digit => digit === digitToReplace ? '1' : '0')\n        .join('')\n    );\n    const start = prime[0] === digitToReplace ? 1 : 0;\n    for (let i = start; i < 10; i++) {\n      const nextNumber = base + i * replacements;\n      if (!isPartOfFamily(nextNumber, prime)) miss++;\n      if (10 - start - miss < family) break;\n    }\n    return 10 - start - miss === family;\n  }\n\n  function isPartOfFamily(number, prime) {\n    return (\n      primeSeive.isPrime(number) && number.toString().length === prime.length\n    );\n  }\n\n  for (let number = 1; number < 125000; number++) {\n    if (primeSeive.isPrime(number) && isNFamily(number, n)) {\n      return number;\n    }\n  }\n  return -1;\n}",
        "error": null,
        "seed": "class PrimeSeive {\n  constructor(num) {\n    const seive = Array(Math.floor((num - 1) / 2)).fill(true);\n    const upper = Math.floor((num - 1) / 2);\n    const sqrtUpper = Math.floor((Math.sqrt(num) - 1) / 2);\n\n    for (let i = 0; i <= sqrtUpper; i++) {\n      if (seive[i]) {\n        // Mark value in seive array\n        const prime = 2 * i + 3;\n        // Mark all multiples of this number as false (not prime)\n        const primeSquaredIndex = 2 * i ** 2 + 6 * i + 3;\n        for (let j = primeSquaredIndex; j < upper; j += prime) {\n          seive[j] = false;\n        }\n      }\n    }\n\n    this._seive = seive;\n  }\n\n  isPrime(num) {\n    return num === 2\n      ? true\n      : num % 2 === 0\n        ? false\n        : this.isOddPrime(num);\n  }\n\n  isOddPrime(num) {\n    return this._seive[(num - 3) / 2];\n  }\n};\n\nfunction primeDigitReplacements(n) {\n  const primeSeive = new PrimeSeive(n * n * n * 2000);\n\n  function isNFamily(number, n) {\n    const prime = number.toString();\n    const lastDigit = prime[prime.length - 1];\n    return doesReplacingMakeFamily(prime, '0', n) ||\n      doesReplacingMakeFamily(prime, '2', n) ||\n      (lastDigit !== '1' && doesReplacingMakeFamily(prime, '1', n));\n  }\n\n  function doesReplacingMakeFamily(prime, digitToReplace, family) {\n    let miss = 0;\n    const base = parseInt(\n      prime\n        .split('')\n        .map(digit => digit == digitToReplace ? '0' : digit)\n        .join('')\n    );\n    const replacements = parseInt(\n      prime\n        .split('')\n        .map(digit => digit === digitToReplace ? '1' : '0')\n        .join('')\n    );\n    const start = prime[0] === digitToReplace ? 1 : 0;\n    for (let i = start; i < 10; i++) {\n      const nextNumber = base + i * replacements;\n      if (!isPartOfFamily(nextNumber, prime)) miss++;\n      if (10 - start - miss < family) break;\n    }\n    return 10 - start - miss === family;\n  }\n\n  function isPartOfFamily(number, prime) {\n    return (\n      primeSeive.isPrime(number) && number.toString().length === prime.length\n    );\n  }\n\n  for (let number = 1; number < 125000; number++) {\n    if (primeSeive.isPrime(number) && isNFamily(number, n)) {\n      return number;\n    }\n  }\n  return -1;\n}"
      }
    ]
  ],
  "assignments": [],
  "tests": [
    {
      "text": "<p><code>primeDigitReplacements(6)</code> should return a number.</p>",
      "testString": "assert(typeof primeDigitReplacements(6) === 'number');"
    },
    {
      "text": "<p><code>primeDigitReplacements(6)</code> should return <code>13</code>.</p>",
      "testString": "assert.strictEqual(primeDigitReplacements(6), 13);"
    },
    {
      "text": "<p><code>primeDigitReplacements(7)</code> should return <code>56003</code>.</p>",
      "testString": "assert.strictEqual(primeDigitReplacements(7), 56003);"
    },
    {
      "text": "<p><code>primeDigitReplacements(8)</code> should return <code>121313</code>.</p>",
      "testString": "assert.strictEqual(primeDigitReplacements(8), 121313);"
    }
  ],
  "description": "<section id=\"description\">\n<p>By replacing the 1st digit of the 2-digit number *3, it turns out that six of the nine possible values: 13, 23, 43, 53, 73, and 83, are all prime.</p>\n<p>By replacing the 3rd and 4th digits of 56**3 with the same digit, this 5-digit number is the first example having seven primes among the ten generated numbers, yielding the family: 56003, 56113, 56333, 56443, 56663, 56773, and 56993. Consequently 56003, being the first member of this family, is the smallest prime with this property.</p>\n<p>Find the smallest prime which, by replacing part of the number (not necessarily adjacent digits) with the same digit, is part of an <code>n</code> prime value family.</p>\n</section>",
  "translationPending": false,
  "block": "project-euler-problems-1-to-100",
  "hasEditableBoundaries": false,
  "order": 0,
  "superOrder": 16,
  "certification": "project-euler",
  "superBlock": "project-euler",
  "challengeOrder": 50,
  "required": [],
  "helpCategory": "Euler",
  "usesMultifileEditor": false,
  "disableLoopProtectTests": true,
  "disableLoopProtectPreview": false
}