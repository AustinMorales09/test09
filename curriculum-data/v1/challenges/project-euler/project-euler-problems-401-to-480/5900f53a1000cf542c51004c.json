{
  "id": "5900f53a1000cf542c51004c",
  "title": "Problem 461: Almost Pi",
  "challengeType": 1,
  "forumTopicId": 302136,
  "dashedName": "problem-461-almost-pi",
  "challengeFiles": [
    {
      "head": "",
      "tail": "",
      "id": "",
      "editableRegionBoundaries": [],
      "history": [
        "script.js"
      ],
      "name": "script",
      "ext": "js",
      "path": "script.js",
      "fileKey": "scriptjs",
      "contents": "function almostPi(n) {\n  \n  return true;\n}",
      "error": null,
      "seed": "function almostPi(n) {\n  \n  return true;\n}"
    }
  ],
  "solutions": [
    [
      {
        "head": "",
        "tail": "",
        "id": "",
        "history": [
          "script.js"
        ],
        "name": "script",
        "ext": "js",
        "path": "script.js",
        "fileKey": "scriptjs",
        "contents": "function almostPi(n) {\n\n  // Find all possible values where f(k, n) <= PI\n  const f = [];\n  let max = 0;\n  while (1) {\n    let current = Math.exp(max / n) - 1;\n\n    if (current > Math.PI) break;\n\n    f.push(current);\n    ++max;\n  }\n\n  // Get all pairs where f[i] + f[j] <= PI\n  const pairs = [];\n  for (let i = 0; i < max; ++i) {\n    for (let j = 0; j < max; ++j) {\n      if (f[i] + f[j] > Math.PI) break;\n      pairs.push(f[i] + f[j]);\n    }\n  }\n\n  // Sort all values\n  pairs.sort((a, b) => a - b);\n\n  // Optimal Value for (a + b)\n  let left = 0;\n  // Optimal Value for (c + d)\n  let right = 0;\n  // minimum error with Math.abs(a + b - Math.PI)\n  let minError = Math.PI;\n\n  // Binary Search for the best match\n  for (let i = 0; i < pairs.length; ++i) {\n    let current = pairs[i];\n    let need = Math.PI - current;\n\n    if (need < current) break;\n\n    let match;\n    for (let i = 1; i < pairs.length; ++i) {\n      if (pairs[i] > need) {\n        match = i;\n        break;\n      }\n    }\n\n    let error = Math.abs(need - pairs[match]);\n    if (error < minError)\n    {\n      minError = error;\n      left = i;\n      right = match;\n    }\n\n    --match;\n    error = Math.abs(need - pairs[match]);\n    if (error < minError) {\n      minError = error;\n      left = i;\n      right = match;\n    }\n  }\n\n  let a, b, c, d;\n\n  OuterLoop1:\n  for (a = 0; a < max; ++a) {\n    for (b = a; b < max; ++b) {\n      if (pairs[left] == f[a] + f[b]) {\n        break OuterLoop1;\n      }\n    }\n  }\n\n  OuterLoop2:\n  for (c = 0; c < max; ++c) {\n    for (d = c; d < max; ++d) {\n      if (pairs[right] == f[c] + f[d]) {\n        break OuterLoop2;\n      }\n    }\n  }\n  return a*a + b*b + c*c + d*d;\n}",
        "error": null,
        "seed": "function almostPi(n) {\n\n  // Find all possible values where f(k, n) <= PI\n  const f = [];\n  let max = 0;\n  while (1) {\n    let current = Math.exp(max / n) - 1;\n\n    if (current > Math.PI) break;\n\n    f.push(current);\n    ++max;\n  }\n\n  // Get all pairs where f[i] + f[j] <= PI\n  const pairs = [];\n  for (let i = 0; i < max; ++i) {\n    for (let j = 0; j < max; ++j) {\n      if (f[i] + f[j] > Math.PI) break;\n      pairs.push(f[i] + f[j]);\n    }\n  }\n\n  // Sort all values\n  pairs.sort((a, b) => a - b);\n\n  // Optimal Value for (a + b)\n  let left = 0;\n  // Optimal Value for (c + d)\n  let right = 0;\n  // minimum error with Math.abs(a + b - Math.PI)\n  let minError = Math.PI;\n\n  // Binary Search for the best match\n  for (let i = 0; i < pairs.length; ++i) {\n    let current = pairs[i];\n    let need = Math.PI - current;\n\n    if (need < current) break;\n\n    let match;\n    for (let i = 1; i < pairs.length; ++i) {\n      if (pairs[i] > need) {\n        match = i;\n        break;\n      }\n    }\n\n    let error = Math.abs(need - pairs[match]);\n    if (error < minError)\n    {\n      minError = error;\n      left = i;\n      right = match;\n    }\n\n    --match;\n    error = Math.abs(need - pairs[match]);\n    if (error < minError) {\n      minError = error;\n      left = i;\n      right = match;\n    }\n  }\n\n  let a, b, c, d;\n\n  OuterLoop1:\n  for (a = 0; a < max; ++a) {\n    for (b = a; b < max; ++b) {\n      if (pairs[left] == f[a] + f[b]) {\n        break OuterLoop1;\n      }\n    }\n  }\n\n  OuterLoop2:\n  for (c = 0; c < max; ++c) {\n    for (d = c; d < max; ++d) {\n      if (pairs[right] == f[c] + f[d]) {\n        break OuterLoop2;\n      }\n    }\n  }\n  return a*a + b*b + c*c + d*d;\n}"
      }
    ]
  ],
  "assignments": [],
  "tests": [
    {
      "text": "<p><code>almostPi</code> should be a function.</p>",
      "testString": "assert(typeof almostPi === 'function')"
    },
    {
      "text": "<p><code>almostPi</code> should return a number.</p>",
      "testString": "assert.strictEqual(typeof almostPi(10), 'number');"
    },
    {
      "text": "<p><code>almostPi(29)</code> should return <code>1208</code>.</p>",
      "testString": "assert.strictEqual(almostPi(29), 1208);"
    },
    {
      "text": "<p><code>almostPi(50)</code> should return <code>4152</code>.</p>",
      "testString": "assert.strictEqual(almostPi(50), 4152);"
    },
    {
      "text": "<p><code>almostPi(200)</code> should return <code>64658</code>.</p>",
      "testString": "assert.strictEqual(almostPi(200), 64658);"
    }
  ],
  "description": "<section id=\"description\">\n<p>Let <code>f(k, n)</code> = $e^\\frac{k}{n} - 1$, for all non-negative integers <code>k</code>.</p>\n<p>Remarkably, <code>f(6, 200) + f(75, 200) + f(89, 200) + f(226, 200)</code> = 3.1415926… ≈ π.</p>\n<p>In fact, it is the best approximation of π of the form <code>f(a, 200) + f(b, 200) + f(c, 200) + f(d, 200)</code>.</p>\n<p>Let <code>almostPi(n)</code> = a<sup>2</sup> + b<sup>2</sup> + c<sup>2</sup> + d<sup>2</sup> for a, b, c, d that minimize the error: $\\lvert f(a,n) + f(b,n) + f(c,n) + f(d,n) - \\Pi\\rvert$</p>\n<p>You are given <code>almostPi(200)</code> = 6<sup>2</sup> + 75<sup>2</sup> + 89<sup>2</sup> + 226<sup>2</sup> = 64658.</p>\n</section>",
  "translationPending": false,
  "block": "project-euler-problems-401-to-480",
  "hasEditableBoundaries": false,
  "order": 4,
  "superOrder": 16,
  "certification": "project-euler",
  "superBlock": "project-euler",
  "challengeOrder": 60,
  "required": [],
  "helpCategory": "Euler",
  "usesMultifileEditor": false,
  "disableLoopProtectTests": true,
  "disableLoopProtectPreview": false
}