(()=>{var e,n,t,r,i={6632:e=>{var n,t,r=e.exports={};function i(){throw new Error("setTimeout has not been defined")}function o(){throw new Error("clearTimeout has not been defined")}function s(e){if(n===setTimeout)return setTimeout(e,0);if((n===i||!n)&&setTimeout)return n=setTimeout,setTimeout(e,0);try{return n(e,0)}catch(t){try{return n.call(null,e,0)}catch(t){return n.call(this,e,0)}}}!function(){try{n="function"==typeof setTimeout?setTimeout:i}catch(e){n=i}try{t="function"==typeof clearTimeout?clearTimeout:o}catch(e){t=o}}();var a,l=[],f=!1,d=-1;function c(){f&&a&&(f=!1,a.length?l=a.concat(l):d=-1,l.length&&u())}function u(){if(!f){var e=s(c);f=!0;for(var n=l.length;n;){for(a=l,l=[];++d<n;)a&&a[d].run();d=-1,n=l.length}a=null,f=!1,function(e){if(t===clearTimeout)return clearTimeout(e);if((t===o||!t)&&clearTimeout)return t=clearTimeout,clearTimeout(e);try{return t(e)}catch(n){try{return t.call(null,e)}catch(n){return t.call(this,e)}}}(e)}}function p(e,n){this.fun=e,this.array=n}function _(){}r.nextTick=function(e){var n=new Array(arguments.length-1);if(arguments.length>1)for(var t=1;t<arguments.length;t++)n[t-1]=arguments[t];l.push(new p(e,n)),1!==l.length||f||s(u)},p.prototype.run=function(){this.fun.apply(null,this.array)},r.title="browser",r.browser=!0,r.env={},r.argv=[],r.version="",r.versions={},r.on=_,r.addListener=_,r.once=_,r.off=_,r.removeListener=_,r.removeAllListeners=_,r.emit=_,r.prependListener=_,r.prependOnceListener=_,r.listeners=function(e){return[]},r.binding=function(e){throw new Error("process.binding is not supported")},r.cwd=function(){return"/"},r.chdir=function(e){throw new Error("process.chdir is not supported")},r.umask=function(){return 0}},3392:function(e,n,t){var r=t(6632);!function(e){"use strict";"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:void 0!==t.g?t.g:"undefined"!=typeof self&&self;var n,i,o,s,a={exports:{}},l={exports:{}};l.exports=function(){function e(e){return e.charAt(0).toUpperCase()+e.substring(1)}function n(e){return function(){return this[e]}}var t=["isConstructor","isEval","isNative","isToplevel"],r=["columnNumber","lineNumber"],i=["fileName","functionName","source"],o=t.concat(r,i,["args"],["evalOrigin"]);function s(n){if(n)for(var t=0;t<o.length;t++)void 0!==n[o[t]]&&this["set"+e(o[t])](n[o[t]])}s.prototype={getArgs:function(){return this.args},setArgs:function(e){if("[object Array]"!==Object.prototype.toString.call(e))throw new TypeError("Args must be an Array");this.args=e},getEvalOrigin:function(){return this.evalOrigin},setEvalOrigin:function(e){if(e instanceof s)this.evalOrigin=e;else{if(!(e instanceof Object))throw new TypeError("Eval Origin must be an Object or StackFrame");this.evalOrigin=new s(e)}},toString:function(){var e=this.getFileName()||"",n=this.getLineNumber()||"",t=this.getColumnNumber()||"",r=this.getFunctionName()||"";return this.getIsEval()?e?"[eval] ("+e+":"+n+":"+t+")":"[eval]:"+n+":"+t:r?r+" ("+e+":"+n+":"+t+")":e+":"+n+":"+t}},s.fromString=function(e){var n=e.indexOf("("),t=e.lastIndexOf(")"),r=e.substring(0,n),i=e.substring(n+1,t).split(","),o=e.substring(t+1);if(0===o.indexOf("@"))var a=/@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(o,""),l=a[1],f=a[2],d=a[3];return new s({functionName:r,args:i||void 0,fileName:l,lineNumber:f||void 0,columnNumber:d||void 0})};for(var a=0;a<t.length;a++)s.prototype["get"+e(t[a])]=n(t[a]),s.prototype["set"+e(t[a])]=function(e){return function(n){this[e]=Boolean(n)}}(t[a]);for(var l=0;l<r.length;l++)s.prototype["get"+e(r[l])]=n(r[l]),s.prototype["set"+e(r[l])]=function(e){return function(n){if(t=n,isNaN(parseFloat(t))||!isFinite(t))throw new TypeError(e+" must be a Number");var t;this[e]=Number(n)}}(r[l]);for(var f=0;f<i.length;f++)s.prototype["get"+e(i[f])]=n(i[f]),s.prototype["set"+e(i[f])]=function(e){return function(n){this[e]=String(n)}}(i[f]);return s}(),a.exports=(n=l.exports,i=/(^|@)\S+:\d+/,o=/^\s*at .*(\S+:\d+|\(native\))/m,s=/^(eval@)?(\[native code])?$/,{parse:function(e){if(void 0!==e.stacktrace||void 0!==e["opera#sourceloc"])return this.parseOpera(e);if(e.stack&&e.stack.match(o))return this.parseV8OrIE(e);if(e.stack)return this.parseFFOrSafari(e);throw new Error("Cannot parse given Error object")},extractLocation:function(e){if(-1===e.indexOf(":"))return[e];var n=/(.+?)(?::(\d+))?(?::(\d+))?$/.exec(e.replace(/[()]/g,""));return[n[1],n[2]||void 0,n[3]||void 0]},parseV8OrIE:function(e){return e.stack.split("\n").filter((function(e){return!!e.match(o)}),this).map((function(e){e.indexOf("(eval ")>-1&&(e=e.replace(/eval code/g,"eval").replace(/(\(eval at [^()]*)|(,.*$)/g,""));var t=e.replace(/^\s+/,"").replace(/\(eval code/g,"(").replace(/^.*?\s+/,""),r=t.match(/ (\(.+\)$)/);t=r?t.replace(r[0],""):t;var i=this.extractLocation(r?r[1]:t),o=r&&t||void 0,s=["eval","<anonymous>"].indexOf(i[0])>-1?void 0:i[0];return new n({functionName:o,fileName:s,lineNumber:i[1],columnNumber:i[2],source:e})}),this)},parseFFOrSafari:function(e){return e.stack.split("\n").filter((function(e){return!e.match(s)}),this).map((function(e){if(e.indexOf(" > eval")>-1&&(e=e.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g,":$1")),-1===e.indexOf("@")&&-1===e.indexOf(":"))return new n({functionName:e});var t=/((.*".+"[^@]*)?[^@]*)(?:@)/,r=e.match(t),i=r&&r[1]?r[1]:void 0,o=this.extractLocation(e.replace(t,""));return new n({functionName:i,fileName:o[0],lineNumber:o[1],columnNumber:o[2],source:e})}),this)},parseOpera:function(e){return!e.stacktrace||e.message.indexOf("\n")>-1&&e.message.split("\n").length>e.stacktrace.split("\n").length?this.parseOpera9(e):e.stack?this.parseOpera11(e):this.parseOpera10(e)},parseOpera9:function(e){for(var t=/Line (\d+).*script (?:in )?(\S+)/i,r=e.message.split("\n"),i=[],o=2,s=r.length;o<s;o+=2){var a=t.exec(r[o]);a&&i.push(new n({fileName:a[2],lineNumber:a[1],source:r[o]}))}return i},parseOpera10:function(e){for(var t=/Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i,r=e.stacktrace.split("\n"),i=[],o=0,s=r.length;o<s;o+=2){var a=t.exec(r[o]);a&&i.push(new n({functionName:a[3]||void 0,fileName:a[2],lineNumber:a[1],source:r[o]}))}return i},parseOpera11:function(e){return e.stack.split("\n").filter((function(e){return!!e.match(i)&&!e.match(/^Error created at/)}),this).map((function(e){var t,r=e.split("@"),i=this.extractLocation(r.pop()),o=r.shift()||"",s=o.replace(/<anonymous function(: (\w+))?>/,"$2").replace(/\([^)]*\)/g,"")||void 0;o.match(/\(([^)]*)\)/)&&(t=o.replace(/^[^(]+\(([^)]*)\)$/,"$1"));var a=void 0===t||"[arguments not available]"===t?void 0:t.split(",");return new n({functionName:s,args:a,fileName:i[0],lineNumber:i[1],columnNumber:i[2],source:e})}),this)}});const f="object"==typeof r&&"object"==typeof r.versions&&"string"==typeof r.versions.node&&void 0===r.browser;let d,c,u,p,_,m,h,y,g;if(m=f?function(e,n){return u.resolve(n||".",e)}:function(e,n){return void 0===n&&(n=location),new URL(e,n).toString()},f||(h="/"),y=f?async function(e,n){if(e.startsWith("file://")&&(e=e.slice(7)),e.includes("://")){let n=await c(e);if(!n.ok)throw new Error(`Failed to load '${e}': request failed.`);return new Uint8Array(await n.arrayBuffer())}{const n=await _.readFile(e);return new Uint8Array(n.buffer,n.byteOffset,n.byteLength)}}:async function(e,n){const t=new URL(e,location);let r=n?{integrity:n}:{},i=await fetch(t,r);if(!i.ok)throw new Error(`Failed to load '${t}': request failed.`);return new Uint8Array(await i.arrayBuffer())},globalThis.document)g=async e=>await import(e);else if(globalThis.importScripts)g=async e=>{try{globalThis.importScripts(e)}catch(n){if(!(n instanceof TypeError))throw n;await import(e)}};else{if(!f)throw new Error("Cannot determine runtime environment");g=async function(e){e.startsWith("file://")&&(e=e.slice(7)),e.includes("://")?p.runInThisContext(await(await c(e)).text()):await import(d.pathToFileURL(e).href)}}function v(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var n,t=e[Symbol.asyncIterator];return t?t.call(e):(e=function(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")}(e),n={},r("next"),r("throw"),r("return"),n[Symbol.asyncIterator]=function(){return this},n);function r(t){n[t]=e[t]&&function(n){return new Promise((function(r,i){!function(e,n,t,r){Promise.resolve(r).then((function(n){e({value:n,done:t})}),n)}(r,i,(n=e[t](n)).done,n.value)}))}}}const E=async e=>{const n=[];await async function e(t){var r,i;try{for(var o,s=v(t.values());!(o=await s.next()).done;){const t=o.value;n.push(t),"directory"===t.kind&&await e(t)}}catch(e){r={error:e}}finally{try{o&&!o.done&&(i=s.return)&&await i.call(s)}finally{if(r)throw r.error}}}(e);const t=new Map;t.set(".",e);for(const r of n){const n=(await e.resolve(r)).join("/");t.set(n,r)}return t};async function b(e={}){await async function(){if(f)return d=(await t.e(856).then(t.t.bind(t,8856,23))).default,_=await t.e(41).then(t.t.bind(t,8041,23)),c=globalThis.fetch?fetch:(await t.e(480).then(t.t.bind(t,9480,23))).default,p=(await t.e(166).then(t.t.bind(t,2166,23))).default,u=await t.e(272).then(t.t.bind(t,3272,23)),void(h=u.sep)}();let n=e.indexURL||"/";n=m(n),n.endsWith("/")||(n+="/"),e.indexURL=n;const r={fullStdLib:!1,jsglobals:globalThis,stdin:globalThis.prompt?globalThis.prompt:void 0,homedir:"/home/pyodide",lockFileURL:n+"repodata.json",args:[],_node_mounts:[]},i=Object.assign(r,e),o=function(){let e={noImageDecoding:!0,noAudioDecoding:!0,noWasmDecoding:!1,preRun:[],quit:(n,t)=>{throw e.exited={status:n,toThrow:t},t}};return e}();o.print=i.stdout,o.printErr=i.stderr,o.arguments=i.args;const s={config:i};o.API=s,function(e,n){let t;t=null!=n.stdLibURL?n.stdLibURL:n.indexURL+"python_stdlib.zip",function(e,n){const t=y(n);e.preRun.push((()=>{const n=e._py_version_major(),r=e._py_version_minor();e.FS.mkdirTree("/lib"),e.FS.mkdirTree(`/lib/python${n}.${r}/site-packages`),e.addRunDependency("install-stdlib"),t.then((t=>{e.FS.writeFile(`/lib/python${n}${r}.zip`,t)})).catch((e=>{console.error("Error occurred while installing the standard library:"),console.error(e)})).finally((()=>{e.removeRunDependency("install-stdlib")}))}))}(e,t),function(e,n){e.preRun.push((function(){try{e.FS.mkdirTree(n)}catch(e){console.error(`Error occurred while making a home directory '${n}':`),console.error(e),console.error("Using '/' for a home directory instead"),n="/"}e.ENV.HOME=n,e.FS.chdir(n)}))}(e,n.homedir),function(e,n){e.preRun.push((()=>{for(const t of n)e.FS.mkdirTree(t),e.FS.mount(e.FS.filesystems.NODEFS,{root:t},t)}))}(e,n._node_mounts),e.preRun.push((()=>function(e){const n=e.FS,t=e.FS.filesystems.MEMFS,r=e.PATH,i={DIR_MODE:16895,FILE_MODE:33279,mount:function(e){if(!e.opts.fileSystemHandle)throw new Error("opts.fileSystemHandle is required");return t.mount.apply(null,arguments)},syncfs:async(e,n,t)=>{try{const r=i.getLocalSet(e),o=await i.getRemoteSet(e),s=n?o:r,a=n?r:o;await i.reconcile(e,s,a),t(null)}catch(e){t(e)}},getLocalSet:e=>{let t=Object.create(null);function i(e){return"."!==e&&".."!==e}function o(e){return n=>r.join2(e,n)}let s=n.readdir(e.mountpoint).filter(i).map(o(e.mountpoint));for(;s.length;){let e=s.pop(),r=n.stat(e);n.isDir(r.mode)&&s.push.apply(s,n.readdir(e).filter(i).map(o(e))),t[e]={timestamp:r.mtime,mode:r.mode}}return{type:"local",entries:t}},getRemoteSet:async e=>{const n=Object.create(null),t=await E(e.opts.fileSystemHandle);for(const[o,s]of t)"."!==o&&(n[r.join2(e.mountpoint,o)]={timestamp:"file"===s.kind?(await s.getFile()).lastModifiedDate:new Date,mode:"file"===s.kind?i.FILE_MODE:i.DIR_MODE});return{type:"remote",entries:n,handles:t}},loadLocalEntry:e=>{const r=n.lookupPath(e).node,i=n.stat(e);if(n.isDir(i.mode))return{timestamp:i.mtime,mode:i.mode};if(n.isFile(i.mode))return r.contents=t.getFileDataAsTypedArray(r),{timestamp:i.mtime,mode:i.mode,contents:r.contents};throw new Error("node type not supported")},storeLocalEntry:(e,t)=>{if(n.isDir(t.mode))n.mkdirTree(e,t.mode);else{if(!n.isFile(t.mode))throw new Error("node type not supported");n.writeFile(e,t.contents,{canOwn:!0})}n.chmod(e,t.mode),n.utime(e,t.timestamp,t.timestamp)},removeLocalEntry:e=>{var t=n.stat(e);n.isDir(t.mode)?n.rmdir(e):n.isFile(t.mode)&&n.unlink(e)},loadRemoteEntry:async e=>{if("file"===e.kind){const n=await e.getFile();return{contents:new Uint8Array(await n.arrayBuffer()),mode:i.FILE_MODE,timestamp:n.lastModifiedDate}}if("directory"===e.kind)return{mode:i.DIR_MODE,timestamp:new Date};throw new Error("unknown kind: "+e.kind)},storeRemoteEntry:async(e,t,i)=>{const o=e.get(r.dirname(t)),s=n.isFile(i.mode)?await o.getFileHandle(r.basename(t),{create:!0}):await o.getDirectoryHandle(r.basename(t),{create:!0});if("file"===s.kind){const e=await s.createWritable();await e.write(i.contents),await e.close()}e.set(t,s)},removeRemoteEntry:async(e,n)=>{const t=e.get(r.dirname(n));await t.removeEntry(r.basename(n)),e.delete(n)},reconcile:async(e,t,o)=>{let s=0;const a=[];Object.keys(t.entries).forEach((function(e){const r=t.entries[e],i=o.entries[e];(!i||n.isFile(r.mode)&&r.timestamp.getTime()>i.timestamp.getTime())&&(a.push(e),s++)})),a.sort();const l=[];if(Object.keys(o.entries).forEach((function(e){t.entries[e]||(l.push(e),s++)})),l.sort().reverse(),!s)return;const f="remote"===t.type?t.handles:o.handles;for(const n of a){const t=r.normalize(n.replace(e.mountpoint,"/")).substring(1);if("local"===o.type){const e=f.get(t),r=await i.loadRemoteEntry(e);i.storeLocalEntry(n,r)}else{const e=i.loadLocalEntry(n);await i.storeRemoteEntry(f,t,e)}}for(const n of l)if("local"===o.type)i.removeLocalEntry(n);else{const t=r.normalize(n.replace(e.mountpoint,"/")).substring(1);await i.removeRemoteEntry(f,t)}}};e.FS.filesystems.NATIVEFS_ASYNC=i}(e)))}(o,i);const a=new Promise((e=>o.postRun=e));if(o.locateFile=e=>i.indexURL+e,"function"!=typeof _createPyodideModule){const e=`${i.indexURL}pyodide.asm.js`;await g(e)}if(await _createPyodideModule(o),await a,o.exited)throw o.exited.toThrow;if("0.23.3"!==s.version)throw new Error(`Pyodide version does not match: '0.23.3' <==> '${s.version}'. If you updated the Pyodide version, make sure you also updated the 'indexURL' parameter passed to loadPyodide.`);o.locateFile=e=>{throw new Error("Didn't expect to load any more file_packager files!")};let[l,v]=s.rawRun("import _pyodide_core");l&&o.API.fatal_loading_error("Failed to import _pyodide_core\n",v);const b=function(e,n){e.runPythonInternal_dict=e._pyodide._base.eval_code("{}"),e.importlib=e.runPythonInternal("import importlib; importlib");let t=e.importlib.import_module;e.sys=t("sys"),e.sys.path.insert(0,n.homedir),e.os=t("os");let r=e.runPythonInternal("import __main__; __main__.__dict__"),i=e.runPythonInternal("import builtins; builtins.__dict__");var o;e.globals=(o=i,new Proxy(r,{get:(e,n)=>"get"===n?n=>{let t=e.get(n);return void 0===t&&(t=o.get(n)),t}:"has"===n?n=>e.has(n)||o.has(n):Reflect.get(e,n)}));let s=e._pyodide._importhook;s.register_js_finder(),s.register_js_module("js",n.jsglobals);let a=e.makePublicAPI();return s.register_js_module("pyodide_js",a),e.pyodide_py=t("pyodide"),e.pyodide_code=t("pyodide.code"),e.pyodide_ffi=t("pyodide.ffi"),e.package_loader=t("pyodide._package_loader"),e.sitepackages=e.package_loader.SITE_PACKAGES.__str__(),e.dsodir=e.package_loader.DSO_DIR.__str__(),e.defaultLdLibraryPath=[e.dsodir,e.sitepackages],e.os.environ.__setitem__("LD_LIBRARY_PATH",e.defaultLdLibraryPath.join(":")),a.pyodide_py=e.pyodide_py,a.globals=e.globals,a}(s,i);if(b.version.includes("dev")||s.setCdnUrl(`https://cdn.jsdelivr.net/pyodide/v${b.version}/full/`),await s.packageIndexReady,s._pyodide._importhook.register_module_not_found_hook(s._import_name_to_package_name,s.repodata_unvendored_stdlibs_and_test),"0.23.3"!==s.repodata_info.version)throw new Error("Lock file version doesn't match Pyodide version");return s.package_loader.init_loaded_packages(),i.fullStdLib&&await b.loadPackage(s.repodata_unvendored_stdlibs),s.initializeStreams(i.stdin,i.stdout,i.stderr),b}globalThis.loadPyodide=b,e.loadPyodide=b,e.version="0.23.3",Object.defineProperty(e,"__esModule",{value:!0})}(n)}},o={};function s(e){var n=o[e];if(void 0!==n)return n.exports;var t=o[e]={exports:{}};return i[e].call(t.exports,t,t.exports,s),t.exports}s.m=i,n=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,s.t=function(t,r){if(1&r&&(t=this(t)),8&r)return t;if("object"==typeof t&&t){if(4&r&&t.__esModule)return t;if(16&r&&"function"==typeof t.then)return t}var i=Object.create(null);s.r(i);var o={};e=e||[null,n({}),n([]),n(n)];for(var a=2&r&&t;"object"==typeof a&&!~e.indexOf(a);a=n(a))Object.getOwnPropertyNames(a).forEach((e=>o[e]=()=>t[e]));return o.default=()=>t,s.d(i,o),i},s.d=(e,n)=>{for(var t in n)s.o(n,t)&&!s.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},s.f={},s.e=e=>Promise.all(Object.keys(s.f).reduce(((n,t)=>(s.f[t](e,n),n)),[])),s.u=e=>e+"-"+{41:"c9af61973fa1930d8ba4",166:"af99a3805e8b3cb19601",256:"7f831494e216fd130ffe",272:"de138e5dc28f4ab9842a",480:"ba1359f46600d65aced7",698:"b34206c0fcf0200750b4",839:"f36715f2eb8f5367c1f1",856:"13e57d7d1111bd7a312e",899:"5fa41c68b1bc87ee516f"}[e]+".js",s.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),s.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),t={},r="@freecodecamp/browser-scripts:",s.l=(e,n,i,o)=>{if(t[e])t[e].push(n);else{var a,l;if(void 0!==i)for(var f=document.getElementsByTagName("script"),d=0;d<f.length;d++){var c=f[d];if(c.getAttribute("src")==e||c.getAttribute("data-webpack")==r+i){a=c;break}}a||(l=!0,(a=document.createElement("script")).charset="utf-8",a.timeout=120,s.nc&&a.setAttribute("nonce",s.nc),a.setAttribute("data-webpack",r+i),a.src=e),t[e]=[n];var u=(n,r)=>{a.onerror=a.onload=null,clearTimeout(p);var i=t[e];if(delete t[e],a.parentNode&&a.parentNode.removeChild(a),i&&i.forEach((e=>e(r))),n)return n(r)},p=setTimeout(u.bind(null,void 0,{type:"timeout",target:a}),12e4);a.onerror=u.bind(null,a.onerror),a.onload=u.bind(null,a.onload),l&&document.head.appendChild(a)}},s.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.p="/js/",(()=>{var e={96:0};s.f.j=(n,t)=>{var r=s.o(e,n)?e[n]:void 0;if(0!==r)if(r)t.push(r[2]);else{var i=new Promise(((t,i)=>r=e[n]=[t,i]));t.push(r[2]=i);var o=s.p+s.u(n),a=new Error;s.l(o,(t=>{if(s.o(e,n)&&(0!==(r=e[n])&&(e[n]=void 0),r)){var i=t&&("load"===t.type?"missing":t.type),o=t&&t.target&&t.target.src;a.message="Loading chunk "+n+" failed.\n("+i+": "+o+")",a.name="ChunkLoadError",a.type=i,a.request=o,r[1](a)}}),"chunk-"+n,n)}};var n=(n,t)=>{var r,i,[o,a,l]=t,f=0;if(o.some((n=>0!==e[n]))){for(r in a)s.o(a,r)&&(s.m[r]=a[r]);l&&l(s)}for(n&&n(t);f<o.length;f++)i=o[f],s.o(e,i)&&e[i]&&e[i][0](),e[i]=0},t=self.webpackChunk_freecodecamp_browser_scripts=self.webpackChunk_freecodecamp_browser_scripts||[];t.forEach(n.bind(null,0)),t.push=n.bind(null,t.push.bind(t))})(),(()=>{"use strict";var e=s(3392);const n="0.23.3";var t={d:(e,n)=>{for(var r in n)t.o(n,r)&&!t.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:n[r]})},o:(e,n)=>Object.prototype.hasOwnProperty.call(e,n)},r={};t.d(r,{Z5:()=>w,yS:()=>E,Nt:()=>g,jX:()=>N,US:()=>v,Hg:()=>b,ep:()=>m,gu:()=>_,Gs:()=>h,Sc:()=>y});const i=(e,n={})=>{const t=!0===n.safe||!0===n.keepProtected;let r=!1;const i=e=>{let o,s,a="";if("nodes"in e)for(const l of e.nodes)switch(l.type){case"block":if(n.first&&!0===r){a+=i(l);break}if(!0===n.preserveNewlines){o=i(l),s=o.split("\n"),a+="\n".repeat(s.length-1);break}if(!0===t&&!0===l.protected){a+=i(l);break}r=!0;break;case"line":if(n.first&&!0===r){a+=l.value;break}!0===t&&!0===l.protected&&(a+=l.value),r=!0;break;default:a+=l.value||""}return a};return i(e)};class o{constructor(e){this.type=e.type,this.value=e.value,this.match=e.match,this.newline=e.newline||""}get protected(){return Boolean(this.match&&"!"===this.match[1])}}class a extends o{constructor(e){super(e),this.nodes=(null==e?void 0:e.nodes)||[]}push(e){this.nodes.push(e)}get protected(){return this.nodes.length>0&&!0===this.nodes[0].protected}}const l={ada:{LINE_REGEX:/^--.*/},apl:{LINE_REGEX:/^⍝.*/},applescript:{BLOCK_OPEN_REGEX:/^\(\*/,BLOCK_CLOSE_REGEX:/^\*\)/},csharp:{LINE_REGEX:/^\/\/.*/},haskell:{BLOCK_OPEN_REGEX:/^\{-/,BLOCK_CLOSE_REGEX:/^-\}/,LINE_REGEX:/^--.*/},javascript:{BLOCK_OPEN_REGEX:/^\/\*\*?(!?)/,BLOCK_CLOSE_REGEX:/^\*\/(\n?)/,LINE_REGEX:/^\/\/(!?).*/},lua:{BLOCK_OPEN_REGEX:/^--\[\[/,BLOCK_CLOSE_REGEX:/^\]\]/,LINE_REGEX:/^--.*/},matlab:{BLOCK_OPEN_REGEX:/^%{/,BLOCK_CLOSE_REGEX:/^%}/,LINE_REGEX:/^%.*/},perl:{LINE_REGEX:/^#.*/},php:{BLOCK_OPEN_REGEX:/^\/\*\*?(!?)/,BLOCK_CLOSE_REGEX:/^\*\/(\n?)/,LINE_REGEX:/^(#|\/\/).*?(?=\?>|\n)/},ruby:{BLOCK_OPEN_REGEX:/^=begin/,BLOCK_CLOSE_REGEX:/^=end/,LINE_REGEX:/^#.*/},shebang:{LINE_REGEX:/^#!.*/},python:{BLOCK_OPEN_REGEX:/^"""/,BLOCK_CLOSE_REGEX:/^"""/,LINE_REGEX:/^#.*/},c:{BLOCK_OPEN_REGEX:/^\/\*\*?(!?)/,BLOCK_CLOSE_REGEX:/^\*\/(\n?)/,LINE_REGEX:/^\/\/(!?).*/},css:{BLOCK_OPEN_REGEX:/^\/\*\*?(!?)/,BLOCK_CLOSE_REGEX:/^\*\/(\n?)/,LINE_REGEX:/^\/\/(!?).*/},java:{BLOCK_OPEN_REGEX:/^\/\*\*?(!?)/,BLOCK_CLOSE_REGEX:/^\*\/(\n?)/,LINE_REGEX:/^\/\/(!?).*/},js:{BLOCK_OPEN_REGEX:/^\/\*\*?(!?)/,BLOCK_CLOSE_REGEX:/^\*\/(\n?)/,LINE_REGEX:/^\/\/(!?).*/},less:{BLOCK_OPEN_REGEX:/^\/\*\*?(!?)/,BLOCK_CLOSE_REGEX:/^\*\/(\n?)/,LINE_REGEX:/^\/\/(!?).*/},pascal:{BLOCK_OPEN_REGEX:/^\(\*/,BLOCK_CLOSE_REGEX:/^\*\)/},ocaml:{BLOCK_OPEN_REGEX:/^\(\*/,BLOCK_CLOSE_REGEX:/^\*\)/},sass:{BLOCK_OPEN_REGEX:/^\/\*\*?(!?)/,BLOCK_CLOSE_REGEX:/^\*\/(\n?)/,LINE_REGEX:/^\/\/(!?).*/},sql:{LINE_REGEX:/^--.*/},swift:{BLOCK_OPEN_REGEX:/^\/\*\*?(!?)/,BLOCK_CLOSE_REGEX:/^\*\/(\n?)/,LINE_REGEX:/^\/\/(!?).*/},ts:{BLOCK_OPEN_REGEX:/^\/\*\*?(!?)/,BLOCK_CLOSE_REGEX:/^\*\/(\n?)/,LINE_REGEX:/^\/\/(!?).*/},typscript:{BLOCK_OPEN_REGEX:/^\/\*\*?(!?)/,BLOCK_CLOSE_REGEX:/^\*\/(\n?)/,LINE_REGEX:/^\/\/(!?).*/}},f=/^\\./,d=/^(['"`])((?:\\\1|[^\1])*?)(\1)/,c=/^\r*\n/,u=(e,n={})=>{var t;if("string"!=typeof e)throw new TypeError("Expected input to be a string");const r=new a({type:"root",nodes:[],value:""}),i=[r],s=(n.language||"javascript").toLowerCase(),u=l[s];if(void 0===u)throw new Error(`Language "${s}" is not supported by strip-comments`);const{LINE_REGEX:p,BLOCK_OPEN_REGEX:_,BLOCK_CLOSE_REGEX:m}=u;let h,y,g=r,v=e,E=!1;[_,m].filter((e=>void 0!==e)).every((e=>'^"""'===e.source))&&(E=!0);const b=(e=v[0]||"")=>(v=v.slice(e.length),e),w=(e,n="text")=>{const t=e.exec(v);if(t)return b(t[0]),{type:n,value:t[0],match:t}},N=e=>{y&&"text"===y.type&&"text"===e.type?y.value=y.value?y.value+e.value:e.value:(g.push(e),"nodes"in e&&e.nodes&&(i.push(e),g=e),y=e)},O=()=>{if("root"===g.type)throw new SyntaxError("Unclosed block comment");i.pop(),g=i[i.length-1]};for(;""!==v;)(h=w(f,"text"))?N(new a(h)):"block"===g.type||y&&/\w$/.test(null!==(t=y.value)&&void 0!==t?t:"")||E&&v.startsWith('"""')||!(h=w(d,"text"))?(h=w(c,"newline"))?N(new o(h)):!_||!n.block||E&&"block"===g.type||!(h=w(_,"open"))?m&&"block"===g.type&&n.block&&(h=w(m,"close"))?(h.newline=h.match[1]||"",N(new o(h)),O()):p&&"block"!==g.type&&n.line&&(h=w(p,"line"))||(h=w(/^[a-zABD-Z0-9\t ]+/,"text"))?N(new o(h)):N(new o({type:"text",value:b(v[0])})):(N(new a({type:"block"})),N(new o(h))):N(new o(h));return r},p=(e,n)=>{const t=Object.assign(Object.assign({},n),{block:!0,line:!0});return i(u(e,t),t)};function _(e){return e.replace(/<!--[\s\S]*?(-->|$)/g,"")}function m(e){return e.replace(/\/\*[\s\S]+?\*\//g,"")}function h(e){try{return p(e)}catch(n){return e}}function y(e){return e.replace(/\s/g,"")}function g(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function v(e,n){var t;const r=p(n),i=`^\\s*?${g(e)}\\(\\s*?\\)`,o=null!==(t=new RegExp(i,"gm").exec(r))&&void 0!==t?t:[];return Boolean(o.length)}function E(...e){const n=e.map((e=>new RegExp(e).source)).join("");return new RegExp(n)}p.block=(e,n)=>{const t=Object.assign(Object.assign({},n),{block:!0});return i(u(e,t),t)},p.line=(e,n)=>{const t=Object.assign(Object.assign({},n),{line:!0});return i(u(e,t),t)},p.first=(e,n)=>{const t=Object.assign(Object.assign({},n),{block:!0,line:!0,first:!0});return i(u(e,t),t)},p.parse=u;const b={astHelpers:'import ast\n\n# A chainable class that allows us to call functions on the result of parsing a string\n\n\nclass Node:\n    def __init__(self, tree=None):\n        if isinstance(tree, str):\n            self.tree = ast.parse(tree)\n        elif isinstance(tree, ast.AST) or tree == None:\n            self.tree = tree\n        else:\n            raise TypeError("Node must be initialized with a string or AST")\n\n    def __getitem__(self, i):\n        if getattr(self.tree, "__getitem__", False):\n            return Node(self.tree[i])\n        elif getattr(self.tree, "body", False):\n            return Node(self.tree.body[i])\n        else:\n            raise IndexError("Empty Nodes cannot be indexed.")\n\n    def __len__(self):\n        if getattr(self.tree, "__len__", False):\n            return len(self.tree)\n        if self.tree is None:\n            return 0\n        if not hasattr(self.tree, "body"):\n            return 1\n        return len(self.tree.body)\n\n    def __eq__(self, other):\n        if not isinstance(other, Node):\n            return False\n        if self.tree == None:\n            return other.tree == None\n        if other.tree == None:\n            return False\n        return ast.dump(self.tree, include_attributes=True) == ast.dump(\n            other.tree, include_attributes=True\n        )\n\n    def __repr__(self):\n        if self.tree == None:\n            return "Node:\\nNone"\n        return "Node:\\n" + ast.dump(self.tree, indent=2)\n\n    def __str__(self):\n        if self.tree == None:\n            return "# no ast"\n        return ast.unparse(self.tree)\n\n    def _has_body(self):\n        return bool(getattr(self.tree, "body", False))\n\n    # "find" functions return a new node with the result of the find\n    # function. In this case, it returns a new node with the function\n    # definition (if it exists)\n\n    def find_function(self, func):\n        if not self._has_body():\n            return Node()\n        for node in self.tree.body:\n            if isinstance(node, ast.FunctionDef):\n                if node.name == func:\n                    return Node(node)\n        return Node()\n\n    def find_functions(self, func):\n        return [\n            node\n            for node in self._find_all((ast.FunctionDef, ast.AsyncFunctionDef))\n            if node.tree.name == func\n        ]\n\n    def find_async_function(self, func):\n        if not self._has_body():\n            return Node()\n        for node in self.tree.body:\n            if isinstance(node, ast.AsyncFunctionDef):\n                if node.name == func:\n                    return Node(node)\n        return Node()\n\n    def find_awaits(self):\n        return [\n            node\n            for node in self._find_all(ast.Expr)\n            if isinstance(node.tree.value, ast.Await)\n        ]\n\n    def has_args(self, arg_str):\n        if not isinstance(self.tree, (ast.FunctionDef, ast.AsyncFunctionDef)):\n            return False\n        dec_list = (f"@{Node(node)}" for node in self.tree.decorator_list)\n        dec_str = "\\n".join(dec_list) + "\\n" if dec_list else ""\n        if id := getattr(self.tree.returns, "id", False):\n            returns = f" -> {id}"\n        elif val := getattr(self.tree.returns, "value", False):\n            returns = f" -> \'{val}\'"\n        else:\n            returns = ""\n        async_kw = ""\n        if isinstance(self.tree, ast.AsyncFunctionDef):\n            async_kw = "async "\n        body_lines = str(self.find_body()).split("\\n")\n        new_body = "".join([f"\\n  {line}" for line in body_lines])\n        func_str = (\n            f"{dec_str}{async_kw}def {self.tree.name}({arg_str}){returns}:{new_body}"\n        )\n        return self.is_equivalent(func_str)\n\n    # returns_str is the annotation of the type returned by the function\n    def has_returns(self, returns_str):\n        if not isinstance(self.tree, (ast.FunctionDef, ast.AsyncFunctionDef)):\n            return False\n        if isinstance(self.tree.returns, ast.Name):\n            return returns_str == self.tree.returns.id\n        elif isinstance(self.tree.returns, ast.Constant):\n            return returns_str == self.tree.returns.value\n        return False\n\n    def find_body(self):\n        if not isinstance(self.tree, ast.AST):\n            return Node()\n        if not hasattr(self.tree, "body"):\n            return Node()\n        return Node(ast.Module(self.tree.body, []))\n\n    # find the return statement of a function\n    def find_return(self):\n        if return_list := self._find_all(ast.Return):\n            return return_list[0]\n        return Node()\n\n    def has_return(self, return_value):\n        return self.find_return().is_equivalent(f"return {return_value}")\n\n    def find_imports(self):\n        return self._find_all((ast.Import, ast.ImportFrom))\n\n    def find_comps(self):\n        return [\n            node\n            for node in self._find_all(ast.Expr)\n            if isinstance(\n                node.tree.value,\n                (ast.ListComp, ast.SetComp, ast.GeneratorExp, ast.DictComp),\n            )\n        ]\n\n    def _find_comp(\n        self, classes=(ast.ListComp, ast.SetComp, ast.GeneratorExp, ast.DictComp)\n    ):\n        if isinstance(self.tree, classes):\n            return Node(self.tree)\n        elif isinstance(self.tree, (ast.Assign, ast.AnnAssign, ast.Return)):\n            if isinstance(self.tree.value, classes):\n                return Node(self.tree.value)\n            return Node()\n\n    # find a list of iterables of a comprehension/generator expression\n    def find_comp_iters(self):\n        if not (node := self._find_comp()):\n            return []\n        return [Node(gen.iter) for gen in node.tree.generators]\n\n    # find a list of targets (iteration variables) of a comprehension/generator expression\n    def find_comp_targets(self):\n        if not (node := self._find_comp()):\n            return []\n        return [Node(gen.target) for gen in node.tree.generators]\n\n    # find the key of a dictionary comprehension\n    def find_comp_key(self):\n        if not (node := self._find_comp(ast.DictComp)):\n            return Node()\n        return Node(node.tree.key)\n\n    # find the expression evaluated for a comprehension/generator expression\n    # which is the value of the key in case of a dictionary comprehension\n    def find_comp_expr(self):\n        if not (node := self._find_comp()):\n            return Node()\n        if isinstance(node.tree, (ast.ListComp, ast.SetComp, ast.GeneratorExp)):\n            return Node(node.tree.elt)\n        elif isinstance(node.tree, ast.DictComp):\n            return Node(node.tree.value)\n\n    # find a list of `IfExpr`s at the end of the comprehension/generator expression\n    def find_comp_ifs(self):\n        if not (node := self._find_comp()):\n            return []\n        return [\n            Node(gen.ifs[i])\n            for gen in node.tree.generators\n            for i in range(len(gen.ifs))\n        ]\n\n    # "has" functions return a boolean indicating whether whatever is being\n    # searched for exists. In this case, it returns True if the variable exists.\n\n    def has_variable(self, name):\n        return self.find_variable(name) != Node()\n\n    def has_import(self, import_str):\n        return any(\n            import_node.is_equivalent(import_str) for import_node in self.find_imports()\n        )\n\n    # find a list of function calls of the \'name\' function\n    def find_calls(self, name):\n        call_list = []\n        for node in self._find_all(ast.Expr):\n            if func := getattr(node.tree.value, "func", False):\n                if isinstance(func, ast.Name) and func.id == name:\n                    call_list.append(Node(node.tree.value))\n                elif isinstance(func, ast.Attribute) and func.attr == name:\n                    call_list.append(Node(node.tree.value))\n        return call_list\n\n    def has_call(self, call):\n        return any(node.is_equivalent(call) for node in self._find_all(ast.Expr))\n\n    def find_call_args(self):\n        if not isinstance(self.tree, ast.Call):\n            return []\n        return [Node(arg) for arg in self.tree.args]\n\n    def has_stmt(self, node_str):\n        if not self._has_body():\n            return False\n        return any(Node(node).is_equivalent(node_str) for node in self.tree.body)\n\n    def find_variable(self, name):\n        if not self._has_body():\n            return Node()\n        for node in self.tree.body:\n            if isinstance(node, ast.Assign):\n                for target in node.targets:\n                    if isinstance(target, ast.Name):\n                        if target.id == name:\n                            return Node(node)\n                    if isinstance(target, ast.Attribute):\n                        names = name.split(".")\n                        if target.value.id == names[0] and target.attr == names[1]:\n                            return Node(node)\n            elif isinstance(node, ast.AnnAssign):\n                if isinstance(node.target, ast.Name):\n                    if node.target.id == name:\n                        return Node(node)\n        return Node()\n\n    # find variable incremented or decremented using += or -=\n    def find_aug_variable(self, name):\n        if not self._has_body():\n            return Node()\n        for node in self.tree.body:\n            if isinstance(node, ast.AugAssign):\n                if isinstance(node.target, ast.Name):\n                    if node.target.id == name:\n                        return Node(node)\n        return Node()\n\n    def get_variable(self, name):\n        var = self.find_variable(name)\n        if var != Node():\n            return var.tree.value.value\n        else:\n            return None\n\n    def has_function(self, name):\n        return self.find_function(name) != Node()\n\n    def has_class(self, name):\n        return self.find_class(name) != Node()\n\n    def has_decorators(self, *args):\n        # the order of args does matter\n        if not isinstance(self.tree, (ast.FunctionDef, ast.AsyncFunctionDef)):\n            return False\n        dec_list = (Node(node) for node in self.tree.decorator_list)\n        return all(any(dec.is_equivalent(arg) for dec in dec_list) for arg in args)\n\n    # Checks if the current scope contains a "pass" statement\n\n    def has_pass(self):\n        if isinstance(self.tree, (ast.If, ast.While, ast.For)):\n            return False\n        if getattr(self.tree, "body", False):\n            return any(isinstance(node, ast.Pass) for node in self.tree.body)\n        return False\n\n    # Checks the variable, name, is in the current scope and is an integer\n\n    def is_integer(self):\n        if not isinstance(self.tree, ast.Assign):\n            return False\n        return type(self.tree.value.value) == type(1)\n\n    def value_is_call(self, name):\n        if not isinstance(self.tree, ast.Assign):\n            return False\n        call = self.tree.value\n        if isinstance(call, ast.Call):\n            return call.func.id == name\n        return False\n\n    # Loosely compares the code in target_str with the code represented by the\n    # Node\'s AST. If the two codes are semantically equivalent (i.e. the same if\n    # you ignore formatting and context) then this returns True, otherwise\n    # False.\n    #\n    # Ignoring context means that the following comparison is True despite the\n    # fact that the AST of `cond_node` is `Constant(value=True)` and `True`\n    # compiles to `Module(body=[Expr(value=Constant(value=True))],\n    # type_ignores=[])`:\n    #\n    # node = Node("if True:\\n  pass") cond_node =\n    # node.find_ifs()[0].find_conditions()[0] cond_node.is_equivalent("True")\n\n    def is_equivalent(self, target_str):\n        # Setting the tree to None is used to represent missing elements. Such\n        # as the condition of a final else clause. It is, therefore, not\n        # equivalent to any string.\n        if self.tree == None:\n            return False\n        code_str = ast.unparse(self.tree)\n\n        # Why parse and unparse again? Because of an edge case when comparing\n        # the `target_str` "\'True\'" with the test in "if \'True\':". These should\n        # be equivalent, but the condition unparses to "\'True\'", while the\n        # `target_str` becomes \'"""True"""\' when parsed and unparsed again.\n\n        # By parsing and unparsing `code_str` we get \'"""True"""\' and the\n        # comparison returns True as expected.\n        return ast.unparse(ast.parse(code_str)) == ast.unparse(ast.parse(target_str))\n\n    def is_empty(self):\n        return self.tree == None\n\n    # Finds the class definition with the given name\n\n    def find_class(self, class_name):\n        if not self._has_body():\n            return Node()\n        for node in self.tree.body:\n            if isinstance(node, ast.ClassDef):\n                if node.name == class_name:\n                    return Node(node)\n        return Node()\n\n    def inherits_from(self, *args):\n        if not isinstance(self.tree, ast.ClassDef):\n            return False\n        if not self.tree.bases:\n            return False\n        id_list = [node.id for node in self.tree.bases]\n        return all(arg in id_list for arg in args)\n\n    # Find an array of conditions in an if statement\n\n    def find_ifs(self):\n        return self._find_all(ast.If)\n\n    def _find_all(self, ast_type):\n        return [Node(node) for node in self.tree.body if isinstance(node, ast_type)]\n\n    def find_whiles(self):\n        return self._find_all(ast.While)\n\n    def find_for_loops(self):\n        return self._find_all(ast.For)\n\n    def find_for_vars(self):\n        if not isinstance(self.tree, ast.For):\n            return Node()\n        return Node(self.tree.target)\n\n    def find_for_iter(self):\n        if not isinstance(self.tree, ast.For):\n            return Node()\n        return Node(self.tree.iter)\n\n    def find_if(self, if_str):\n        if_list = self._find_all(ast.If)\n        for if_statement in if_list:\n            if if_statement.find_conditions()[0].is_equivalent(if_str):\n                return if_statement\n        return Node()\n\n    def find_while(self, while_str):\n        while_list = self._find_all(ast.While)\n        for while_loop in while_list:\n            if while_loop.find_conditions()[0].is_equivalent(while_str):\n                return while_loop\n        return Node()\n\n    def find_for(self, target_str, iter_str):\n        for_list = self._find_all(ast.For)\n        for for_loop in for_list:\n            if for_loop.find_for_vars().is_equivalent(\n                target_str\n            ) and for_loop.find_for_iter().is_equivalent(iter_str):\n                return for_loop\n        return Node()\n\n    # Find an array of bodies in if/elif statement and while or for loops\n\n    def find_bodies(self):\n        def _find_bodies(tree):\n            if not isinstance(tree, (ast.If, ast.While, ast.For)):\n                return []\n            if tree.orelse == []:\n                return [tree.body]\n            if isinstance(tree.orelse[0], (ast.If, ast.While, ast.For)):\n                return [tree.body] + _find_bodies(tree.orelse[0])\n\n            return [tree.body] + [tree.orelse]\n\n        return [Node(ast.Module(body, [])) for body in _find_bodies(self.tree)]\n\n    # Find an array of conditions in if/elif statement or while loop\n\n    def find_conditions(self):\n        def _find_conditions(tree):\n            if not isinstance(tree, (ast.If, ast.While)):\n                return []\n            test = tree.test\n            if tree.orelse == []:\n                return [test]\n            if isinstance(tree.orelse[0], (ast.If, ast.While)):\n                return [test] + _find_conditions(tree.orelse[0])\n\n            return [test, None]\n\n        return [Node(test) for test in _find_conditions(self.tree)]\n\n    # Returs a Boolean indicating if the statements passed as arguments\n    # are found in the same order in the tree (statements can be non-consecutive)\n    def is_ordered(self, *args):\n        if not self._has_body():\n            return False\n        if len(args) < 2:\n            return False\n        arg_dict = {key: None for key in range(len(args))}\n        for i, node in enumerate(self.tree.body):\n            for j, arg in enumerate(args):\n                if Node(node).is_equivalent(arg):\n                    arg_dict[j] = i\n                    break\n        if None in arg_dict.values():\n            return False\n        return all(arg_dict[n] < arg_dict[n + 1] for n in range(len(arg_dict) - 1))\n\n\n# Exception formatting functions. Currently bundled with the Node class, until\n# we improve the testing, building and CI so that they can easily handle\n# multiple files.\n\n\ndef drop_until(*, traces, filename):\n    from itertools import dropwhile\n\n    return list(\n        dropwhile(lambda line: not line.startswith(f\'  File "{filename}"\'), traces)\n    )\n\n\ndef build_message(*, traces, exception_list):\n    return "".join(["Traceback (most recent call last):\\n"] + traces + exception_list)\n\n\ndef _replace_startswith(string, old, new):\n    if string.startswith(old):\n        return new + string[len(old) :]\n    return string\n\n\ndef format_exception(*, exception, traceback, filename, new_filename=None):\n    if new_filename is None:\n        new_filename = filename\n    from traceback import format_exception_only, format_tb\n\n    # The trace up to "filename" are the frames that are not part of the user\'s\n    # code so we drop them.\n    traces = drop_until(traces=format_tb(traceback), filename=filename)\n    renamed_traces = [\n        _replace_startswith(trace, f\'  File "{filename}"\', f\'  File "{new_filename}"\')\n        for trace in traces\n    ]\n    renamed_exception = [\n        _replace_startswith(e, f\'  File "{filename}"\', f\'  File "{new_filename}"\')\n        for e in format_exception_only(exception)\n    ]\n    return build_message(traces=renamed_traces, exception_list=renamed_exception)\n',getDef(e,n){const t=new RegExp(`\\n?(?<function_indentation> *?)def +${n} *\\((?<function_parameters>[^\\)]*)\\)\\s*:\\s*?\\n?(?<function_body>.*?)(?=\\n\\k<function_indentation>[\\w#]|$)`,"s").exec(e);if(t){const{function_parameters:e,function_body:n,function_indentation:r}=t.groups,i=r.replace(/\n+/,"");return{def:t[0].replace(/^\n/,""),function_parameters:e,function_body:n,function_indentation:i.length}}return null},removeComments:e=>e.replace(/\/\/.*|\/\*[\s\S]*?\*\/|(#.*$)/gm,""),getBlock(e,n){const t=n instanceof RegExp?n.source:n.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),r=new RegExp(`\\n?(?<block_indentation> *?)(?<block_condition>${t})\\s*:\\s*?\\n(?<block_body>(\\k<block_indentation> +[^\\n]*| *\\n)+)(\n|$)`,"sm").exec(e);if(r){const{block_body:e,block_indentation:n,block_condition:t}=r.groups;return{block_body:e,block_condition:t,block_indentation:n.replace(/\n+/g,"").length}}return null}};class w{constructor(e){this.doc=e}_getStyleRules(){const e=this.getStyleSheet();return this.styleSheetToCssRulesArray(e).filter((e=>e.type===CSSRule.STYLE_RULE))}getStyleDeclarations(e){var n;return null===(n=this._getStyleRules())||void 0===n?void 0:n.filter((n=>(null==n?void 0:n.selectorText)===e)).map((e=>e.style))}getStyle(e){var n;const t=null===(n=this._getStyleRules().find((n=>(null==n?void 0:n.selectorText)===e)))||void 0===n?void 0:n.style;return t?(t.getPropVal=(e,n=!1)=>n?t.getPropertyValue(e).replace(/\s+/g,""):t.getPropertyValue(e),t):null}getStyleAny(e){for(const n of e){const e=this.getStyle(n);if(e)return e}return null}getStyleRule(e){var n;const t=null===(n=this._getStyleRules())||void 0===n?void 0:n.find((n=>(null==n?void 0:n.selectorText)===e));return t?Object.assign(Object.assign({},t),{isDeclaredAfter:e=>(e=>n=>{var t,r,i,o;const s=(null===(r=Array.from((null===(t=e.parentStyleSheet)||void 0===t?void 0:t.cssRules)||[]))||void 0===r?void 0:r.filter((e=>e.type===CSSRule.STYLE_RULE))).find((e=>(null==e?void 0:e.selectorText)===n));return!!s&&Array.from((null===(i=e.parentStyleSheet)||void 0===i?void 0:i.cssRules)||[]).indexOf(e)>Array.from((null===(o=null==s?void 0:s.parentStyleSheet)||void 0===o?void 0:o.cssRules)||[]).indexOf(s)})(t)(e)}):null}getCSSRules(e){const n=this.getStyleSheet(),t=this.styleSheetToCssRulesArray(n);switch(e){case"media":return t.filter((e=>e.type===CSSRule.MEDIA_RULE));case"fontface":return t.filter((e=>e.type===CSSRule.FONT_FACE_RULE));case"import":return t.filter((e=>e.type===CSSRule.IMPORT_RULE));case"keyframes":return t.filter((e=>e.type===CSSRule.KEYFRAMES_RULE));default:return t}}isPropertyUsed(e){return this._getStyleRules().some((n=>{var t;return null===(t=n.style)||void 0===t?void 0:t.getPropertyValue(e)}))}getRuleListsWithinMedia(e){const n=this.getCSSRules("media"),t=null==n?void 0:n.find((n=>{var t;return(null===(t=null==n?void 0:n.media)||void 0===t?void 0:t.mediaText)===e})),r=null==t?void 0:t.cssRules;return Array.from(r||[])}getStyleSheet(){var e,n,t,r,i;const o=null===(e=this.doc)||void 0===e?void 0:e.querySelector("link[href*='styles']"),s=null===(n=this.doc)||void 0===n?void 0:n.querySelector("style.fcc-injected-styles"),a=null===(t=this.doc)||void 0===t?void 0:t.querySelector("style:not([class]):not([media])");return(null===(i=null===(r=null==o?void 0:o.sheet)||void 0===r?void 0:r.cssRules)||void 0===i?void 0:i.length)?o.sheet:s?s.sheet:a?a.sheet:null}styleSheetToCssRulesArray(e){return Array.from((null==e?void 0:e.cssRules)||[])}selectorsFromSelector(e){const n=this.doc.querySelectorAll(e),t=Array.from(n).map((e=>{const n=[],t=[],r=[];for(;e.parentNode;){let i=e.tagName.toLowerCase();Array.from(e.parentNode.children).filter((n=>n.tagName===e.tagName)).length>1&&(i+=`:nth-child(${Array.from(e.parentNode.childNodes).indexOf(e)+1})`),n.unshift(i),t.unshift(i),r.push([n.join(" > "),t.join(" ")]),e=e.parentNode}return r.flat()})).flat();return[...new Set(t)]}}function N(e){const n=e.match(/(?:function\s*[^(]*\(([^)]*)\))/)||e.match(/(?:\b(?:const|let|var)\s*\w+\s*=\s*(?:function)?\s*\(([^)]*)\))/)||e.match(/=\s+([^)]*)=>/);return n?(n[1]||n[2]||n[3]||n[4]).split(",").map((e=>{const n=e.trim().split("="),t=n.length>1?n[1].replace(/['"]/g,"").trim():void 0;return{name:n[0].trim(),defaultValue:t}})):[]}var O=r.Hg;const L=self;let R=null,S=!0;async function x(){if(R)return R;R=await(0,e.loadPyodide)({indexURL:"https://cdn.jsdelivr.net/pyodide/v".concat(n,"/full/")}),Object.freeze(self),R.FS.writeFile("/home/pyodide/ast_helpers.py",O.astHelpers,{encoding:"utf8"}),S=!0,postMessage({type:"stopped"})}x(),L.onmessage=e=>{const{data:n}=e;"listen"===n.type?S=!1:"cancel"===n.type?function(e){let{value:n}=e;postMessage({type:"is-alive",text:n})}(n):function(e){try{if(S)return;const n=(e.code.contents||"").slice();postMessage({type:"reset"});const{runPython:t,getResetId:r,globals:i,printException:o}=function(){if(!R)throw new Error("pyodide not loaded");const e=R.globals.get("str");R.registerJsModule("jscustom",{print:function(){for(var n=arguments.length,t=new Array(n),r=0;r<n;r++)t[r]=arguments[r];const i=t.map((n=>e(n))).join(" ");postMessage({type:"print",text:i})},input:function(e){postMessage({type:"input",text:e});const n=new XMLHttpRequest;return n.open("POST","/python/intercept-input/",!1),n.send(null),JSON.parse(n.responseText)}});const n=R.globals.get("dict")();n.set("__name__","__main__");const t=e=>R.runPython(e,{globals:n});t("\n  import jscustom\n  from jscustom import print\n  from jscustom import input\n  def __wrap(func):\n    def fn(*args):\n      data = func(*args)\n      if data.type == 'cancel':\n        raise KeyboardInterrupt(data.value)\n      return data.value\n    return fn\n  input = __wrap(input)\n  "),t('\n  import sys\n  def __get_reset_id():\n    if sys.last_value and sys.last_value.args:\n      return "".join(str(sys.last_value.args[0]))\n    else:\n      return ""\n  '),t('\ndef print_exception():\n    from ast_helpers import format_exception\n    formatted = format_exception(exception=sys.last_value, traceback=sys.last_traceback, filename="<exec>", new_filename="main.py")\n    print(formatted)\n');const r=n.get("print_exception");return{runPython:t,getResetId:n.get("__get_reset_id"),globals:n,printException:r}}();try{t(n)}catch(e){const n=e;o(),console.error(n);const t=r();"KeyboardInterrupt"===n.type&&t&&(S=!0,postMessage({type:"stopped",text:r()}))}finally{r.destroy(),o.destroy(),i.destroy()}}catch(e){console.error(e),R&&(R=null),x()}}(n)}})()})();
//# sourceMappingURL=python-worker-05215f65484c7ab0a32e.js.map