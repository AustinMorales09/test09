/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js":
/*!***********************************************************************************!*\
  !*** ../../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js ***!
  \***********************************************************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../../../node_modules/.pnpm/pyodide@0.23.3/node_modules/pyodide/pyodide.js":
/*!**********************************************************************************!*\
  !*** ../../../node_modules/.pnpm/pyodide@0.23.3/node_modules/pyodide/pyodide.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var __dirname = "/";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
!function(global,factory){ true?factory(exports):0}(this,(function(exports){"use strict";"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof __webpack_require__.g?__webpack_require__.g:"undefined"!=typeof self&&self;var errorStackParser={exports:{}},stackframe={exports:{}};!function(module,exports){module.exports=function(){function _isNumber(n){return!isNaN(parseFloat(n))&&isFinite(n)}function _capitalize(str){return str.charAt(0).toUpperCase()+str.substring(1)}function _getter(p){return function(){return this[p]}}var booleanProps=["isConstructor","isEval","isNative","isToplevel"],numericProps=["columnNumber","lineNumber"],stringProps=["fileName","functionName","source"],arrayProps=["args"],objectProps=["evalOrigin"],props=booleanProps.concat(numericProps,stringProps,arrayProps,objectProps);function StackFrame(obj){if(obj)for(var i=0;i<props.length;i++)void 0!==obj[props[i]]&&this["set"+_capitalize(props[i])](obj[props[i]])}StackFrame.prototype={getArgs:function(){return this.args},setArgs:function(v){if("[object Array]"!==Object.prototype.toString.call(v))throw new TypeError("Args must be an Array");this.args=v},getEvalOrigin:function(){return this.evalOrigin},setEvalOrigin:function(v){if(v instanceof StackFrame)this.evalOrigin=v;else{if(!(v instanceof Object))throw new TypeError("Eval Origin must be an Object or StackFrame");this.evalOrigin=new StackFrame(v)}},toString:function(){var fileName=this.getFileName()||"",lineNumber=this.getLineNumber()||"",columnNumber=this.getColumnNumber()||"",functionName=this.getFunctionName()||"";return this.getIsEval()?fileName?"[eval] ("+fileName+":"+lineNumber+":"+columnNumber+")":"[eval]:"+lineNumber+":"+columnNumber:functionName?functionName+" ("+fileName+":"+lineNumber+":"+columnNumber+")":fileName+":"+lineNumber+":"+columnNumber}},StackFrame.fromString=function(str){var argsStartIndex=str.indexOf("("),argsEndIndex=str.lastIndexOf(")"),functionName=str.substring(0,argsStartIndex),args=str.substring(argsStartIndex+1,argsEndIndex).split(","),locationString=str.substring(argsEndIndex+1);if(0===locationString.indexOf("@"))var parts=/@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString,""),fileName=parts[1],lineNumber=parts[2],columnNumber=parts[3];return new StackFrame({functionName:functionName,args:args||void 0,fileName:fileName,lineNumber:lineNumber||void 0,columnNumber:columnNumber||void 0})};for(var i=0;i<booleanProps.length;i++)StackFrame.prototype["get"+_capitalize(booleanProps[i])]=_getter(booleanProps[i]),StackFrame.prototype["set"+_capitalize(booleanProps[i])]=function(p){return function(v){this[p]=Boolean(v)}}(booleanProps[i]);for(var j=0;j<numericProps.length;j++)StackFrame.prototype["get"+_capitalize(numericProps[j])]=_getter(numericProps[j]),StackFrame.prototype["set"+_capitalize(numericProps[j])]=function(p){return function(v){if(!_isNumber(v))throw new TypeError(p+" must be a Number");this[p]=Number(v)}}(numericProps[j]);for(var k=0;k<stringProps.length;k++)StackFrame.prototype["get"+_capitalize(stringProps[k])]=_getter(stringProps[k]),StackFrame.prototype["set"+_capitalize(stringProps[k])]=function(p){return function(v){this[p]=String(v)}}(stringProps[k]);return StackFrame}()}(stackframe),function(module,exports){var StackFrame,FIREFOX_SAFARI_STACK_REGEXP,CHROME_IE_STACK_REGEXP,SAFARI_NATIVE_CODE_REGEXP;module.exports=(StackFrame=stackframe.exports,FIREFOX_SAFARI_STACK_REGEXP=/(^|@)\S+:\d+/,CHROME_IE_STACK_REGEXP=/^\s*at .*(\S+:\d+|\(native\))/m,SAFARI_NATIVE_CODE_REGEXP=/^(eval@)?(\[native code])?$/,{parse:function(error){if(void 0!==error.stacktrace||void 0!==error["opera#sourceloc"])return this.parseOpera(error);if(error.stack&&error.stack.match(CHROME_IE_STACK_REGEXP))return this.parseV8OrIE(error);if(error.stack)return this.parseFFOrSafari(error);throw new Error("Cannot parse given Error object")},extractLocation:function(urlLike){if(-1===urlLike.indexOf(":"))return[urlLike];var parts=/(.+?)(?::(\d+))?(?::(\d+))?$/.exec(urlLike.replace(/[()]/g,""));return[parts[1],parts[2]||void 0,parts[3]||void 0]},parseV8OrIE:function(error){return error.stack.split("\n").filter((function(line){return!!line.match(CHROME_IE_STACK_REGEXP)}),this).map((function(line){line.indexOf("(eval ")>-1&&(line=line.replace(/eval code/g,"eval").replace(/(\(eval at [^()]*)|(,.*$)/g,""));var sanitizedLine=line.replace(/^\s+/,"").replace(/\(eval code/g,"(").replace(/^.*?\s+/,""),location=sanitizedLine.match(/ (\(.+\)$)/);sanitizedLine=location?sanitizedLine.replace(location[0],""):sanitizedLine;var locationParts=this.extractLocation(location?location[1]:sanitizedLine),functionName=location&&sanitizedLine||void 0,fileName=["eval","<anonymous>"].indexOf(locationParts[0])>-1?void 0:locationParts[0];return new StackFrame({functionName:functionName,fileName:fileName,lineNumber:locationParts[1],columnNumber:locationParts[2],source:line})}),this)},parseFFOrSafari:function(error){return error.stack.split("\n").filter((function(line){return!line.match(SAFARI_NATIVE_CODE_REGEXP)}),this).map((function(line){if(line.indexOf(" > eval")>-1&&(line=line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g,":$1")),-1===line.indexOf("@")&&-1===line.indexOf(":"))return new StackFrame({functionName:line});var functionNameRegex=/((.*".+"[^@]*)?[^@]*)(?:@)/,matches=line.match(functionNameRegex),functionName=matches&&matches[1]?matches[1]:void 0,locationParts=this.extractLocation(line.replace(functionNameRegex,""));return new StackFrame({functionName:functionName,fileName:locationParts[0],lineNumber:locationParts[1],columnNumber:locationParts[2],source:line})}),this)},parseOpera:function(e){return!e.stacktrace||e.message.indexOf("\n")>-1&&e.message.split("\n").length>e.stacktrace.split("\n").length?this.parseOpera9(e):e.stack?this.parseOpera11(e):this.parseOpera10(e)},parseOpera9:function(e){for(var lineRE=/Line (\d+).*script (?:in )?(\S+)/i,lines=e.message.split("\n"),result=[],i=2,len=lines.length;i<len;i+=2){var match=lineRE.exec(lines[i]);match&&result.push(new StackFrame({fileName:match[2],lineNumber:match[1],source:lines[i]}))}return result},parseOpera10:function(e){for(var lineRE=/Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i,lines=e.stacktrace.split("\n"),result=[],i=0,len=lines.length;i<len;i+=2){var match=lineRE.exec(lines[i]);match&&result.push(new StackFrame({functionName:match[3]||void 0,fileName:match[2],lineNumber:match[1],source:lines[i]}))}return result},parseOpera11:function(error){return error.stack.split("\n").filter((function(line){return!!line.match(FIREFOX_SAFARI_STACK_REGEXP)&&!line.match(/^Error created at/)}),this).map((function(line){var argsRaw,tokens=line.split("@"),locationParts=this.extractLocation(tokens.pop()),functionCall=tokens.shift()||"",functionName=functionCall.replace(/<anonymous function(: (\w+))?>/,"$2").replace(/\([^)]*\)/g,"")||void 0;functionCall.match(/\(([^)]*)\)/)&&(argsRaw=functionCall.replace(/^[^(]+\(([^)]*)\)$/,"$1"));var args=void 0===argsRaw||"[arguments not available]"===argsRaw?void 0:argsRaw.split(",");return new StackFrame({functionName:functionName,args:args,fileName:locationParts[0],lineNumber:locationParts[1],columnNumber:locationParts[2],source:line})}),this)}})}(errorStackParser);var ErrorStackParser=errorStackParser.exports;const IN_NODE="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node&&void 0===process.browser;let nodeUrlMod,nodeFetch,nodePath,nodeVmMod,nodeFsPromisesMod,resolvePath,pathSep,loadBinaryFile,loadScript;if(resolvePath=IN_NODE?function(path,base){return nodePath.resolve(base||".",path)}:function(path,base){return void 0===base&&(base=location),new URL(path,base).toString()},IN_NODE||(pathSep="/"),loadBinaryFile=IN_NODE?async function(path,_file_sub_resource_hash){if(path.startsWith("file://")&&(path=path.slice("file://".length)),path.includes("://")){let response=await nodeFetch(path);if(!response.ok)throw new Error(`Failed to load '${path}': request failed.`);return new Uint8Array(await response.arrayBuffer())}{const data=await nodeFsPromisesMod.readFile(path);return new Uint8Array(data.buffer,data.byteOffset,data.byteLength)}}:async function(path,subResourceHash){const url=new URL(path,location);let options=subResourceHash?{integrity:subResourceHash}:{},response=await fetch(url,options);if(!response.ok)throw new Error(`Failed to load '${url}': request failed.`);return new Uint8Array(await response.arrayBuffer())},globalThis.document)loadScript=async url=>await import(/* webpackIgnore: true */url);else if(globalThis.importScripts)loadScript=async url=>{try{globalThis.importScripts(url)}catch(e){if(!(e instanceof TypeError))throw e;await import(/* webpackIgnore: true */url)}};else{if(!IN_NODE)throw new Error("Cannot determine runtime environment");loadScript=async function(url){url.startsWith("file://")&&(url=url.slice("file://".length));url.includes("://")?nodeVmMod.runInThisContext(await(await nodeFetch(url)).text()):await import(/* webpackIgnore: true */nodeUrlMod.pathToFileURL(url).href)}}function __values(o){var s="function"==typeof Symbol&&Symbol.iterator,m=s&&o[s],i=0;if(m)return m.call(o);if(o&&"number"==typeof o.length)return{next:function(){return o&&i>=o.length&&(o=void 0),{value:o&&o[i++],done:!o}}};throw new TypeError(s?"Object is not iterable.":"Symbol.iterator is not defined.")}function __asyncValues(o){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var i,m=o[Symbol.asyncIterator];return m?m.call(o):(o=__values(o),i={},verb("next"),verb("throw"),verb("return"),i[Symbol.asyncIterator]=function(){return this},i);function verb(n){i[n]=o[n]&&function(v){return new Promise((function(resolve,reject){(function(resolve,reject,d,v){Promise.resolve(v).then((function(v){resolve({value:v,done:d})}),reject)})(resolve,reject,(v=o[n](v)).done,v.value)}))}}}const getFsHandles=async dirHandle=>{const handles=[];await async function collect(curDirHandle){var e_1,_a;try{for(var _c,_b=__asyncValues(curDirHandle.values());!(_c=await _b.next()).done;){const entry=_c.value;handles.push(entry),"directory"===entry.kind&&await collect(entry)}}catch(e_1_1){e_1={error:e_1_1}}finally{try{_c&&!_c.done&&(_a=_b.return)&&await _a.call(_b)}finally{if(e_1)throw e_1.error}}}(dirHandle);const result=new Map;result.set(".",dirHandle);for(const handle of handles){const relativePath=(await dirHandle.resolve(handle)).join("/");result.set(relativePath,handle)}return result};function initializeFileSystem(Module,config){let stdLibURL;stdLibURL=null!=config.stdLibURL?config.stdLibURL:config.indexURL+"python_stdlib.zip",function(Module,stdlibURL){const stdlibPromise=loadBinaryFile(stdlibURL);Module.preRun.push((()=>{const pymajor=Module._py_version_major(),pyminor=Module._py_version_minor();Module.FS.mkdirTree("/lib"),Module.FS.mkdirTree(`/lib/python${pymajor}.${pyminor}/site-packages`),Module.addRunDependency("install-stdlib"),stdlibPromise.then((stdlib=>{Module.FS.writeFile(`/lib/python${pymajor}${pyminor}.zip`,stdlib)})).catch((e=>{console.error("Error occurred while installing the standard library:"),console.error(e)})).finally((()=>{Module.removeRunDependency("install-stdlib")}))}))}(Module,stdLibURL),function(Module,path){Module.preRun.push((function(){try{Module.FS.mkdirTree(path)}catch(e){console.error(`Error occurred while making a home directory '${path}':`),console.error(e),console.error("Using '/' for a home directory instead"),path="/"}Module.ENV.HOME=path,Module.FS.chdir(path)}))}(Module,config.homedir),function(Module,mounts){Module.preRun.push((()=>{for(const mount of mounts)Module.FS.mkdirTree(mount),Module.FS.mount(Module.FS.filesystems.NODEFS,{root:mount},mount)}))}(Module,config._node_mounts),Module.preRun.push((()=>function(module){const FS=module.FS,MEMFS=module.FS.filesystems.MEMFS,PATH=module.PATH,nativeFSAsync={DIR_MODE:16895,FILE_MODE:33279,mount:function(mount){if(!mount.opts.fileSystemHandle)throw new Error("opts.fileSystemHandle is required");return MEMFS.mount.apply(null,arguments)},syncfs:async(mount,populate,callback)=>{try{const local=nativeFSAsync.getLocalSet(mount),remote=await nativeFSAsync.getRemoteSet(mount),src=populate?remote:local,dst=populate?local:remote;await nativeFSAsync.reconcile(mount,src,dst),callback(null)}catch(e){callback(e)}},getLocalSet:mount=>{let entries=Object.create(null);function isRealDir(p){return"."!==p&&".."!==p}function toAbsolute(root){return p=>PATH.join2(root,p)}let check=FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));for(;check.length;){let path=check.pop(),stat=FS.stat(path);FS.isDir(stat.mode)&&check.push.apply(check,FS.readdir(path).filter(isRealDir).map(toAbsolute(path))),entries[path]={timestamp:stat.mtime,mode:stat.mode}}return{type:"local",entries:entries}},getRemoteSet:async mount=>{const entries=Object.create(null),handles=await getFsHandles(mount.opts.fileSystemHandle);for(const[path,handle]of handles)"."!==path&&(entries[PATH.join2(mount.mountpoint,path)]={timestamp:"file"===handle.kind?(await handle.getFile()).lastModifiedDate:new Date,mode:"file"===handle.kind?nativeFSAsync.FILE_MODE:nativeFSAsync.DIR_MODE});return{type:"remote",entries:entries,handles:handles}},loadLocalEntry:path=>{const node=FS.lookupPath(path).node,stat=FS.stat(path);if(FS.isDir(stat.mode))return{timestamp:stat.mtime,mode:stat.mode};if(FS.isFile(stat.mode))return node.contents=MEMFS.getFileDataAsTypedArray(node),{timestamp:stat.mtime,mode:stat.mode,contents:node.contents};throw new Error("node type not supported")},storeLocalEntry:(path,entry)=>{if(FS.isDir(entry.mode))FS.mkdirTree(path,entry.mode);else{if(!FS.isFile(entry.mode))throw new Error("node type not supported");FS.writeFile(path,entry.contents,{canOwn:!0})}FS.chmod(path,entry.mode),FS.utime(path,entry.timestamp,entry.timestamp)},removeLocalEntry:path=>{var stat=FS.stat(path);FS.isDir(stat.mode)?FS.rmdir(path):FS.isFile(stat.mode)&&FS.unlink(path)},loadRemoteEntry:async handle=>{if("file"===handle.kind){const file=await handle.getFile();return{contents:new Uint8Array(await file.arrayBuffer()),mode:nativeFSAsync.FILE_MODE,timestamp:file.lastModifiedDate}}if("directory"===handle.kind)return{mode:nativeFSAsync.DIR_MODE,timestamp:new Date};throw new Error("unknown kind: "+handle.kind)},storeRemoteEntry:async(handles,path,entry)=>{const parentDirHandle=handles.get(PATH.dirname(path)),handle=FS.isFile(entry.mode)?await parentDirHandle.getFileHandle(PATH.basename(path),{create:!0}):await parentDirHandle.getDirectoryHandle(PATH.basename(path),{create:!0});if("file"===handle.kind){const writable=await handle.createWritable();await writable.write(entry.contents),await writable.close()}handles.set(path,handle)},removeRemoteEntry:async(handles,path)=>{const parentDirHandle=handles.get(PATH.dirname(path));await parentDirHandle.removeEntry(PATH.basename(path)),handles.delete(path)},reconcile:async(mount,src,dst)=>{let total=0;const create=[];Object.keys(src.entries).forEach((function(key){const e=src.entries[key],e2=dst.entries[key];(!e2||FS.isFile(e.mode)&&e.timestamp.getTime()>e2.timestamp.getTime())&&(create.push(key),total++)})),create.sort();const remove=[];if(Object.keys(dst.entries).forEach((function(key){src.entries[key]||(remove.push(key),total++)})),remove.sort().reverse(),!total)return;const handles="remote"===src.type?src.handles:dst.handles;for(const path of create){const relPath=PATH.normalize(path.replace(mount.mountpoint,"/")).substring(1);if("local"===dst.type){const handle=handles.get(relPath),entry=await nativeFSAsync.loadRemoteEntry(handle);nativeFSAsync.storeLocalEntry(path,entry)}else{const entry=nativeFSAsync.loadLocalEntry(path);await nativeFSAsync.storeRemoteEntry(handles,relPath,entry)}}for(const path of remove)if("local"===dst.type)nativeFSAsync.removeLocalEntry(path);else{const relPath=PATH.normalize(path.replace(mount.mountpoint,"/")).substring(1);await nativeFSAsync.removeRemoteEntry(handles,relPath)}}};module.FS.filesystems.NATIVEFS_ASYNC=nativeFSAsync}(Module)))}function finalizeBootstrap(API,config){API.runPythonInternal_dict=API._pyodide._base.eval_code("{}"),API.importlib=API.runPythonInternal("import importlib; importlib");let import_module=API.importlib.import_module;API.sys=import_module("sys"),API.sys.path.insert(0,config.homedir),API.os=import_module("os");let globals=API.runPythonInternal("import __main__; __main__.__dict__"),builtins=API.runPythonInternal("import builtins; builtins.__dict__");var builtins_dict;API.globals=(builtins_dict=builtins,new Proxy(globals,{get:(target,symbol)=>"get"===symbol?key=>{let result=target.get(key);return void 0===result&&(result=builtins_dict.get(key)),result}:"has"===symbol?key=>target.has(key)||builtins_dict.has(key):Reflect.get(target,symbol)}));let importhook=API._pyodide._importhook;importhook.register_js_finder(),importhook.register_js_module("js",config.jsglobals);let pyodide=API.makePublicAPI();return importhook.register_js_module("pyodide_js",pyodide),API.pyodide_py=import_module("pyodide"),API.pyodide_code=import_module("pyodide.code"),API.pyodide_ffi=import_module("pyodide.ffi"),API.package_loader=import_module("pyodide._package_loader"),API.sitepackages=API.package_loader.SITE_PACKAGES.__str__(),API.dsodir=API.package_loader.DSO_DIR.__str__(),API.defaultLdLibraryPath=[API.dsodir,API.sitepackages],API.os.environ.__setitem__("LD_LIBRARY_PATH",API.defaultLdLibraryPath.join(":")),pyodide.pyodide_py=API.pyodide_py,pyodide.globals=API.globals,pyodide}async function loadPyodide(options={}){await async function(){if(!IN_NODE)return;if(nodeUrlMod=(await __webpack_require__.e(/*! import() */ "_148e").then(__webpack_require__.t.bind(__webpack_require__, /*! url */ "?148e", 23))).default,nodeFsPromisesMod=await __webpack_require__.e(/*! import() */ "_7977").then(__webpack_require__.t.bind(__webpack_require__, /*! fs/promises */ "?7977", 23)),nodeFetch=globalThis.fetch?fetch:(await __webpack_require__.e(/*! import() */ "node_modules_pnpm_node-fetch_2_7_0_node_modules_node-fetch_browser_js").then(__webpack_require__.t.bind(__webpack_require__, /*! node-fetch */ "../../../node_modules/.pnpm/node-fetch@2.7.0/node_modules/node-fetch/browser.js", 23))).default,nodeVmMod=(await __webpack_require__.e(/*! import() */ "_bf79").then(__webpack_require__.t.bind(__webpack_require__, /*! vm */ "?bf79", 23))).default,nodePath=await __webpack_require__.e(/*! import() */ "_0e99").then(__webpack_require__.t.bind(__webpack_require__, /*! path */ "?0e99", 23)),pathSep=nodePath.sep,"undefined"!="function")return;const node_modules={fs:await __webpack_require__.e(/*! import() */ "_8b49").then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ "?8b49", 23)),crypto:await __webpack_require__.e(/*! import() */ "_c04c").then(__webpack_require__.t.bind(__webpack_require__, /*! crypto */ "?c04c", 23)),ws:await __webpack_require__.e(/*! import() */ "_8e35").then(__webpack_require__.t.bind(__webpack_require__, /*! ws */ "?8e35", 23)),child_process:await __webpack_require__.e(/*! import() */ "_3f74").then(__webpack_require__.t.bind(__webpack_require__, /*! child_process */ "?3f74", 23))};globalThis.require=function(mod){return node_modules[mod]}}();let indexURL=options.indexURL||function(){if(true)return __dirname;let err;try{throw new Error}catch(e){err=e}let fileName=ErrorStackParser.parse(err)[0].fileName;const indexOfLastSlash=fileName.lastIndexOf(pathSep);if(-1===indexOfLastSlash)throw new Error("Could not extract indexURL path from pyodide module location");return fileName.slice(0,indexOfLastSlash)}();indexURL=resolvePath(indexURL),indexURL.endsWith("/")||(indexURL+="/"),options.indexURL=indexURL;const default_config={fullStdLib:!1,jsglobals:globalThis,stdin:globalThis.prompt?globalThis.prompt:void 0,homedir:"/home/pyodide",lockFileURL:indexURL+"repodata.json",args:[],_node_mounts:[]},config=Object.assign(default_config,options),Module=function(){let Module={noImageDecoding:!0,noAudioDecoding:!0,noWasmDecoding:!1,preRun:[],quit:(status,toThrow)=>{throw Module.exited={status:status,toThrow:toThrow},toThrow}};return Module}();Module.print=config.stdout,Module.printErr=config.stderr,Module.arguments=config.args;const API={config:config};Module.API=API,initializeFileSystem(Module,config);const moduleLoaded=new Promise((r=>Module.postRun=r));if(Module.locateFile=path=>config.indexURL+path,"function"!=typeof _createPyodideModule){const scriptSrc=`${config.indexURL}pyodide.asm.js`;await loadScript(scriptSrc)}if(await _createPyodideModule(Module),await moduleLoaded,Module.exited)throw Module.exited.toThrow;if("0.23.3"!==API.version)throw new Error(`Pyodide version does not match: '0.23.3' <==> '${API.version}'. If you updated the Pyodide version, make sure you also updated the 'indexURL' parameter passed to loadPyodide.`);Module.locateFile=path=>{throw new Error("Didn't expect to load any more file_packager files!")};let[err,captured_stderr]=API.rawRun("import _pyodide_core");err&&Module.API.fatal_loading_error("Failed to import _pyodide_core\n",captured_stderr);const pyodide=finalizeBootstrap(API,config);if(pyodide.version.includes("dev")||API.setCdnUrl(`https://cdn.jsdelivr.net/pyodide/v${pyodide.version}/full/`),await API.packageIndexReady,API._pyodide._importhook.register_module_not_found_hook(API._import_name_to_package_name,API.repodata_unvendored_stdlibs_and_test),"0.23.3"!==API.repodata_info.version)throw new Error("Lock file version doesn't match Pyodide version");return API.package_loader.init_loaded_packages(),config.fullStdLib&&await pyodide.loadPackage(API.repodata_unvendored_stdlibs),API.initializeStreams(config.stdin,config.stdout,config.stderr),pyodide}globalThis.loadPyodide=loadPyodide,exports.loadPyodide=loadPyodide,exports.version="0.23.3",Object.defineProperty(exports,"__esModule",{value:!0})}));
//# sourceMappingURL=pyodide.js.map


/***/ }),

/***/ "../../../node_modules/.pnpm/@freecodecamp+curriculum-helpers@3.4.0/node_modules/@freecodecamp/curriculum-helpers/dist/index.mjs":
/*!***************************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@freecodecamp+curriculum-helpers@3.4.0/node_modules/@freecodecamp/curriculum-helpers/dist/index.mjs ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CSSHelp: () => (/* binding */ N),
/* harmony export */   concatRegex: () => (/* binding */ b),
/* harmony export */   escapeRegExp: () => (/* binding */ R),
/* harmony export */   getFunctionParams: () => (/* binding */ C),
/* harmony export */   isCalledWithNoArgs: () => (/* binding */ L),
/* harmony export */   python: () => (/* binding */ O),
/* harmony export */   removeCssComments: () => (/* binding */ S),
/* harmony export */   removeHtmlComments: () => (/* binding */ w),
/* harmony export */   removeJSComments: () => (/* binding */ G),
/* harmony export */   removeWhiteSpace: () => (/* binding */ x)
/* harmony export */ });
var e={d:(n,t)=>{for(var r in t)e.o(t,r)&&!e.o(n,r)&&Object.defineProperty(n,r,{enumerable:!0,get:t[r]})},o:(e,n)=>Object.prototype.hasOwnProperty.call(e,n)},n={};e.d(n,{Z5:()=>y,yS:()=>m,Nt:()=>h,jX:()=>v,US:()=>E,Hg:()=>g,ep:()=>c,gu:()=>u,Gs:()=>_,Sc:()=>p});const t=(e,n={})=>{const t=!0===n.safe||!0===n.keepProtected;let r=!1;const s=e=>{let i,o,a="";if("nodes"in e)for(const l of e.nodes)switch(l.type){case"block":if(n.first&&!0===r){a+=s(l);break}if(!0===n.preserveNewlines){i=s(l),o=i.split("\n"),a+="\n".repeat(o.length-1);break}if(!0===t&&!0===l.protected){a+=s(l);break}r=!0;break;case"line":if(n.first&&!0===r){a+=l.value;break}!0===t&&!0===l.protected&&(a+=l.value),r=!0;break;default:a+=l.value||""}return a};return s(e)};class r{constructor(e){this.type=e.type,this.value=e.value,this.match=e.match,this.newline=e.newline||""}get protected(){return Boolean(this.match&&"!"===this.match[1])}}class s extends r{constructor(e){super(e),this.nodes=(null==e?void 0:e.nodes)||[]}push(e){this.nodes.push(e)}get protected(){return this.nodes.length>0&&!0===this.nodes[0].protected}}const i={ada:{LINE_REGEX:/^--.*/},apl:{LINE_REGEX:/^⍝.*/},applescript:{BLOCK_OPEN_REGEX:/^\(\*/,BLOCK_CLOSE_REGEX:/^\*\)/},csharp:{LINE_REGEX:/^\/\/.*/},haskell:{BLOCK_OPEN_REGEX:/^\{-/,BLOCK_CLOSE_REGEX:/^-\}/,LINE_REGEX:/^--.*/},javascript:{BLOCK_OPEN_REGEX:/^\/\*\*?(!?)/,BLOCK_CLOSE_REGEX:/^\*\/(\n?)/,LINE_REGEX:/^\/\/(!?).*/},lua:{BLOCK_OPEN_REGEX:/^--\[\[/,BLOCK_CLOSE_REGEX:/^\]\]/,LINE_REGEX:/^--.*/},matlab:{BLOCK_OPEN_REGEX:/^%{/,BLOCK_CLOSE_REGEX:/^%}/,LINE_REGEX:/^%.*/},perl:{LINE_REGEX:/^#.*/},php:{BLOCK_OPEN_REGEX:/^\/\*\*?(!?)/,BLOCK_CLOSE_REGEX:/^\*\/(\n?)/,LINE_REGEX:/^(#|\/\/).*?(?=\?>|\n)/},ruby:{BLOCK_OPEN_REGEX:/^=begin/,BLOCK_CLOSE_REGEX:/^=end/,LINE_REGEX:/^#.*/},shebang:{LINE_REGEX:/^#!.*/},python:{BLOCK_OPEN_REGEX:/^"""/,BLOCK_CLOSE_REGEX:/^"""/,LINE_REGEX:/^#.*/},c:{BLOCK_OPEN_REGEX:/^\/\*\*?(!?)/,BLOCK_CLOSE_REGEX:/^\*\/(\n?)/,LINE_REGEX:/^\/\/(!?).*/},css:{BLOCK_OPEN_REGEX:/^\/\*\*?(!?)/,BLOCK_CLOSE_REGEX:/^\*\/(\n?)/,LINE_REGEX:/^\/\/(!?).*/},java:{BLOCK_OPEN_REGEX:/^\/\*\*?(!?)/,BLOCK_CLOSE_REGEX:/^\*\/(\n?)/,LINE_REGEX:/^\/\/(!?).*/},js:{BLOCK_OPEN_REGEX:/^\/\*\*?(!?)/,BLOCK_CLOSE_REGEX:/^\*\/(\n?)/,LINE_REGEX:/^\/\/(!?).*/},less:{BLOCK_OPEN_REGEX:/^\/\*\*?(!?)/,BLOCK_CLOSE_REGEX:/^\*\/(\n?)/,LINE_REGEX:/^\/\/(!?).*/},pascal:{BLOCK_OPEN_REGEX:/^\(\*/,BLOCK_CLOSE_REGEX:/^\*\)/},ocaml:{BLOCK_OPEN_REGEX:/^\(\*/,BLOCK_CLOSE_REGEX:/^\*\)/},sass:{BLOCK_OPEN_REGEX:/^\/\*\*?(!?)/,BLOCK_CLOSE_REGEX:/^\*\/(\n?)/,LINE_REGEX:/^\/\/(!?).*/},sql:{LINE_REGEX:/^--.*/},swift:{BLOCK_OPEN_REGEX:/^\/\*\*?(!?)/,BLOCK_CLOSE_REGEX:/^\*\/(\n?)/,LINE_REGEX:/^\/\/(!?).*/},ts:{BLOCK_OPEN_REGEX:/^\/\*\*?(!?)/,BLOCK_CLOSE_REGEX:/^\*\/(\n?)/,LINE_REGEX:/^\/\/(!?).*/},typscript:{BLOCK_OPEN_REGEX:/^\/\*\*?(!?)/,BLOCK_CLOSE_REGEX:/^\*\/(\n?)/,LINE_REGEX:/^\/\/(!?).*/}},o=/^\\./,a=/^(['"`])((?:\\\1|[^\1])*?)(\1)/,l=/^\r*\n/,f=(e,n={})=>{var t;if("string"!=typeof e)throw new TypeError("Expected input to be a string");const f=new s({type:"root",nodes:[],value:""}),d=[f],u=(n.language||"javascript").toLowerCase(),c=i[u];if(void 0===c)throw new Error(`Language "${u}" is not supported by strip-comments`);const{LINE_REGEX:_,BLOCK_OPEN_REGEX:p,BLOCK_CLOSE_REGEX:h}=c;let E,m,g=f,y=e,v=!1;[p,h].filter((e=>void 0!==e)).every((e=>'^"""'===e.source))&&(v=!0);const N=(e=y[0]||"")=>(y=y.slice(e.length),e),b=(e,n="text")=>{const t=e.exec(y);if(t)return N(t[0]),{type:n,value:t[0],match:t}},R=e=>{m&&"text"===m.type&&"text"===e.type?m.value=m.value?m.value+e.value:e.value:(g.push(e),"nodes"in e&&e.nodes&&(d.push(e),g=e),m=e)},C=()=>{if("root"===g.type)throw new SyntaxError("Unclosed block comment");d.pop(),g=d[d.length-1]};for(;""!==y;)(E=b(o,"text"))?R(new s(E)):"block"===g.type||m&&/\w$/.test(null!==(t=m.value)&&void 0!==t?t:"")||v&&y.startsWith('"""')||!(E=b(a,"text"))?(E=b(l,"newline"))?R(new r(E)):!p||!n.block||v&&"block"===g.type||!(E=b(p,"open"))?h&&"block"===g.type&&n.block&&(E=b(h,"close"))?(E.newline=E.match[1]||"",R(new r(E)),C()):_&&"block"!==g.type&&n.line&&(E=b(_,"line"))||(E=b(/^[a-zABD-Z0-9\t ]+/,"text"))?R(new r(E)):R(new r({type:"text",value:N(y[0])})):(R(new s({type:"block"})),R(new r(E))):R(new r(E));return f},d=(e,n)=>{const r=Object.assign(Object.assign({},n),{block:!0,line:!0});return t(f(e,r),r)};function u(e){return e.replace(/<!--[\s\S]*?(-->|$)/g,"")}function c(e){return e.replace(/\/\*[\s\S]+?\*\//g,"")}function _(e){try{return d(e)}catch(n){return e}}function p(e){return e.replace(/\s/g,"")}function h(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function E(e,n){var t;const r=d(n),s=`^\\s*?${h(e)}\\(\\s*?\\)`,i=null!==(t=new RegExp(s,"gm").exec(r))&&void 0!==t?t:[];return Boolean(i.length)}function m(...e){const n=e.map((e=>new RegExp(e).source)).join("");return new RegExp(n)}d.block=(e,n)=>{const r=Object.assign(Object.assign({},n),{block:!0});return t(f(e,r),r)},d.line=(e,n)=>{const r=Object.assign(Object.assign({},n),{line:!0});return t(f(e,r),r)},d.first=(e,n)=>{const r=Object.assign(Object.assign({},n),{block:!0,line:!0,first:!0});return t(f(e,r),r)},d.parse=f;const g={astHelpers:'import ast\n\n# A chainable class that allows us to call functions on the result of parsing a string\n\n\nclass Node:\n    def __init__(self, tree=None):\n        if isinstance(tree, str):\n            self.tree = ast.parse(tree)\n        elif isinstance(tree, ast.AST) or tree == None:\n            self.tree = tree\n        else:\n            raise TypeError("Node must be initialized with a string or AST")\n\n    def __getitem__(self, i):\n        if getattr(self.tree, "__getitem__", False):\n            return Node(self.tree[i])\n        elif getattr(self.tree, "body", False):\n            return Node(self.tree.body[i])\n        else:\n            raise IndexError("Empty Nodes cannot be indexed.")\n\n    def __len__(self):\n        if getattr(self.tree, "__len__", False):\n            return len(self.tree)\n        if self.tree is None:\n            return 0\n        if not hasattr(self.tree, "body"):\n            return 1\n        return len(self.tree.body)\n\n    def __eq__(self, other):\n        if not isinstance(other, Node):\n            return False\n        if self.tree == None:\n            return other.tree == None\n        if other.tree == None:\n            return False\n        return ast.dump(self.tree, include_attributes=True) == ast.dump(\n            other.tree, include_attributes=True\n        )\n\n    def __repr__(self):\n        if self.tree == None:\n            return "Node:\\nNone"\n        return "Node:\\n" + ast.dump(self.tree, indent=2)\n\n    def __str__(self):\n        if self.tree == None:\n            return "# no ast"\n        return ast.unparse(self.tree)\n\n    def _has_body(self):\n        return bool(getattr(self.tree, "body", False))\n\n    # "find" functions return a new node with the result of the find\n    # function. In this case, it returns a new node with the function\n    # definition (if it exists)\n\n    def find_function(self, func):\n        if not self._has_body():\n            return Node()\n        for node in self.tree.body:\n            if isinstance(node, ast.FunctionDef):\n                if node.name == func:\n                    return Node(node)\n        return Node()\n\n    def find_functions(self, func):\n        return [\n            node\n            for node in self._find_all((ast.FunctionDef, ast.AsyncFunctionDef))\n            if node.tree.name == func\n        ]\n\n    def find_async_function(self, func):\n        if not self._has_body():\n            return Node()\n        for node in self.tree.body:\n            if isinstance(node, ast.AsyncFunctionDef):\n                if node.name == func:\n                    return Node(node)\n        return Node()\n\n    def find_awaits(self):\n        return [\n            node\n            for node in self._find_all(ast.Expr)\n            if isinstance(node.tree.value, ast.Await)\n        ]\n\n    def has_args(self, arg_str):\n        if not isinstance(self.tree, (ast.FunctionDef, ast.AsyncFunctionDef)):\n            return False\n        dec_list = (f"@{Node(node)}" for node in self.tree.decorator_list)\n        dec_str = "\\n".join(dec_list) + "\\n" if dec_list else ""\n        if id := getattr(self.tree.returns, "id", False):\n            returns = f" -> {id}"\n        elif val := getattr(self.tree.returns, "value", False):\n            returns = f" -> \'{val}\'"\n        else:\n            returns = ""\n        async_kw = ""\n        if isinstance(self.tree, ast.AsyncFunctionDef):\n            async_kw = "async "\n        body_lines = str(self.find_body()).split("\\n")\n        new_body = "".join([f"\\n  {line}" for line in body_lines])\n        func_str = (\n            f"{dec_str}{async_kw}def {self.tree.name}({arg_str}){returns}:{new_body}"\n        )\n        return self.is_equivalent(func_str)\n\n    # returns_str is the annotation of the type returned by the function\n    def has_returns(self, returns_str):\n        if not isinstance(self.tree, (ast.FunctionDef, ast.AsyncFunctionDef)):\n            return False\n        if isinstance(self.tree.returns, ast.Name):\n            return returns_str == self.tree.returns.id\n        elif isinstance(self.tree.returns, ast.Constant):\n            return returns_str == self.tree.returns.value\n        return False\n\n    def find_body(self):\n        if not isinstance(self.tree, ast.AST):\n            return Node()\n        if not hasattr(self.tree, "body"):\n            return Node()\n        return Node(ast.Module(self.tree.body, []))\n\n    # find the return statement of a function\n    def find_return(self):\n        if return_list := self._find_all(ast.Return):\n            return return_list[0]\n        return Node()\n\n    def has_return(self, return_value):\n        return self.find_return().is_equivalent(f"return {return_value}")\n\n    def find_imports(self):\n        return self._find_all((ast.Import, ast.ImportFrom))\n\n    def find_comps(self):\n        return [\n            node\n            for node in self._find_all(ast.Expr)\n            if isinstance(\n                node.tree.value,\n                (ast.ListComp, ast.SetComp, ast.GeneratorExp, ast.DictComp),\n            )\n        ]\n\n    def _find_comp(\n        self, classes=(ast.ListComp, ast.SetComp, ast.GeneratorExp, ast.DictComp)\n    ):\n        if isinstance(self.tree, classes):\n            return Node(self.tree)\n        elif isinstance(self.tree, (ast.Assign, ast.AnnAssign, ast.Return)):\n            if isinstance(self.tree.value, classes):\n                return Node(self.tree.value)\n            return Node()\n\n    # find a list of iterables of a comprehension/generator expression\n    def find_comp_iters(self):\n        if not (node := self._find_comp()):\n            return []\n        return [Node(gen.iter) for gen in node.tree.generators]\n\n    # find a list of targets (iteration variables) of a comprehension/generator expression\n    def find_comp_targets(self):\n        if not (node := self._find_comp()):\n            return []\n        return [Node(gen.target) for gen in node.tree.generators]\n\n    # find the key of a dictionary comprehension\n    def find_comp_key(self):\n        if not (node := self._find_comp(ast.DictComp)):\n            return Node()\n        return Node(node.tree.key)\n\n    # find the expression evaluated for a comprehension/generator expression\n    # which is the value of the key in case of a dictionary comprehension\n    def find_comp_expr(self):\n        if not (node := self._find_comp()):\n            return Node()\n        if isinstance(node.tree, (ast.ListComp, ast.SetComp, ast.GeneratorExp)):\n            return Node(node.tree.elt)\n        elif isinstance(node.tree, ast.DictComp):\n            return Node(node.tree.value)\n\n    # find a list of `IfExpr`s at the end of the comprehension/generator expression\n    def find_comp_ifs(self):\n        if not (node := self._find_comp()):\n            return []\n        return [\n            Node(gen.ifs[i])\n            for gen in node.tree.generators\n            for i in range(len(gen.ifs))\n        ]\n\n    # "has" functions return a boolean indicating whether whatever is being\n    # searched for exists. In this case, it returns True if the variable exists.\n\n    def has_variable(self, name):\n        return self.find_variable(name) != Node()\n\n    def has_import(self, import_str):\n        return any(\n            import_node.is_equivalent(import_str) for import_node in self.find_imports()\n        )\n\n    # find a list of function calls of the \'name\' function\n    def find_calls(self, name):\n        call_list = []\n        for node in self._find_all(ast.Expr):\n            if func := getattr(node.tree.value, "func", False):\n                if isinstance(func, ast.Name) and func.id == name:\n                    call_list.append(Node(node.tree.value))\n                elif isinstance(func, ast.Attribute) and func.attr == name:\n                    call_list.append(Node(node.tree.value))\n        return call_list\n\n    def has_call(self, call):\n        return any(node.is_equivalent(call) for node in self._find_all(ast.Expr))\n\n    def find_call_args(self):\n        if not isinstance(self.tree, ast.Call):\n            return []\n        return [Node(arg) for arg in self.tree.args]\n\n    def has_stmt(self, node_str):\n        if not self._has_body():\n            return False\n        return any(Node(node).is_equivalent(node_str) for node in self.tree.body)\n\n    def find_variable(self, name):\n        if not self._has_body():\n            return Node()\n        for node in self.tree.body:\n            if isinstance(node, ast.Assign):\n                for target in node.targets:\n                    if isinstance(target, ast.Name):\n                        if target.id == name:\n                            return Node(node)\n                    if isinstance(target, ast.Attribute):\n                        names = name.split(".")\n                        if target.value.id == names[0] and target.attr == names[1]:\n                            return Node(node)\n            elif isinstance(node, ast.AnnAssign):\n                if isinstance(node.target, ast.Name):\n                    if node.target.id == name:\n                        return Node(node)\n        return Node()\n\n    # find variable incremented or decremented using += or -=\n    def find_aug_variable(self, name):\n        if not self._has_body():\n            return Node()\n        for node in self.tree.body:\n            if isinstance(node, ast.AugAssign):\n                if isinstance(node.target, ast.Name):\n                    if node.target.id == name:\n                        return Node(node)\n        return Node()\n\n    def get_variable(self, name):\n        var = self.find_variable(name)\n        if var != Node():\n            return var.tree.value.value\n        else:\n            return None\n\n    def has_function(self, name):\n        return self.find_function(name) != Node()\n\n    def has_class(self, name):\n        return self.find_class(name) != Node()\n\n    def has_decorators(self, *args):\n        # the order of args does matter\n        if not isinstance(self.tree, (ast.FunctionDef, ast.AsyncFunctionDef)):\n            return False\n        dec_list = (Node(node) for node in self.tree.decorator_list)\n        return all(any(dec.is_equivalent(arg) for dec in dec_list) for arg in args)\n\n    # Checks if the current scope contains a "pass" statement\n\n    def has_pass(self):\n        if isinstance(self.tree, (ast.If, ast.While, ast.For)):\n            return False\n        if getattr(self.tree, "body", False):\n            return any(isinstance(node, ast.Pass) for node in self.tree.body)\n        return False\n\n    # Checks the variable, name, is in the current scope and is an integer\n\n    def is_integer(self):\n        if not isinstance(self.tree, ast.Assign):\n            return False\n        return type(self.tree.value.value) == type(1)\n\n    def value_is_call(self, name):\n        if not isinstance(self.tree, ast.Assign):\n            return False\n        call = self.tree.value\n        if isinstance(call, ast.Call):\n            return call.func.id == name\n        return False\n\n    # Loosely compares the code in target_str with the code represented by the\n    # Node\'s AST. If the two codes are semantically equivalent (i.e. the same if\n    # you ignore formatting and context) then this returns True, otherwise\n    # False.\n    #\n    # Ignoring context means that the following comparison is True despite the\n    # fact that the AST of `cond_node` is `Constant(value=True)` and `True`\n    # compiles to `Module(body=[Expr(value=Constant(value=True))],\n    # type_ignores=[])`:\n    #\n    # node = Node("if True:\\n  pass") cond_node =\n    # node.find_ifs()[0].find_conditions()[0] cond_node.is_equivalent("True")\n\n    def is_equivalent(self, target_str):\n        # Setting the tree to None is used to represent missing elements. Such\n        # as the condition of a final else clause. It is, therefore, not\n        # equivalent to any string.\n        if self.tree == None:\n            return False\n        code_str = ast.unparse(self.tree)\n\n        # Why parse and unparse again? Because of an edge case when comparing\n        # the `target_str` "\'True\'" with the test in "if \'True\':". These should\n        # be equivalent, but the condition unparses to "\'True\'", while the\n        # `target_str` becomes \'"""True"""\' when parsed and unparsed again.\n\n        # By parsing and unparsing `code_str` we get \'"""True"""\' and the\n        # comparison returns True as expected.\n        return ast.unparse(ast.parse(code_str)) == ast.unparse(ast.parse(target_str))\n\n    def is_empty(self):\n        return self.tree == None\n\n    # Finds the class definition with the given name\n\n    def find_class(self, class_name):\n        if not self._has_body():\n            return Node()\n        for node in self.tree.body:\n            if isinstance(node, ast.ClassDef):\n                if node.name == class_name:\n                    return Node(node)\n        return Node()\n\n    def inherits_from(self, *args):\n        if not isinstance(self.tree, ast.ClassDef):\n            return False\n        if not self.tree.bases:\n            return False\n        id_list = [node.id for node in self.tree.bases]\n        return all(arg in id_list for arg in args)\n\n    # Find an array of conditions in an if statement\n\n    def find_ifs(self):\n        return self._find_all(ast.If)\n\n    def _find_all(self, ast_type):\n        return [Node(node) for node in self.tree.body if isinstance(node, ast_type)]\n\n    def find_whiles(self):\n        return self._find_all(ast.While)\n\n    def find_for_loops(self):\n        return self._find_all(ast.For)\n\n    def find_for_vars(self):\n        if not isinstance(self.tree, ast.For):\n            return Node()\n        return Node(self.tree.target)\n\n    def find_for_iter(self):\n        if not isinstance(self.tree, ast.For):\n            return Node()\n        return Node(self.tree.iter)\n\n    def find_if(self, if_str):\n        if_list = self._find_all(ast.If)\n        for if_statement in if_list:\n            if if_statement.find_conditions()[0].is_equivalent(if_str):\n                return if_statement\n        return Node()\n\n    def find_while(self, while_str):\n        while_list = self._find_all(ast.While)\n        for while_loop in while_list:\n            if while_loop.find_conditions()[0].is_equivalent(while_str):\n                return while_loop\n        return Node()\n\n    def find_for(self, target_str, iter_str):\n        for_list = self._find_all(ast.For)\n        for for_loop in for_list:\n            if for_loop.find_for_vars().is_equivalent(\n                target_str\n            ) and for_loop.find_for_iter().is_equivalent(iter_str):\n                return for_loop\n        return Node()\n\n    # Find an array of bodies in if/elif statement and while or for loops\n\n    def find_bodies(self):\n        def _find_bodies(tree):\n            if not isinstance(tree, (ast.If, ast.While, ast.For)):\n                return []\n            if tree.orelse == []:\n                return [tree.body]\n            if isinstance(tree.orelse[0], (ast.If, ast.While, ast.For)):\n                return [tree.body] + _find_bodies(tree.orelse[0])\n\n            return [tree.body] + [tree.orelse]\n\n        return [Node(ast.Module(body, [])) for body in _find_bodies(self.tree)]\n\n    # Find an array of conditions in if/elif statement or while loop\n\n    def find_conditions(self):\n        def _find_conditions(tree):\n            if not isinstance(tree, (ast.If, ast.While)):\n                return []\n            test = tree.test\n            if tree.orelse == []:\n                return [test]\n            if isinstance(tree.orelse[0], (ast.If, ast.While)):\n                return [test] + _find_conditions(tree.orelse[0])\n\n            return [test, None]\n\n        return [Node(test) for test in _find_conditions(self.tree)]\n\n    # Returs a Boolean indicating if the statements passed as arguments\n    # are found in the same order in the tree (statements can be non-consecutive)\n    def is_ordered(self, *args):\n        if not self._has_body():\n            return False\n        if len(args) < 2:\n            return False\n        arg_dict = {key: None for key in range(len(args))}\n        for i, node in enumerate(self.tree.body):\n            for j, arg in enumerate(args):\n                if Node(node).is_equivalent(arg):\n                    arg_dict[j] = i\n                    break\n        if None in arg_dict.values():\n            return False\n        return all(arg_dict[n] < arg_dict[n + 1] for n in range(len(arg_dict) - 1))\n\n\n# Exception formatting functions. Currently bundled with the Node class, until\n# we improve the testing, building and CI so that they can easily handle\n# multiple files.\n\n\ndef drop_until(*, traces, filename):\n    from itertools import dropwhile\n\n    return list(\n        dropwhile(lambda line: not line.startswith(f\'  File "{filename}"\'), traces)\n    )\n\n\ndef build_message(*, traces, exception_list):\n    return "".join(["Traceback (most recent call last):\\n"] + traces + exception_list)\n\n\ndef _replace_startswith(string, old, new):\n    if string.startswith(old):\n        return new + string[len(old) :]\n    return string\n\n\ndef format_exception(*, exception, traceback, filename, new_filename=None):\n    if new_filename is None:\n        new_filename = filename\n    from traceback import format_exception_only, format_tb\n\n    # The trace up to "filename" are the frames that are not part of the user\'s\n    # code so we drop them.\n    traces = drop_until(traces=format_tb(traceback), filename=filename)\n    renamed_traces = [\n        _replace_startswith(trace, f\'  File "{filename}"\', f\'  File "{new_filename}"\')\n        for trace in traces\n    ]\n    renamed_exception = [\n        _replace_startswith(e, f\'  File "{filename}"\', f\'  File "{new_filename}"\')\n        for e in format_exception_only(exception)\n    ]\n    return build_message(traces=renamed_traces, exception_list=renamed_exception)\n',getDef(e,n){const t=new RegExp(`\\n?(?<function_indentation> *?)def +${n} *\\((?<function_parameters>[^\\)]*)\\)\\s*:\\s*?\\n?(?<function_body>.*?)(?=\\n\\k<function_indentation>[\\w#]|$)`,"s").exec(e);if(t){const{function_parameters:e,function_body:n,function_indentation:r}=t.groups,s=r.replace(/\n+/,"");return{def:t[0].replace(/^\n/,""),function_parameters:e,function_body:n,function_indentation:s.length}}return null},removeComments:e=>e.replace(/\/\/.*|\/\*[\s\S]*?\*\/|(#.*$)/gm,""),getBlock(e,n){const t=n instanceof RegExp?n.source:n.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),r=new RegExp(`\\n?(?<block_indentation> *?)(?<block_condition>${t})\\s*:\\s*?\\n(?<block_body>(\\k<block_indentation> +[^\\n]*| *\\n)+)(\n|$)`,"sm").exec(e);if(r){const{block_body:e,block_indentation:n,block_condition:t}=r.groups;return{block_body:e,block_condition:t,block_indentation:n.replace(/\n+/g,"").length}}return null}};class y{constructor(e){this.doc=e}_getStyleRules(){const e=this.getStyleSheet();return this.styleSheetToCssRulesArray(e).filter((e=>e.type===CSSRule.STYLE_RULE))}getStyleDeclarations(e){var n;return null===(n=this._getStyleRules())||void 0===n?void 0:n.filter((n=>(null==n?void 0:n.selectorText)===e)).map((e=>e.style))}getStyle(e){var n;const t=null===(n=this._getStyleRules().find((n=>(null==n?void 0:n.selectorText)===e)))||void 0===n?void 0:n.style;return t?(t.getPropVal=(e,n=!1)=>n?t.getPropertyValue(e).replace(/\s+/g,""):t.getPropertyValue(e),t):null}getStyleAny(e){for(const n of e){const e=this.getStyle(n);if(e)return e}return null}getStyleRule(e){var n;const t=null===(n=this._getStyleRules())||void 0===n?void 0:n.find((n=>(null==n?void 0:n.selectorText)===e));return t?Object.assign(Object.assign({},t),{isDeclaredAfter:e=>(e=>n=>{var t,r,s,i;const o=(null===(r=Array.from((null===(t=e.parentStyleSheet)||void 0===t?void 0:t.cssRules)||[]))||void 0===r?void 0:r.filter((e=>e.type===CSSRule.STYLE_RULE))).find((e=>(null==e?void 0:e.selectorText)===n));return!!o&&Array.from((null===(s=e.parentStyleSheet)||void 0===s?void 0:s.cssRules)||[]).indexOf(e)>Array.from((null===(i=null==o?void 0:o.parentStyleSheet)||void 0===i?void 0:i.cssRules)||[]).indexOf(o)})(t)(e)}):null}getCSSRules(e){const n=this.getStyleSheet(),t=this.styleSheetToCssRulesArray(n);switch(e){case"media":return t.filter((e=>e.type===CSSRule.MEDIA_RULE));case"fontface":return t.filter((e=>e.type===CSSRule.FONT_FACE_RULE));case"import":return t.filter((e=>e.type===CSSRule.IMPORT_RULE));case"keyframes":return t.filter((e=>e.type===CSSRule.KEYFRAMES_RULE));default:return t}}isPropertyUsed(e){return this._getStyleRules().some((n=>{var t;return null===(t=n.style)||void 0===t?void 0:t.getPropertyValue(e)}))}getRuleListsWithinMedia(e){const n=this.getCSSRules("media"),t=null==n?void 0:n.find((n=>{var t;return(null===(t=null==n?void 0:n.media)||void 0===t?void 0:t.mediaText)===e})),r=null==t?void 0:t.cssRules;return Array.from(r||[])}getStyleSheet(){var e,n,t,r,s;const i=null===(e=this.doc)||void 0===e?void 0:e.querySelector("link[href*='styles']"),o=null===(n=this.doc)||void 0===n?void 0:n.querySelector("style.fcc-injected-styles"),a=null===(t=this.doc)||void 0===t?void 0:t.querySelector("style:not([class]):not([media])");return(null===(s=null===(r=null==i?void 0:i.sheet)||void 0===r?void 0:r.cssRules)||void 0===s?void 0:s.length)?i.sheet:o?o.sheet:a?a.sheet:null}styleSheetToCssRulesArray(e){return Array.from((null==e?void 0:e.cssRules)||[])}selectorsFromSelector(e){const n=this.doc.querySelectorAll(e),t=Array.from(n).map((e=>{const n=[],t=[],r=[];for(;e.parentNode;){let s=e.tagName.toLowerCase();Array.from(e.parentNode.children).filter((n=>n.tagName===e.tagName)).length>1&&(s+=`:nth-child(${Array.from(e.parentNode.childNodes).indexOf(e)+1})`),n.unshift(s),t.unshift(s),r.push([n.join(" > "),t.join(" ")]),e=e.parentNode}return r.flat()})).flat();return[...new Set(t)]}}function v(e){const n=e.match(/(?:function\s*[^(]*\(([^)]*)\))/)||e.match(/(?:\b(?:const|let|var)\s*\w+\s*=\s*(?:function)?\s*\(([^)]*)\))/)||e.match(/=\s+([^)]*)=>/);return n?(n[1]||n[2]||n[3]||n[4]).split(",").map((e=>{const n=e.trim().split("="),t=n.length>1?n[1].replace(/['"]/g,"").trim():void 0;return{name:n[0].trim(),defaultValue:t}})):[]}var N=n.Z5,b=n.yS,R=n.Nt,C=n.jX,L=n.US,O=n.Hg,S=n.ep,w=n.gu,G=n.Gs,x=n.Sc;
//# sourceMappingURL=index.mjs.map

/***/ }),

/***/ "../../../node_modules/.pnpm/pyodide@0.23.3/node_modules/pyodide/package.json":
/*!************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/pyodide@0.23.3/node_modules/pyodide/package.json ***!
  \************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"pyodide","version":"0.23.3","description":"The Pyodide JavaScript package","keywords":["python","webassembly"],"homepage":"https://github.com/pyodide/pyodide","repository":{"type":"git","url":"https://github.com/pyodide/pyodide"},"bugs":{"url":"https://github.com/pyodide/pyodide/issues"},"license":"Apache-2.0","devDependencies":{"@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-node-resolve":"^13.1.3","@types/assert":"^1.5.6","@types/emscripten":"^1.39.5","@types/expect":"^24.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.25","@types/node-fetch":"^2.6.1","@types/ws":"^8.5.3","chai":"^4.3.6","chai-as-promised":"^7.1.1","cross-env":"^7.0.3","dts-bundle-generator":"^6.7.0","error-stack-parser":"^2.1.4","express":"^4.17.3","mocha":"^9.0.2","npm-run-all":"^4.1.5","nyc":"^15.1.0","prettier":"^2.2.1","rollup":"^2.48.0","rollup-plugin-terser":"^7.0.2","rollup-plugin-ts":"^2.0.5","terser":"^5.7.0","ts-mocha":"^9.0.2","tsd":"^0.24.1","typedoc":"^0.22.15","typescript":"^4.6.4"},"main":"pyodide.js","exports":{".":{"require":"./pyodide.js","import":"./pyodide.mjs"},"./pyodide.asm.wasm":"./pyodide.asm.wasm","./pyodide.asm.js":"./pyodide.asm.js","./python_stdlib.zip":"./python_stdlib.zip","./pyodide.mjs":"./pyodide.mjs","./pyodide.js":"./pyodide.js","./package.json":"./package.json","./repodata.json":"./repodata.json"},"files":["pyodide.asm.js","pyodide.asm.wasm","python_stdlib.zip","pyodide.mjs","pyodide.js.map","pyodide.mjs.map","pyodide.d.ts","ffi.d.ts","repodata.json","console.html"],"browser":{"child_process":false,"crypto":false,"fs":false,"fs/promises":false,"path":false,"url":false,"vm":false,"ws":false},"scripts":{"test":"npm-run-all test:*","test:unit":"cross-env TEST_NODE=1 ts-mocha -p tsconfig.test.json test/unit/**/*.test.ts","test:node":"cross-env TEST_NODE=1 mocha test/integration/**/*.test.js","test:browser":"mocha test/integration/**/*.test.js","coverage":"cross-env TEST_NODE=1 npm-run-all coverage:*","coverage:build":"nyc npm run test:node"},"mocha":{"bail":false,"timeout":30000,"full-trace":true,"inline-diffs":true,"check-leaks":false,"global":["pyodide","page","chai"],"file":["test/conftest.js"]},"nyc":{"reporter":["html","text-summary"],"include":["*.ts"],"all":true,"clean":true,"cache":false,"instrument":false,"checkCoverage":true,"statements":95,"functions":95,"branches":80,"lines":95},"tsd":{"compilerOptions":{"lib":["ES2017","DOM"]}},"dependencies":{"base-64":"^1.0.0","node-fetch":"^2.6.1","ws":"^8.5.0"},"types":"./pyodide.d.ts"}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "-" + {"_148e":"b2ac95e7ae259e8a418a","_7977":"db849b9b7065573d872e","node_modules_pnpm_node-fetch_2_7_0_node_modules_node-fetch_browser_js":"937e362e014b78019c76","_bf79":"0207c26b4b0be05e6802","_0e99":"9d4cb7d5628d33a9cb24","_8b49":"0b717090779d2efa1545","_c04c":"04dc33699f618d22b1fb","_8e35":"808822fbc0e4ca9f80ff","_3f74":"de2ee31e3a915e4c722b"}[chunkId] + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "@freecodecamp/browser-scripts:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/js/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"python-worker": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk_freecodecamp_browser_scripts"] = self["webpackChunk_freecodecamp_browser_scripts"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**************************!*\
  !*** ./python-worker.ts ***!
  \**************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var pyodide_pyodide_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pyodide/pyodide.js */ "../../../node_modules/.pnpm/pyodide@0.23.3/node_modules/pyodide/pyodide.js");
/* harmony import */ var pyodide_pyodide_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pyodide_pyodide_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var pyodide_package_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pyodide/package.json */ "../../../node_modules/.pnpm/pyodide@0.23.3/node_modules/pyodide/package.json");
/* harmony import */ var _freecodecamp_curriculum_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @freecodecamp/curriculum-helpers */ "../../../node_modules/.pnpm/@freecodecamp+curriculum-helpers@3.4.0/node_modules/@freecodecamp/curriculum-helpers/dist/index.mjs");
// We have to specify pyodide.js because we need to import that file (not .mjs)
// and 'import' defaults to .mjs



const ctx = self;
let pyodide = null;
// Since messages are buffered, it needs to be possible to discard 'run'
// messages. Otherwise messages could build up while the worker is busy (for
// example, while loading pyodide) and the work would try to process them in
// sequence. Instead, it will ignore messages until it receives a 'listen'
// message and will inform the client every time it starts ignoring messages.
let ignoreRunMessages = true;
async function setupPyodide() {
  if (pyodide) return pyodide;
  pyodide = await (0,pyodide_pyodide_js__WEBPACK_IMPORTED_MODULE_0__.loadPyodide)({
    // TODO: host this ourselves
    indexURL: "https://cdn.jsdelivr.net/pyodide/v".concat(pyodide_package_json__WEBPACK_IMPORTED_MODULE_1__.version, "/full/")
  });

  // We freeze this to prevent learners from getting the worker into a
  // weird state. NOTE: this has to come after pyodide is loaded, because
  // pyodide modifies self while loading.
  Object.freeze(self);

  // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access
  pyodide.FS.writeFile('/home/pyodide/ast_helpers.py', _freecodecamp_curriculum_helpers__WEBPACK_IMPORTED_MODULE_2__.python.astHelpers, {
    encoding: 'utf8'
  });
  ignoreRunMessages = true;
  postMessage({
    type: 'stopped'
  });
}
function resetPyodide() {
  if (pyodide) pyodide = null;
  void setupPyodide();
}
void setupPyodide();
function initRunPython() {
  if (!pyodide) throw new Error('pyodide not loaded');
  // eslint-disable-next-line @typescript-eslint/no-unsafe-call
  const str = pyodide.globals.get('str');
  function print() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const text = args.map(x => str(x)).join(' ');
    postMessage({
      type: 'print',
      text
    });
  }
  function input(text) {
    // TODO: send unique ids to the main thread and the service worker, so we
    // can have multiple concurrent input requests.
    postMessage({
      type: 'input',
      text
    });
    const request = new XMLHttpRequest();
    request.open('POST', '/python/intercept-input/', false);
    request.send(null);

    // We want to raise a KeyboardInterrupt if the user cancels. To do that,
    // this function returns a JS object with the 'type' property set to
    // 'cancel'. Then the python code can actually raise the exception.
    return JSON.parse(request.responseText);
  }

  // I tried setting jsglobals here, to provide 'input' and 'print' to python,
  // without having to modify the global window object. However, it didn't work
  // because pyodide needs access to that object. Instead, I used
  // registerJsModule when setting up runPython.

  // Make print available to python
  pyodide.registerJsModule('jscustom', {
    print,
    input
  });
  // Create fresh globals each time user code is run.
  // eslint-disable-next-line @typescript-eslint/no-unsafe-call
  const globals = pyodide.globals.get('dict')();
  // Some tests rely on __name__ being set to __main__ and we new dicts do not
  // have this set by default.
  // eslint-disable-next-line @typescript-eslint/no-unsafe-call
  globals.set('__name__', '__main__');
  // The runPython helper is a shortcut for running python code with our
  // custom globals.
  const runPython = pyCode => pyodide.runPython(pyCode, {
    globals
  });
  runPython("\n  import jscustom\n  from jscustom import print\n  from jscustom import input\n  def __wrap(func):\n    def fn(*args):\n      data = func(*args)\n      if data.type == 'cancel':\n        raise KeyboardInterrupt(data.value)\n      return data.value\n    return fn\n  input = __wrap(input)\n  ");

  // Exposing sys.last_value can create memory leaks, so this just returns a
  // string instead of the actual exception. args[0] is what was passed to the
  // exception constructor. In our case, that's the id we want.
  // TODO: I'm using 'join' to make sure we're not leaking a reference to the
  // exception. This might be excessive, but I don't know enough about pyodide
  // to be sure.
  runPython("\n  import sys\n  def __get_reset_id():\n    if sys.last_value and sys.last_value.args:\n      return \"\".join(str(sys.last_value.args[0]))\n    else:\n      return \"\"\n  ");
  runPython("\ndef print_exception():\n    from ast_helpers import format_exception\n    formatted = format_exception(exception=sys.last_value, traceback=sys.last_traceback, filename=\"<exec>\", new_filename=\"main.py\")\n    print(formatted)\n");
  // eslint-disable-next-line @typescript-eslint/no-unsafe-call
  const printException = globals.get('print_exception');

  // eslint-disable-next-line @typescript-eslint/no-unsafe-call
  const getResetId = globals.get('__get_reset_id');
  return {
    runPython,
    getResetId,
    globals,
    printException
  };
}
ctx.onmessage = e => {
  const {
    data
  } = e;
  if (data.type === 'listen') {
    handleListenRequest();
  } else if (data.type === 'cancel') {
    handleCancelRequest(data);
  } else {
    handleRunRequest(data);
  }
};

// This lets the client know that there is nothing to cancel.
function handleCancelRequest(_ref) {
  let {
    value
  } = _ref;
  postMessage({
    type: 'is-alive',
    text: value
  });
}
function handleListenRequest() {
  ignoreRunMessages = false;
}
function handleRunRequest(data) {
  try {
    if (ignoreRunMessages) return;
    const code = (data.code.contents || '').slice();
    // TODO: use reset-terminal for clarity?
    postMessage({
      type: 'reset'
    });
    const {
      runPython,
      getResetId,
      globals,
      printException
    } = initRunPython();
    // use pyodide.runPythonAsync if we want top-level await
    try {
      runPython(code);
    } catch (e) {
      const err = e;
      // the formatted exception is printed to the terminal
      printException();
      // but the full error is logged to the console for debugging
      console.error(err);
      const resetId = getResetId();
      // TODO: if a user raises a KeyboardInterrupt with a custom message this
      // will be treated as a reset, the client will resend their code and this
      // will loop. Can we fix that? Perhaps by using a custom exception?
      if (err.type === 'KeyboardInterrupt' && resetId) {
        // If the client sends a lot of run messages, it's easy for them to build
        // up while the worker is busy. As such, we both ignore any queued run
        // messages...
        ignoreRunMessages = true;
        // ...and tell the client that we're ignoring them.
        postMessage({
          type: 'stopped',
          text: getResetId()
        });
      }
    } finally {
      getResetId.destroy();
      printException.destroy();
      globals.destroy();
    }
  } catch (e) {
    // This should only be reach if pyodide crashes, but it's helpful to log
    // the error in case it's something else.
    console.error(e);
    void resetPyodide();
  }
}
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHl0aG9uLXdvcmtlci02NDljZGQwNmE2ODIzYjYzNjkzYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7Ozs7Ozs7Ozs7OztBQ3ZMN0IsMEJBQTBCLEtBQW9ELGtCQUFrQixDQUF5SixDQUFDLHlCQUF5QixhQUFhLGdHQUFnRyxxQkFBTSxDQUFDLHFCQUFNLGdDQUFnQyxzQkFBc0IsV0FBVyxhQUFhLFlBQVksMEJBQTBCLDBCQUEwQixzQkFBc0IseUNBQXlDLDBCQUEwQixvREFBb0Qsb0JBQW9CLGtCQUFrQixnQkFBZ0IsMFJBQTBSLHlCQUF5QixtQkFBbUIsZUFBZSw2RUFBNkUsc0JBQXNCLG1CQUFtQixpQkFBaUIscUJBQXFCLHFHQUFxRyxZQUFZLDBCQUEwQix1QkFBdUIsMkJBQTJCLDZDQUE2QyxLQUFLLDZGQUE2RixtQ0FBbUMscUJBQXFCLHdKQUF3SixxUEFBcVAscUNBQXFDLDZOQUE2TixpS0FBaUssdUJBQXVCLDhIQUE4SCxHQUFHLFlBQVksc0JBQXNCLDJKQUEySixtQkFBbUIsb0JBQW9CLGtCQUFrQixZQUFZLHNCQUFzQiwySkFBMkosbUJBQW1CLDREQUE0RCxtQkFBbUIsa0JBQWtCLFlBQVkscUJBQXFCLHdKQUF3SixtQkFBbUIsbUJBQW1CLGlCQUFpQixrQkFBa0IsR0FBRyxzQ0FBc0MsNEZBQTRGLDBNQUEwTSxzQkFBc0IsOEZBQThGLHlGQUF5RixrREFBa0QsbURBQW1ELG1DQUFtQyw2Q0FBNkMsMkVBQTJFLG1EQUFtRCw2QkFBNkIsc0RBQXNELDJDQUEyQyw0QkFBNEIsNkdBQTZHLHVJQUF1SSwyRUFBMkUsNk1BQTZNLHVCQUF1QixrSEFBa0gsRUFBRSxRQUFRLGlDQUFpQyxzREFBc0QsNkNBQTZDLDRCQUE0QixtTEFBbUwsa0JBQWtCLEVBQUUsbU5BQW1OLHVCQUF1QiwwSEFBMEgsRUFBRSxRQUFRLHdCQUF3QixvTEFBb0wseUJBQXlCLDhHQUE4RyxNQUFNLE1BQU0sZ0NBQWdDLG1DQUFtQyxzREFBc0QsR0FBRyxjQUFjLDBCQUEwQiwwSUFBMEksTUFBTSxNQUFNLGdDQUFnQyxtQ0FBbUMsb0ZBQW9GLEdBQUcsY0FBYyw4QkFBOEIsc0RBQXNELGtGQUFrRiw0QkFBNEIsOE5BQThOLDZGQUE2RiwyRkFBMkYsdUJBQXVCLG9JQUFvSSxFQUFFLFNBQVMsRUFBRSxtQkFBbUIsOENBQThDLCtCQUErQixPQUFPLG1CQUFtQixPQUFPLDRCQUE0QixPQUFPLHlCQUF5QixPQUFPLFNBQVMsNEdBQTRHLDJDQUEyQyx3Q0FBd0MscUJBQXFCLG9FQUFvRSw0RkFBNEYseUZBQXlGLG1DQUFtQyxtREFBbUQsS0FBSyxxQkFBcUIscURBQXFELGtEQUFrRCxvRUFBb0Usc0NBQXNDLGlDQUFpQyw2QkFBNkIsMEJBQTBCLEdBQUcsbUNBQW1DLG1EQUFtRCxJQUFJLHFCQUFxQixvREFBb0Qsc0ZBQXNGLHdEQUF3RCxJQUFJLDhCQUE4QixTQUFTLHFDQUFxQyw2Q0FBNkMsS0FBSyxvRUFBb0UsK0JBQStCLDZEQUE2RCw4SkFBOEoscUJBQXFCLCtEQUErRCxzQkFBc0IsdUNBQXVDLGdCQUFnQixtQ0FBbUMsMkJBQTJCLG1GQUFtRiwwQkFBMEIscUZBQXFGLGdDQUFnQyxzQ0FBc0MsOEVBQThFLFlBQVksSUFBSSxpQkFBaUIsdUJBQXVCLDZDQUE2Qyw4QkFBOEIscUNBQXFDLFNBQVMsZUFBZSxFQUFFLFVBQVUsMkNBQTJDLEtBQUsscUNBQXFDLGlCQUFpQiwyQ0FBMkMsV0FBVyxJQUFJLG1EQUFtRCwyQkFBMkIsRUFBRSxxQkFBcUIsb0VBQW9FLGFBQWEsS0FBSyxhQUFhLFFBQVEsSUFBSSxnREFBZ0QsUUFBUSx5QkFBeUIsWUFBWSxxQkFBcUIsMEJBQTBCLDZCQUE2QiwrREFBK0QsZ0NBQWdDLGVBQWUsNkNBQTZDLGNBQWMsaUhBQWlILDhDQUE4Qyx5QkFBeUIsNEVBQTRFLDhEQUE4RCxRQUFRLEdBQUcsUUFBUSx3RkFBd0Ysa0NBQWtDLFFBQVEsRUFBRSxRQUFRLGNBQWMsY0FBYyx3RkFBd0YsaUJBQWlCLDZDQUE2QyxHQUFHLEdBQUcseUNBQXlDLCtCQUErQixJQUFJLDBCQUEwQixTQUFTLCtEQUErRCxLQUFLLHVGQUF1RiwyQ0FBMkMsR0FBRyxnREFBZ0QseUJBQXlCLG1HQUFtRyxXQUFXLFFBQVEsR0FBRyxzRUFBc0UscUZBQXFGLHFEQUFxRCxxRkFBcUYseUNBQXlDLHlDQUF5QyxJQUFJLGdKQUFnSiw0REFBNEQsU0FBUyxhQUFhLHFCQUFxQixnQ0FBZ0Msc0JBQXNCLHdCQUF3QiwwQkFBMEIsNkJBQTZCLDJGQUEyRixLQUFLLGFBQWEsRUFBRSx3Q0FBd0MscUhBQXFILHFDQUFxQyxPQUFPLDhCQUE4Qiw0QkFBNEIsMEZBQTBGLDBGQUEwRiwySkFBMkosRUFBRSxPQUFPLCtDQUErQyx1QkFBdUIsdURBQXVELDhCQUE4QixxQ0FBcUMsa0ZBQWtGLDREQUE0RCwyQ0FBMkMsZ0NBQWdDLHNEQUFzRCxLQUFLLHFFQUFxRSxrQ0FBa0MsVUFBVSxFQUFFLHlFQUF5RSx5QkFBeUIsdUJBQXVCLHlFQUF5RSxnQ0FBZ0MseUJBQXlCLGtDQUFrQyxPQUFPLGdIQUFnSCxvQ0FBb0MsZ0RBQWdELDhDQUE4Qyw4Q0FBOEMsNElBQTRJLFVBQVUsZ0VBQWdFLFVBQVUsRUFBRSx5QkFBeUIsNkNBQTZDLDREQUE0RCx5QkFBeUIseUNBQXlDLHNEQUFzRCw0RUFBNEUsa0NBQWtDLFlBQVksZ0JBQWdCLGdEQUFnRCw2Q0FBNkMsbUdBQW1HLGlCQUFpQixnQkFBZ0IsbURBQW1ELDZDQUE2Qyx5Q0FBeUMsMERBQTBELDBCQUEwQiw4RUFBOEUsdUJBQXVCLG9GQUFvRiwwQ0FBMEMsS0FBSywrQ0FBK0MsNkRBQTZELG9GQUFvRixLQUFLLDhFQUE4RSwwREFBMEQsbURBQW1ELFdBQVcsdUNBQXVDLDJEQUEyRCwwREFBMEQsWUFBWSw4Q0FBOEMsOEZBQThGLG9EQUFvRCxxRUFBcUUsb0JBQW9CLGtCQUFrQix1REFBdUQsMENBQTBDLDJCQUEyQiwrREFBK0Qsd0ZBQXdGLEdBQUcsd0NBQXdDLHFGQUFxRixnQ0FBZ0MscWpCQUFxakIscUNBQXFDLEVBQUUsdUJBQXVCLG1CQUFtQixxQkFBcUIsNEhBQWEsa0NBQWtDLG9JQUFxQix5Q0FBeUMsNlFBQW9CLDJCQUEyQiwySEFBWSx5QkFBeUIsNkhBQWMsbUNBQW1DLFVBQWMsUUFBUSxvQkFBb0IsU0FBUywySEFBWSxjQUFjLCtIQUFnQixVQUFVLDJIQUFZLHFCQUFxQixzSUFBdUIsRUFBRSxpQ0FBaUMsMEJBQTBCLEdBQUcsMENBQTBDLEdBQUcsSUFBMEIsUUFBUSxTQUFTLENBQUMsUUFBUSxJQUFJLGdCQUFnQixTQUFTLE1BQU0scURBQXFELHFEQUFxRCx5R0FBeUcsMENBQTBDLEdBQUcsaUdBQWlHLHNCQUFzQix5S0FBeUssZ0VBQWdFLFlBQVksMEZBQTBGLHFCQUFxQiw4QkFBOEIsV0FBVyxjQUFjLEdBQUcsc0ZBQXNGLFdBQVcsZUFBZSxtREFBbUQsc0RBQXNELHlGQUF5RixtQkFBbUIsZ0JBQWdCLGdCQUFnQiw0QkFBNEIsbUdBQW1HLDRGQUE0RixZQUFZLG9IQUFvSCx5QkFBeUIsd0VBQXdFLDREQUE0RCx3RkFBd0YsNENBQTRDLHVGQUF1RixnQkFBZ0IsZ1JBQWdSLHVNQUF1TSx3SUFBd0ksU0FBUyxFQUFFO0FBQ240b0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNEQSxPQUFPLFVBQVUsK0RBQStELHVCQUF1QixFQUFFLG9EQUFvRCxNQUFNLE9BQU8sMEZBQTBGLEVBQUUsZUFBZSxJQUFJLDBDQUEwQyxTQUFTLFlBQVksYUFBYSxxREFBcUQsZ0NBQWdDLFFBQVEsTUFBTSw0QkFBNEIsa0RBQWtELE1BQU0sNkJBQTZCLFFBQVEsTUFBTSxLQUFLLE1BQU0sK0JBQStCLFdBQVcsTUFBTSw0Q0FBNEMsTUFBTSx1QkFBdUIsVUFBVSxhQUFhLFFBQVEsZUFBZSxrRkFBa0YsZ0JBQWdCLGlEQUFpRCxrQkFBa0IsZUFBZSxpREFBaUQsUUFBUSxtQkFBbUIsZ0JBQWdCLDBEQUEwRCxTQUFTLEtBQUssbUJBQW1CLE1BQU0sa0JBQWtCLGNBQWMsbURBQW1ELFNBQVMscUJBQXFCLFVBQVUscUJBQXFCLDBCQUEwQixxQkFBcUIsYUFBYSx3RkFBd0YsTUFBTSx3RUFBd0UsU0FBUyxxQkFBcUIsd0JBQXdCLG9CQUFvQixPQUFPLGtCQUFrQixNQUFNLG1HQUFtRyxPQUFPLHVFQUF1RSxVQUFVLG1CQUFtQixTQUFTLG1FQUFtRSxJQUFJLHdGQUF3RixNQUFNLHdGQUF3RixPQUFPLHdGQUF3RixLQUFLLHdGQUF3RixPQUFPLHdGQUF3RixTQUFTLG1EQUFtRCxRQUFRLG1EQUFtRCxPQUFPLHdGQUF3RixNQUFNLG1CQUFtQixRQUFRLHdGQUF3RixLQUFLLHdGQUF3RixZQUFZLHlGQUF5RixpRUFBaUUsSUFBSSxNQUFNLDJFQUEyRSxlQUFlLDhCQUE4QiwwREFBMEQsMkNBQTJDLEVBQUUsdUNBQXVDLE1BQU0sb0RBQW9ELEdBQUcscUJBQXFCLG9FQUFvRSwrREFBK0Qsa0JBQWtCLHFCQUFxQiwyQkFBMkIsT0FBTyxrSUFBa0ksUUFBUSxtRUFBbUUseUJBQXlCLEtBQUssT0FBTywrWkFBK1osMEJBQTBCLGFBQWEsYUFBYSw0QkFBNEIsU0FBUyxXQUFXLHNDQUFzQyxLQUFLLGlCQUFpQixFQUFFLG9CQUFvQixjQUFjLDRDQUE0QyxjQUFjLHlDQUF5QyxjQUFjLElBQUksWUFBWSxTQUFTLFVBQVUsY0FBYywyQkFBMkIsY0FBYywyQkFBMkIsb0JBQW9CLGdCQUFnQixNQUFNLHdCQUF3QixLQUFLLHNFQUFzRSx5QkFBeUIsaUJBQWlCLGtEQUFrRCxxQkFBcUIsZ0JBQWdCLHNDQUFzQyxLQUFLLFNBQVMsRUFBRSxtQkFBbUIsZ0JBQWdCLHNDQUFzQyxLQUFLLFFBQVEsRUFBRSxtQkFBbUIsaUJBQWlCLHNDQUFzQyxLQUFLLDBCQUEwQixFQUFFLG1CQUFtQixXQUFXLFNBQVMsbzlGQUFvOUYsV0FBVyxxTUFBcU0sR0FBRyxtR0FBbUcsSUFBSSw0UEFBNFAsS0FBSyxpRUFBaUUsU0FBUyxTQUFTLEtBQUssZUFBZSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsU0FBUyx5aENBQXloQyxhQUFhLDY0V0FBNjRXLHNDQUFzQyw2ckJBQTZyQixTQUFTLDJ2QkFBMnZCLFNBQVMsaUJBQWlCLGFBQWEsZ0hBQWdILFNBQVMsaUJBQWlCLGFBQWEsaUtBQWlLLDJEQUEyRCxHQUFHLGdJQUFnSSxNQUFNLE1BQU0sNkRBQTZELGdDQUFnQyxPQUFPLGdHQUFnRyxZQUFZLGtGQUFrRix5REFBeUQsb0ZBQW9GLEVBQUUsMkZBQTJGLE1BQU0sTUFBTSxtREFBbUQsVUFBVSxPQUFPLDhFQUE4RSxjQUFjLFFBQVEsZUFBZSxXQUFXLGlCQUFpQiw2QkFBNkIsa0ZBQWtGLHdCQUF3QixNQUFNLGdJQUFnSSxZQUFZLE1BQU0sbUhBQW1ILDBHQUEwRyxlQUFlLGtCQUFrQix5QkFBeUIsY0FBYyxZQUFZLGdCQUFnQixNQUFNLDZHQUE2Ryx1Q0FBdUMsS0FBSywyQkFBMkIsWUFBWSxnTkFBZ04sNE1BQTRNLFFBQVEsT0FBTyxlQUFlLGlFQUFpRSxVQUFVLDhEQUE4RCxxRUFBcUUsZ0VBQWdFLHNFQUFzRSxrQkFBa0Isa0JBQWtCLHVDQUF1QyxNQUFNLG1FQUFtRSxHQUFHLDJCQUEyQiwrREFBK0QsTUFBTSw2RUFBNkUsK0JBQStCLHlCQUF5QixnQkFBZ0IsY0FBYyx5UUFBeVEsZ0pBQWdKLDZCQUE2QixtREFBbUQseUJBQXlCLDhEQUE4RCxxQkFBcUIsS0FBSyxhQUFhLEVBQUUsOEJBQThCLGlHQUFpRyxpREFBaUQsaUZBQWlGLGdCQUFnQixVQUFVLHVCQUF1QixjQUFjLHlKQUF5SixzREFBc0QsZ0ZBQWdGLE9BQU8saUNBQWlDLE1BQU0sMEVBQXdSO0FBQzV6MkI7Ozs7Ozs7Ozs7Ozs7Ozs7O1VDREE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOzs7OztXQ3pCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsaUNBQWlDLFdBQVc7V0FDNUM7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxzREFBc0Q7V0FDdEQsc0NBQXNDLGlFQUFpRTtXQUN2RztXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7Ozs7O1dDekJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxFQUFFO1dBQ0Y7Ozs7O1dDUkE7V0FDQTtXQUNBO1dBQ0EsOEJBQThCLHVWQUF1VjtXQUNyWDs7Ozs7V0NKQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEdBQUc7V0FDSDtXQUNBO1dBQ0EsQ0FBQzs7Ozs7V0NQRDs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHVCQUF1Qiw0QkFBNEI7V0FDbkQ7V0FDQTtXQUNBO1dBQ0EsaUJBQWlCLG9CQUFvQjtXQUNyQztXQUNBLG1HQUFtRyxZQUFZO1dBQy9HO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsbUVBQW1FLGlDQUFpQztXQUNwRztXQUNBO1dBQ0E7V0FDQTs7Ozs7V0N6Q0E7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztXQ05BOzs7OztXQ0FBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQSxpQ0FBaUM7O1dBRWpDO1dBQ0E7V0FDQTtXQUNBLEtBQUs7V0FDTCxlQUFlO1dBQ2Y7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTs7V0FFQTs7V0FFQTs7V0FFQTs7V0FFQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxNQUFNLHFCQUFxQjtXQUMzQjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7O1dBRUE7V0FDQTtXQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDckZBO0FBQ0E7QUFDd0U7QUFDakM7QUFFcUI7QUFFNUQsTUFBTUcsR0FBK0IsR0FBR0MsSUFDckI7QUFFbkIsSUFBSUMsT0FBZ0MsR0FBRyxJQUFJO0FBMEIzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSUMsaUJBQWlCLEdBQUcsSUFBSTtBQUU1QixlQUFlQyxZQUFZQSxDQUFBLEVBQUc7RUFDNUIsSUFBSUYsT0FBTyxFQUFFLE9BQU9BLE9BQU87RUFFM0JBLE9BQU8sR0FBRyxNQUFNTCwrREFBVyxDQUFDO0lBQzFCO0lBQ0FRLFFBQVEsdUNBQUFDLE1BQUEsQ0FBdUNSLHlEQUFXO0VBQzVELENBQUMsQ0FBQzs7RUFFRjtFQUNBO0VBQ0E7RUFDQVUsTUFBTSxDQUFDQyxNQUFNLENBQUNSLElBQUksQ0FBQzs7RUFFbkI7RUFDQUMsT0FBTyxDQUFDUSxFQUFFLENBQUNDLFNBQVMsQ0FDbEIsOEJBQThCLEVBQzlCWixvRUFBYyxDQUFDYyxVQUFVLEVBQ3pCO0lBQ0VDLFFBQVEsRUFBRTtFQUNaLENBQ0YsQ0FBQztFQUVEWCxpQkFBaUIsR0FBRyxJQUFJO0VBQ3hCWSxXQUFXLENBQUM7SUFBRUMsSUFBSSxFQUFFO0VBQVUsQ0FBQyxDQUFDO0FBQ2xDO0FBRUEsU0FBU0MsWUFBWUEsQ0FBQSxFQUFHO0VBQ3RCLElBQUlmLE9BQU8sRUFBRUEsT0FBTyxHQUFHLElBQUk7RUFDM0IsS0FBS0UsWUFBWSxDQUFDLENBQUM7QUFDckI7QUFFQSxLQUFLQSxZQUFZLENBQUMsQ0FBQztBQUVuQixTQUFTYyxhQUFhQSxDQUFBLEVBQUc7RUFDdkIsSUFBSSxDQUFDaEIsT0FBTyxFQUFFLE1BQU0sSUFBSWlCLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQztFQUNuRDtFQUNBLE1BQU1DLEdBQUcsR0FBR2xCLE9BQU8sQ0FBQ21CLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLEtBQUssQ0FBMkI7RUFFaEUsU0FBU0MsS0FBS0EsQ0FBQSxFQUFxQjtJQUFBLFNBQUFDLElBQUEsR0FBQUMsU0FBQSxDQUFBQyxNQUFBLEVBQWpCQyxJQUFJLE9BQUFDLEtBQUEsQ0FBQUosSUFBQSxHQUFBSyxJQUFBLE1BQUFBLElBQUEsR0FBQUwsSUFBQSxFQUFBSyxJQUFBO01BQUpGLElBQUksQ0FBQUUsSUFBQSxJQUFBSixTQUFBLENBQUFJLElBQUE7SUFBQTtJQUNwQixNQUFNQyxJQUFJLEdBQUdILElBQUksQ0FBQ0ksR0FBRyxDQUFDQyxDQUFDLElBQUlaLEdBQUcsQ0FBQ1ksQ0FBQyxDQUFDLENBQUMsQ0FBQ0MsSUFBSSxDQUFDLEdBQUcsQ0FBQztJQUM1Q2xCLFdBQVcsQ0FBQztNQUFFQyxJQUFJLEVBQUUsT0FBTztNQUFFYztJQUFLLENBQUMsQ0FBQztFQUN0QztFQUVBLFNBQVNJLEtBQUtBLENBQUNKLElBQVksRUFBRTtJQUMzQjtJQUNBO0lBQ0FmLFdBQVcsQ0FBQztNQUFFQyxJQUFJLEVBQUUsT0FBTztNQUFFYztJQUFLLENBQUMsQ0FBQztJQUNwQyxNQUFNSyxPQUFPLEdBQUcsSUFBSUMsY0FBYyxDQUFDLENBQUM7SUFDcENELE9BQU8sQ0FBQ0UsSUFBSSxDQUFDLE1BQU0sRUFBRSwwQkFBMEIsRUFBRSxLQUFLLENBQUM7SUFDdkRGLE9BQU8sQ0FBQ0csSUFBSSxDQUFDLElBQUksQ0FBQzs7SUFFbEI7SUFDQTtJQUNBO0lBQ0EsT0FBT0MsSUFBSSxDQUFDQyxLQUFLLENBQUNMLE9BQU8sQ0FBQ00sWUFBWSxDQUFDO0VBSXpDOztFQUVBO0VBQ0E7RUFDQTtFQUNBOztFQUVBO0VBQ0F2QyxPQUFPLENBQUN3QyxnQkFBZ0IsQ0FBQyxVQUFVLEVBQUU7SUFDbkNuQixLQUFLO0lBQ0xXO0VBQ0YsQ0FBQyxDQUFDO0VBQ0Y7RUFDQTtFQUNBLE1BQU1iLE9BQU8sR0FBR25CLE9BQU8sQ0FBQ21CLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQVk7RUFDeEQ7RUFDQTtFQUNBO0VBQ0FELE9BQU8sQ0FBQ3NCLEdBQUcsQ0FBQyxVQUFVLEVBQUUsVUFBVSxDQUFDO0VBQ25DO0VBQ0E7RUFDQSxNQUFNQyxTQUFTLEdBQUlDLE1BQWMsSUFDL0IzQyxPQUFPLENBQUUwQyxTQUFTLENBQUNDLE1BQU0sRUFBRTtJQUFFeEI7RUFBUSxDQUFDLENBQVk7RUFDcER1QixTQUFTLHdTQVlSLENBQUM7O0VBRUY7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0FBLFNBQVMsaUxBT1IsQ0FBQztFQUNGQSxTQUFTLDBPQUtWLENBQUM7RUFDQTtFQUNBLE1BQU1FLGNBQWMsR0FBR3pCLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLGlCQUFpQixDQUNwQzs7RUFFaEI7RUFDQSxNQUFNeUIsVUFBVSxHQUFHMUIsT0FBTyxDQUFDQyxHQUFHLENBQUMsZ0JBQWdCLENBQTZCO0VBQzVFLE9BQU87SUFBRXNCLFNBQVM7SUFBRUcsVUFBVTtJQUFFMUIsT0FBTztJQUFFeUI7RUFBZSxDQUFDO0FBQzNEO0FBRUE5QyxHQUFHLENBQUNnRCxTQUFTLEdBQUlDLENBQW9ELElBQUs7RUFDeEUsTUFBTTtJQUFFQztFQUFLLENBQUMsR0FBR0QsQ0FBQztFQUNsQixJQUFJQyxJQUFJLENBQUNsQyxJQUFJLEtBQUssUUFBUSxFQUFFO0lBQzFCbUMsbUJBQW1CLENBQUMsQ0FBQztFQUN2QixDQUFDLE1BQU0sSUFBSUQsSUFBSSxDQUFDbEMsSUFBSSxLQUFLLFFBQVEsRUFBRTtJQUNqQ29DLG1CQUFtQixDQUFDRixJQUFJLENBQUM7RUFDM0IsQ0FBQyxNQUFNO0lBQ0xHLGdCQUFnQixDQUFDSCxJQUFJLENBQUM7RUFDeEI7QUFDRixDQUFDOztBQUVEO0FBQ0EsU0FBU0UsbUJBQW1CQSxDQUFBRSxJQUFBLEVBQStCO0VBQUEsSUFBOUI7SUFBRUM7RUFBeUIsQ0FBQyxHQUFBRCxJQUFBO0VBQ3ZEdkMsV0FBVyxDQUFDO0lBQUVDLElBQUksRUFBRSxVQUFVO0lBQUVjLElBQUksRUFBRXlCO0VBQU0sQ0FBQyxDQUFDO0FBQ2hEO0FBRUEsU0FBU0osbUJBQW1CQSxDQUFBLEVBQUc7RUFDN0JoRCxpQkFBaUIsR0FBRyxLQUFLO0FBQzNCO0FBRUEsU0FBU2tELGdCQUFnQkEsQ0FBQ0gsSUFBNEIsRUFBRTtFQUN0RCxJQUFJO0lBQ0YsSUFBSS9DLGlCQUFpQixFQUFFO0lBQ3ZCLE1BQU1xRCxJQUFJLEdBQUcsQ0FBQ04sSUFBSSxDQUFDTSxJQUFJLENBQUNDLFFBQVEsSUFBSSxFQUFFLEVBQUVDLEtBQUssQ0FBQyxDQUFDO0lBQy9DO0lBQ0EzQyxXQUFXLENBQUM7TUFBRUMsSUFBSSxFQUFFO0lBQVEsQ0FBQyxDQUFDO0lBRTlCLE1BQU07TUFBRTRCLFNBQVM7TUFBRUcsVUFBVTtNQUFFMUIsT0FBTztNQUFFeUI7SUFBZSxDQUFDLEdBQUc1QixhQUFhLENBQUMsQ0FBQztJQUMxRTtJQUNBLElBQUk7TUFDRjBCLFNBQVMsQ0FBQ1ksSUFBSSxDQUFDO0lBQ2pCLENBQUMsQ0FBQyxPQUFPUCxDQUFDLEVBQUU7TUFDVixNQUFNVSxHQUFHLEdBQUdWLENBQWdCO01BQzVCO01BQ0FILGNBQWMsQ0FBQyxDQUFDO01BQ2hCO01BQ0FjLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDRixHQUFHLENBQUM7TUFDbEIsTUFBTUcsT0FBTyxHQUFHZixVQUFVLENBQUMsQ0FBQztNQUM1QjtNQUNBO01BQ0E7TUFDQSxJQUFJWSxHQUFHLENBQUMzQyxJQUFJLEtBQUssbUJBQW1CLElBQUk4QyxPQUFPLEVBQUU7UUFDL0M7UUFDQTtRQUNBO1FBQ0EzRCxpQkFBaUIsR0FBRyxJQUFJO1FBQ3hCO1FBQ0FZLFdBQVcsQ0FBQztVQUFFQyxJQUFJLEVBQUUsU0FBUztVQUFFYyxJQUFJLEVBQUVpQixVQUFVLENBQUM7UUFBRSxDQUFDLENBQUM7TUFDdEQ7SUFDRixDQUFDLFNBQVM7TUFDUkEsVUFBVSxDQUFDZ0IsT0FBTyxDQUFDLENBQUM7TUFDcEJqQixjQUFjLENBQUNpQixPQUFPLENBQUMsQ0FBQztNQUN4QjFDLE9BQU8sQ0FBQzBDLE9BQU8sQ0FBQyxDQUFDO0lBQ25CO0VBQ0YsQ0FBQyxDQUFDLE9BQU9kLENBQUMsRUFBRTtJQUNWO0lBQ0E7SUFDQVcsT0FBTyxDQUFDQyxLQUFLLENBQUNaLENBQUMsQ0FBQztJQUNoQixLQUFLaEMsWUFBWSxDQUFDLENBQUM7RUFDckI7QUFDRixDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGZyZWVjb2RlY2FtcC9icm93c2VyLXNjcmlwdHMvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3Byb2Nlc3NAMC4xMS4xMC9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovL0BmcmVlY29kZWNhbXAvYnJvd3Nlci1zY3JpcHRzLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9weW9kaWRlQDAuMjMuMy9ub2RlX21vZHVsZXMvcHlvZGlkZS9weW9kaWRlLmpzIiwid2VicGFjazovL0BmcmVlY29kZWNhbXAvYnJvd3Nlci1zY3JpcHRzLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AZnJlZWNvZGVjYW1wK2N1cnJpY3VsdW0taGVscGVyc0AzLjQuMC9ub2RlX21vZHVsZXMvQGZyZWVjb2RlY2FtcC9jdXJyaWN1bHVtLWhlbHBlcnMvZGlzdC9pbmRleC5tanMiLCJ3ZWJwYWNrOi8vQGZyZWVjb2RlY2FtcC9icm93c2VyLXNjcmlwdHMvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vQGZyZWVjb2RlY2FtcC9icm93c2VyLXNjcmlwdHMvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vQGZyZWVjb2RlY2FtcC9icm93c2VyLXNjcmlwdHMvd2VicGFjay9ydW50aW1lL2NyZWF0ZSBmYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vQGZyZWVjb2RlY2FtcC9icm93c2VyLXNjcmlwdHMvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL0BmcmVlY29kZWNhbXAvYnJvd3Nlci1zY3JpcHRzL3dlYnBhY2svcnVudGltZS9lbnN1cmUgY2h1bmsiLCJ3ZWJwYWNrOi8vQGZyZWVjb2RlY2FtcC9icm93c2VyLXNjcmlwdHMvd2VicGFjay9ydW50aW1lL2dldCBqYXZhc2NyaXB0IGNodW5rIGZpbGVuYW1lIiwid2VicGFjazovL0BmcmVlY29kZWNhbXAvYnJvd3Nlci1zY3JpcHRzL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vQGZyZWVjb2RlY2FtcC9icm93c2VyLXNjcmlwdHMvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9AZnJlZWNvZGVjYW1wL2Jyb3dzZXItc2NyaXB0cy93ZWJwYWNrL3J1bnRpbWUvbG9hZCBzY3JpcHQiLCJ3ZWJwYWNrOi8vQGZyZWVjb2RlY2FtcC9icm93c2VyLXNjcmlwdHMvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9AZnJlZWNvZGVjYW1wL2Jyb3dzZXItc2NyaXB0cy93ZWJwYWNrL3J1bnRpbWUvcHVibGljUGF0aCIsIndlYnBhY2s6Ly9AZnJlZWNvZGVjYW1wL2Jyb3dzZXItc2NyaXB0cy93ZWJwYWNrL3J1bnRpbWUvanNvbnAgY2h1bmsgbG9hZGluZyIsIndlYnBhY2s6Ly9AZnJlZWNvZGVjYW1wL2Jyb3dzZXItc2NyaXB0cy8uL3B5dGhvbi13b3JrZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIiFmdW5jdGlvbihnbG9iYWwsZmFjdG9yeSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/ZmFjdG9yeShleHBvcnRzKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImV4cG9ydHNcIl0sZmFjdG9yeSk6ZmFjdG9yeSgoZ2xvYmFsPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6Z2xvYmFsfHxzZWxmKS5sb2FkUHlvZGlkZT17fSl9KHRoaXMsKGZ1bmN0aW9uKGV4cG9ydHMpe1widXNlIHN0cmljdFwiO1widW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJnNlbGY7dmFyIGVycm9yU3RhY2tQYXJzZXI9e2V4cG9ydHM6e319LHN0YWNrZnJhbWU9e2V4cG9ydHM6e319OyFmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBfaXNOdW1iZXIobil7cmV0dXJuIWlzTmFOKHBhcnNlRmxvYXQobikpJiZpc0Zpbml0ZShuKX1mdW5jdGlvbiBfY2FwaXRhbGl6ZShzdHIpe3JldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrc3RyLnN1YnN0cmluZygxKX1mdW5jdGlvbiBfZ2V0dGVyKHApe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0aGlzW3BdfX12YXIgYm9vbGVhblByb3BzPVtcImlzQ29uc3RydWN0b3JcIixcImlzRXZhbFwiLFwiaXNOYXRpdmVcIixcImlzVG9wbGV2ZWxcIl0sbnVtZXJpY1Byb3BzPVtcImNvbHVtbk51bWJlclwiLFwibGluZU51bWJlclwiXSxzdHJpbmdQcm9wcz1bXCJmaWxlTmFtZVwiLFwiZnVuY3Rpb25OYW1lXCIsXCJzb3VyY2VcIl0sYXJyYXlQcm9wcz1bXCJhcmdzXCJdLG9iamVjdFByb3BzPVtcImV2YWxPcmlnaW5cIl0scHJvcHM9Ym9vbGVhblByb3BzLmNvbmNhdChudW1lcmljUHJvcHMsc3RyaW5nUHJvcHMsYXJyYXlQcm9wcyxvYmplY3RQcm9wcyk7ZnVuY3Rpb24gU3RhY2tGcmFtZShvYmope2lmKG9iailmb3IodmFyIGk9MDtpPHByb3BzLmxlbmd0aDtpKyspdm9pZCAwIT09b2JqW3Byb3BzW2ldXSYmdGhpc1tcInNldFwiK19jYXBpdGFsaXplKHByb3BzW2ldKV0ob2JqW3Byb3BzW2ldXSl9U3RhY2tGcmFtZS5wcm90b3R5cGU9e2dldEFyZ3M6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hcmdzfSxzZXRBcmdzOmZ1bmN0aW9uKHYpe2lmKFwiW29iamVjdCBBcnJheV1cIiE9PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJncyBtdXN0IGJlIGFuIEFycmF5XCIpO3RoaXMuYXJncz12fSxnZXRFdmFsT3JpZ2luOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXZhbE9yaWdpbn0sc2V0RXZhbE9yaWdpbjpmdW5jdGlvbih2KXtpZih2IGluc3RhbmNlb2YgU3RhY2tGcmFtZSl0aGlzLmV2YWxPcmlnaW49djtlbHNle2lmKCEodiBpbnN0YW5jZW9mIE9iamVjdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV2YWwgT3JpZ2luIG11c3QgYmUgYW4gT2JqZWN0IG9yIFN0YWNrRnJhbWVcIik7dGhpcy5ldmFsT3JpZ2luPW5ldyBTdGFja0ZyYW1lKHYpfX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXt2YXIgZmlsZU5hbWU9dGhpcy5nZXRGaWxlTmFtZSgpfHxcIlwiLGxpbmVOdW1iZXI9dGhpcy5nZXRMaW5lTnVtYmVyKCl8fFwiXCIsY29sdW1uTnVtYmVyPXRoaXMuZ2V0Q29sdW1uTnVtYmVyKCl8fFwiXCIsZnVuY3Rpb25OYW1lPXRoaXMuZ2V0RnVuY3Rpb25OYW1lKCl8fFwiXCI7cmV0dXJuIHRoaXMuZ2V0SXNFdmFsKCk/ZmlsZU5hbWU/XCJbZXZhbF0gKFwiK2ZpbGVOYW1lK1wiOlwiK2xpbmVOdW1iZXIrXCI6XCIrY29sdW1uTnVtYmVyK1wiKVwiOlwiW2V2YWxdOlwiK2xpbmVOdW1iZXIrXCI6XCIrY29sdW1uTnVtYmVyOmZ1bmN0aW9uTmFtZT9mdW5jdGlvbk5hbWUrXCIgKFwiK2ZpbGVOYW1lK1wiOlwiK2xpbmVOdW1iZXIrXCI6XCIrY29sdW1uTnVtYmVyK1wiKVwiOmZpbGVOYW1lK1wiOlwiK2xpbmVOdW1iZXIrXCI6XCIrY29sdW1uTnVtYmVyfX0sU3RhY2tGcmFtZS5mcm9tU3RyaW5nPWZ1bmN0aW9uKHN0cil7dmFyIGFyZ3NTdGFydEluZGV4PXN0ci5pbmRleE9mKFwiKFwiKSxhcmdzRW5kSW5kZXg9c3RyLmxhc3RJbmRleE9mKFwiKVwiKSxmdW5jdGlvbk5hbWU9c3RyLnN1YnN0cmluZygwLGFyZ3NTdGFydEluZGV4KSxhcmdzPXN0ci5zdWJzdHJpbmcoYXJnc1N0YXJ0SW5kZXgrMSxhcmdzRW5kSW5kZXgpLnNwbGl0KFwiLFwiKSxsb2NhdGlvblN0cmluZz1zdHIuc3Vic3RyaW5nKGFyZ3NFbmRJbmRleCsxKTtpZigwPT09bG9jYXRpb25TdHJpbmcuaW5kZXhPZihcIkBcIikpdmFyIHBhcnRzPS9AKC4rPykoPzo6KFxcZCspKT8oPzo6KFxcZCspKT8kLy5leGVjKGxvY2F0aW9uU3RyaW5nLFwiXCIpLGZpbGVOYW1lPXBhcnRzWzFdLGxpbmVOdW1iZXI9cGFydHNbMl0sY29sdW1uTnVtYmVyPXBhcnRzWzNdO3JldHVybiBuZXcgU3RhY2tGcmFtZSh7ZnVuY3Rpb25OYW1lOmZ1bmN0aW9uTmFtZSxhcmdzOmFyZ3N8fHZvaWQgMCxmaWxlTmFtZTpmaWxlTmFtZSxsaW5lTnVtYmVyOmxpbmVOdW1iZXJ8fHZvaWQgMCxjb2x1bW5OdW1iZXI6Y29sdW1uTnVtYmVyfHx2b2lkIDB9KX07Zm9yKHZhciBpPTA7aTxib29sZWFuUHJvcHMubGVuZ3RoO2krKylTdGFja0ZyYW1lLnByb3RvdHlwZVtcImdldFwiK19jYXBpdGFsaXplKGJvb2xlYW5Qcm9wc1tpXSldPV9nZXR0ZXIoYm9vbGVhblByb3BzW2ldKSxTdGFja0ZyYW1lLnByb3RvdHlwZVtcInNldFwiK19jYXBpdGFsaXplKGJvb2xlYW5Qcm9wc1tpXSldPWZ1bmN0aW9uKHApe3JldHVybiBmdW5jdGlvbih2KXt0aGlzW3BdPUJvb2xlYW4odil9fShib29sZWFuUHJvcHNbaV0pO2Zvcih2YXIgaj0wO2o8bnVtZXJpY1Byb3BzLmxlbmd0aDtqKyspU3RhY2tGcmFtZS5wcm90b3R5cGVbXCJnZXRcIitfY2FwaXRhbGl6ZShudW1lcmljUHJvcHNbal0pXT1fZ2V0dGVyKG51bWVyaWNQcm9wc1tqXSksU3RhY2tGcmFtZS5wcm90b3R5cGVbXCJzZXRcIitfY2FwaXRhbGl6ZShudW1lcmljUHJvcHNbal0pXT1mdW5jdGlvbihwKXtyZXR1cm4gZnVuY3Rpb24odil7aWYoIV9pc051bWJlcih2KSl0aHJvdyBuZXcgVHlwZUVycm9yKHArXCIgbXVzdCBiZSBhIE51bWJlclwiKTt0aGlzW3BdPU51bWJlcih2KX19KG51bWVyaWNQcm9wc1tqXSk7Zm9yKHZhciBrPTA7azxzdHJpbmdQcm9wcy5sZW5ndGg7aysrKVN0YWNrRnJhbWUucHJvdG90eXBlW1wiZ2V0XCIrX2NhcGl0YWxpemUoc3RyaW5nUHJvcHNba10pXT1fZ2V0dGVyKHN0cmluZ1Byb3BzW2tdKSxTdGFja0ZyYW1lLnByb3RvdHlwZVtcInNldFwiK19jYXBpdGFsaXplKHN0cmluZ1Byb3BzW2tdKV09ZnVuY3Rpb24ocCl7cmV0dXJuIGZ1bmN0aW9uKHYpe3RoaXNbcF09U3RyaW5nKHYpfX0oc3RyaW5nUHJvcHNba10pO3JldHVybiBTdGFja0ZyYW1lfSgpfShzdGFja2ZyYW1lKSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyl7dmFyIFN0YWNrRnJhbWUsRklSRUZPWF9TQUZBUklfU1RBQ0tfUkVHRVhQLENIUk9NRV9JRV9TVEFDS19SRUdFWFAsU0FGQVJJX05BVElWRV9DT0RFX1JFR0VYUDttb2R1bGUuZXhwb3J0cz0oU3RhY2tGcmFtZT1zdGFja2ZyYW1lLmV4cG9ydHMsRklSRUZPWF9TQUZBUklfU1RBQ0tfUkVHRVhQPS8oXnxAKVxcUys6XFxkKy8sQ0hST01FX0lFX1NUQUNLX1JFR0VYUD0vXlxccyphdCAuKihcXFMrOlxcZCt8XFwobmF0aXZlXFwpKS9tLFNBRkFSSV9OQVRJVkVfQ09ERV9SRUdFWFA9L14oZXZhbEApPyhcXFtuYXRpdmUgY29kZV0pPyQvLHtwYXJzZTpmdW5jdGlvbihlcnJvcil7aWYodm9pZCAwIT09ZXJyb3Iuc3RhY2t0cmFjZXx8dm9pZCAwIT09ZXJyb3JbXCJvcGVyYSNzb3VyY2Vsb2NcIl0pcmV0dXJuIHRoaXMucGFyc2VPcGVyYShlcnJvcik7aWYoZXJyb3Iuc3RhY2smJmVycm9yLnN0YWNrLm1hdGNoKENIUk9NRV9JRV9TVEFDS19SRUdFWFApKXJldHVybiB0aGlzLnBhcnNlVjhPcklFKGVycm9yKTtpZihlcnJvci5zdGFjaylyZXR1cm4gdGhpcy5wYXJzZUZGT3JTYWZhcmkoZXJyb3IpO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBwYXJzZSBnaXZlbiBFcnJvciBvYmplY3RcIil9LGV4dHJhY3RMb2NhdGlvbjpmdW5jdGlvbih1cmxMaWtlKXtpZigtMT09PXVybExpa2UuaW5kZXhPZihcIjpcIikpcmV0dXJuW3VybExpa2VdO3ZhciBwYXJ0cz0vKC4rPykoPzo6KFxcZCspKT8oPzo6KFxcZCspKT8kLy5leGVjKHVybExpa2UucmVwbGFjZSgvWygpXS9nLFwiXCIpKTtyZXR1cm5bcGFydHNbMV0scGFydHNbMl18fHZvaWQgMCxwYXJ0c1szXXx8dm9pZCAwXX0scGFyc2VWOE9ySUU6ZnVuY3Rpb24oZXJyb3Ipe3JldHVybiBlcnJvci5zdGFjay5zcGxpdChcIlxcblwiKS5maWx0ZXIoKGZ1bmN0aW9uKGxpbmUpe3JldHVybiEhbGluZS5tYXRjaChDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQKX0pLHRoaXMpLm1hcCgoZnVuY3Rpb24obGluZSl7bGluZS5pbmRleE9mKFwiKGV2YWwgXCIpPi0xJiYobGluZT1saW5lLnJlcGxhY2UoL2V2YWwgY29kZS9nLFwiZXZhbFwiKS5yZXBsYWNlKC8oXFwoZXZhbCBhdCBbXigpXSopfCgsLiokKS9nLFwiXCIpKTt2YXIgc2FuaXRpemVkTGluZT1saW5lLnJlcGxhY2UoL15cXHMrLyxcIlwiKS5yZXBsYWNlKC9cXChldmFsIGNvZGUvZyxcIihcIikucmVwbGFjZSgvXi4qP1xccysvLFwiXCIpLGxvY2F0aW9uPXNhbml0aXplZExpbmUubWF0Y2goLyAoXFwoLitcXCkkKS8pO3Nhbml0aXplZExpbmU9bG9jYXRpb24/c2FuaXRpemVkTGluZS5yZXBsYWNlKGxvY2F0aW9uWzBdLFwiXCIpOnNhbml0aXplZExpbmU7dmFyIGxvY2F0aW9uUGFydHM9dGhpcy5leHRyYWN0TG9jYXRpb24obG9jYXRpb24/bG9jYXRpb25bMV06c2FuaXRpemVkTGluZSksZnVuY3Rpb25OYW1lPWxvY2F0aW9uJiZzYW5pdGl6ZWRMaW5lfHx2b2lkIDAsZmlsZU5hbWU9W1wiZXZhbFwiLFwiPGFub255bW91cz5cIl0uaW5kZXhPZihsb2NhdGlvblBhcnRzWzBdKT4tMT92b2lkIDA6bG9jYXRpb25QYXJ0c1swXTtyZXR1cm4gbmV3IFN0YWNrRnJhbWUoe2Z1bmN0aW9uTmFtZTpmdW5jdGlvbk5hbWUsZmlsZU5hbWU6ZmlsZU5hbWUsbGluZU51bWJlcjpsb2NhdGlvblBhcnRzWzFdLGNvbHVtbk51bWJlcjpsb2NhdGlvblBhcnRzWzJdLHNvdXJjZTpsaW5lfSl9KSx0aGlzKX0scGFyc2VGRk9yU2FmYXJpOmZ1bmN0aW9uKGVycm9yKXtyZXR1cm4gZXJyb3Iuc3RhY2suc3BsaXQoXCJcXG5cIikuZmlsdGVyKChmdW5jdGlvbihsaW5lKXtyZXR1cm4hbGluZS5tYXRjaChTQUZBUklfTkFUSVZFX0NPREVfUkVHRVhQKX0pLHRoaXMpLm1hcCgoZnVuY3Rpb24obGluZSl7aWYobGluZS5pbmRleE9mKFwiID4gZXZhbFwiKT4tMSYmKGxpbmU9bGluZS5yZXBsYWNlKC8gbGluZSAoXFxkKykoPzogPiBldmFsIGxpbmUgXFxkKykqID4gZXZhbDpcXGQrOlxcZCsvZyxcIjokMVwiKSksLTE9PT1saW5lLmluZGV4T2YoXCJAXCIpJiYtMT09PWxpbmUuaW5kZXhPZihcIjpcIikpcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtmdW5jdGlvbk5hbWU6bGluZX0pO3ZhciBmdW5jdGlvbk5hbWVSZWdleD0vKCguKlwiLitcIlteQF0qKT9bXkBdKikoPzpAKS8sbWF0Y2hlcz1saW5lLm1hdGNoKGZ1bmN0aW9uTmFtZVJlZ2V4KSxmdW5jdGlvbk5hbWU9bWF0Y2hlcyYmbWF0Y2hlc1sxXT9tYXRjaGVzWzFdOnZvaWQgMCxsb2NhdGlvblBhcnRzPXRoaXMuZXh0cmFjdExvY2F0aW9uKGxpbmUucmVwbGFjZShmdW5jdGlvbk5hbWVSZWdleCxcIlwiKSk7cmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtmdW5jdGlvbk5hbWU6ZnVuY3Rpb25OYW1lLGZpbGVOYW1lOmxvY2F0aW9uUGFydHNbMF0sbGluZU51bWJlcjpsb2NhdGlvblBhcnRzWzFdLGNvbHVtbk51bWJlcjpsb2NhdGlvblBhcnRzWzJdLHNvdXJjZTpsaW5lfSl9KSx0aGlzKX0scGFyc2VPcGVyYTpmdW5jdGlvbihlKXtyZXR1cm4hZS5zdGFja3RyYWNlfHxlLm1lc3NhZ2UuaW5kZXhPZihcIlxcblwiKT4tMSYmZS5tZXNzYWdlLnNwbGl0KFwiXFxuXCIpLmxlbmd0aD5lLnN0YWNrdHJhY2Uuc3BsaXQoXCJcXG5cIikubGVuZ3RoP3RoaXMucGFyc2VPcGVyYTkoZSk6ZS5zdGFjaz90aGlzLnBhcnNlT3BlcmExMShlKTp0aGlzLnBhcnNlT3BlcmExMChlKX0scGFyc2VPcGVyYTk6ZnVuY3Rpb24oZSl7Zm9yKHZhciBsaW5lUkU9L0xpbmUgKFxcZCspLipzY3JpcHQgKD86aW4gKT8oXFxTKykvaSxsaW5lcz1lLm1lc3NhZ2Uuc3BsaXQoXCJcXG5cIikscmVzdWx0PVtdLGk9MixsZW49bGluZXMubGVuZ3RoO2k8bGVuO2krPTIpe3ZhciBtYXRjaD1saW5lUkUuZXhlYyhsaW5lc1tpXSk7bWF0Y2gmJnJlc3VsdC5wdXNoKG5ldyBTdGFja0ZyYW1lKHtmaWxlTmFtZTptYXRjaFsyXSxsaW5lTnVtYmVyOm1hdGNoWzFdLHNvdXJjZTpsaW5lc1tpXX0pKX1yZXR1cm4gcmVzdWx0fSxwYXJzZU9wZXJhMTA6ZnVuY3Rpb24oZSl7Zm9yKHZhciBsaW5lUkU9L0xpbmUgKFxcZCspLipzY3JpcHQgKD86aW4gKT8oXFxTKykoPzo6IEluIGZ1bmN0aW9uIChcXFMrKSk/JC9pLGxpbmVzPWUuc3RhY2t0cmFjZS5zcGxpdChcIlxcblwiKSxyZXN1bHQ9W10saT0wLGxlbj1saW5lcy5sZW5ndGg7aTxsZW47aSs9Mil7dmFyIG1hdGNoPWxpbmVSRS5leGVjKGxpbmVzW2ldKTttYXRjaCYmcmVzdWx0LnB1c2gobmV3IFN0YWNrRnJhbWUoe2Z1bmN0aW9uTmFtZTptYXRjaFszXXx8dm9pZCAwLGZpbGVOYW1lOm1hdGNoWzJdLGxpbmVOdW1iZXI6bWF0Y2hbMV0sc291cmNlOmxpbmVzW2ldfSkpfXJldHVybiByZXN1bHR9LHBhcnNlT3BlcmExMTpmdW5jdGlvbihlcnJvcil7cmV0dXJuIGVycm9yLnN0YWNrLnNwbGl0KFwiXFxuXCIpLmZpbHRlcigoZnVuY3Rpb24obGluZSl7cmV0dXJuISFsaW5lLm1hdGNoKEZJUkVGT1hfU0FGQVJJX1NUQUNLX1JFR0VYUCkmJiFsaW5lLm1hdGNoKC9eRXJyb3IgY3JlYXRlZCBhdC8pfSksdGhpcykubWFwKChmdW5jdGlvbihsaW5lKXt2YXIgYXJnc1Jhdyx0b2tlbnM9bGluZS5zcGxpdChcIkBcIiksbG9jYXRpb25QYXJ0cz10aGlzLmV4dHJhY3RMb2NhdGlvbih0b2tlbnMucG9wKCkpLGZ1bmN0aW9uQ2FsbD10b2tlbnMuc2hpZnQoKXx8XCJcIixmdW5jdGlvbk5hbWU9ZnVuY3Rpb25DYWxsLnJlcGxhY2UoLzxhbm9ueW1vdXMgZnVuY3Rpb24oOiAoXFx3KykpPz4vLFwiJDJcIikucmVwbGFjZSgvXFwoW14pXSpcXCkvZyxcIlwiKXx8dm9pZCAwO2Z1bmN0aW9uQ2FsbC5tYXRjaCgvXFwoKFteKV0qKVxcKS8pJiYoYXJnc1Jhdz1mdW5jdGlvbkNhbGwucmVwbGFjZSgvXlteKF0rXFwoKFteKV0qKVxcKSQvLFwiJDFcIikpO3ZhciBhcmdzPXZvaWQgMD09PWFyZ3NSYXd8fFwiW2FyZ3VtZW50cyBub3QgYXZhaWxhYmxlXVwiPT09YXJnc1Jhdz92b2lkIDA6YXJnc1Jhdy5zcGxpdChcIixcIik7cmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtmdW5jdGlvbk5hbWU6ZnVuY3Rpb25OYW1lLGFyZ3M6YXJncyxmaWxlTmFtZTpsb2NhdGlvblBhcnRzWzBdLGxpbmVOdW1iZXI6bG9jYXRpb25QYXJ0c1sxXSxjb2x1bW5OdW1iZXI6bG9jYXRpb25QYXJ0c1syXSxzb3VyY2U6bGluZX0pfSksdGhpcyl9fSl9KGVycm9yU3RhY2tQYXJzZXIpO3ZhciBFcnJvclN0YWNrUGFyc2VyPWVycm9yU3RhY2tQYXJzZXIuZXhwb3J0cztjb25zdCBJTl9OT0RFPVwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzJiZcIm9iamVjdFwiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyYmXCJzdHJpbmdcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSYmdm9pZCAwPT09cHJvY2Vzcy5icm93c2VyO2xldCBub2RlVXJsTW9kLG5vZGVGZXRjaCxub2RlUGF0aCxub2RlVm1Nb2Qsbm9kZUZzUHJvbWlzZXNNb2QscmVzb2x2ZVBhdGgscGF0aFNlcCxsb2FkQmluYXJ5RmlsZSxsb2FkU2NyaXB0O2lmKHJlc29sdmVQYXRoPUlOX05PREU/ZnVuY3Rpb24ocGF0aCxiYXNlKXtyZXR1cm4gbm9kZVBhdGgucmVzb2x2ZShiYXNlfHxcIi5cIixwYXRoKX06ZnVuY3Rpb24ocGF0aCxiYXNlKXtyZXR1cm4gdm9pZCAwPT09YmFzZSYmKGJhc2U9bG9jYXRpb24pLG5ldyBVUkwocGF0aCxiYXNlKS50b1N0cmluZygpfSxJTl9OT0RFfHwocGF0aFNlcD1cIi9cIiksbG9hZEJpbmFyeUZpbGU9SU5fTk9ERT9hc3luYyBmdW5jdGlvbihwYXRoLF9maWxlX3N1Yl9yZXNvdXJjZV9oYXNoKXtpZihwYXRoLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpJiYocGF0aD1wYXRoLnNsaWNlKFwiZmlsZTovL1wiLmxlbmd0aCkpLHBhdGguaW5jbHVkZXMoXCI6Ly9cIikpe2xldCByZXNwb25zZT1hd2FpdCBub2RlRmV0Y2gocGF0aCk7aWYoIXJlc3BvbnNlLm9rKXRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgJyR7cGF0aH0nOiByZXF1ZXN0IGZhaWxlZC5gKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSl9e2NvbnN0IGRhdGE9YXdhaXQgbm9kZUZzUHJvbWlzZXNNb2QucmVhZEZpbGUocGF0aCk7cmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLGRhdGEuYnl0ZU9mZnNldCxkYXRhLmJ5dGVMZW5ndGgpfX06YXN5bmMgZnVuY3Rpb24ocGF0aCxzdWJSZXNvdXJjZUhhc2gpe2NvbnN0IHVybD1uZXcgVVJMKHBhdGgsbG9jYXRpb24pO2xldCBvcHRpb25zPXN1YlJlc291cmNlSGFzaD97aW50ZWdyaXR5OnN1YlJlc291cmNlSGFzaH06e30scmVzcG9uc2U9YXdhaXQgZmV0Y2godXJsLG9wdGlvbnMpO2lmKCFyZXNwb25zZS5vayl0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkICcke3VybH0nOiByZXF1ZXN0IGZhaWxlZC5gKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSl9LGdsb2JhbFRoaXMuZG9jdW1lbnQpbG9hZFNjcmlwdD1hc3luYyB1cmw9PmF3YWl0IGltcG9ydCgvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovdXJsKTtlbHNlIGlmKGdsb2JhbFRoaXMuaW1wb3J0U2NyaXB0cylsb2FkU2NyaXB0PWFzeW5jIHVybD0+e3RyeXtnbG9iYWxUaGlzLmltcG9ydFNjcmlwdHModXJsKX1jYXRjaChlKXtpZighKGUgaW5zdGFuY2VvZiBUeXBlRXJyb3IpKXRocm93IGU7YXdhaXQgaW1wb3J0KC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi91cmwpfX07ZWxzZXtpZighSU5fTk9ERSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZGV0ZXJtaW5lIHJ1bnRpbWUgZW52aXJvbm1lbnRcIik7bG9hZFNjcmlwdD1hc3luYyBmdW5jdGlvbih1cmwpe3VybC5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSYmKHVybD11cmwuc2xpY2UoXCJmaWxlOi8vXCIubGVuZ3RoKSk7dXJsLmluY2x1ZGVzKFwiOi8vXCIpP25vZGVWbU1vZC5ydW5JblRoaXNDb250ZXh0KGF3YWl0KGF3YWl0IG5vZGVGZXRjaCh1cmwpKS50ZXh0KCkpOmF3YWl0IGltcG9ydCgvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovbm9kZVVybE1vZC5wYXRoVG9GaWxlVVJMKHVybCkuaHJlZil9fWZ1bmN0aW9uIF9fdmFsdWVzKG8pe3ZhciBzPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yLG09cyYmb1tzXSxpPTA7aWYobSlyZXR1cm4gbS5jYWxsKG8pO2lmKG8mJlwibnVtYmVyXCI9PXR5cGVvZiBvLmxlbmd0aClyZXR1cm57bmV4dDpmdW5jdGlvbigpe3JldHVybiBvJiZpPj1vLmxlbmd0aCYmKG89dm9pZCAwKSx7dmFsdWU6byYmb1tpKytdLGRvbmU6IW99fX07dGhyb3cgbmV3IFR5cGVFcnJvcihzP1wiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIjpcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIil9ZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKXtpZighU3ltYm9sLmFzeW5jSXRlcmF0b3IpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTt2YXIgaSxtPW9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdO3JldHVybiBtP20uY2FsbChvKToobz1fX3ZhbHVlcyhvKSxpPXt9LHZlcmIoXCJuZXh0XCIpLHZlcmIoXCJ0aHJvd1wiKSx2ZXJiKFwicmV0dXJuXCIpLGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LGkpO2Z1bmN0aW9uIHZlcmIobil7aVtuXT1vW25dJiZmdW5jdGlvbih2KXtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KXsoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3QsZCx2KXtQcm9taXNlLnJlc29sdmUodikudGhlbigoZnVuY3Rpb24odil7cmVzb2x2ZSh7dmFsdWU6dixkb25lOmR9KX0pLHJlamVjdCl9KShyZXNvbHZlLHJlamVjdCwodj1vW25dKHYpKS5kb25lLHYudmFsdWUpfSkpfX19Y29uc3QgZ2V0RnNIYW5kbGVzPWFzeW5jIGRpckhhbmRsZT0+e2NvbnN0IGhhbmRsZXM9W107YXdhaXQgYXN5bmMgZnVuY3Rpb24gY29sbGVjdChjdXJEaXJIYW5kbGUpe3ZhciBlXzEsX2E7dHJ5e2Zvcih2YXIgX2MsX2I9X19hc3luY1ZhbHVlcyhjdXJEaXJIYW5kbGUudmFsdWVzKCkpOyEoX2M9YXdhaXQgX2IubmV4dCgpKS5kb25lOyl7Y29uc3QgZW50cnk9X2MudmFsdWU7aGFuZGxlcy5wdXNoKGVudHJ5KSxcImRpcmVjdG9yeVwiPT09ZW50cnkua2luZCYmYXdhaXQgY29sbGVjdChlbnRyeSl9fWNhdGNoKGVfMV8xKXtlXzE9e2Vycm9yOmVfMV8xfX1maW5hbGx5e3RyeXtfYyYmIV9jLmRvbmUmJihfYT1fYi5yZXR1cm4pJiZhd2FpdCBfYS5jYWxsKF9iKX1maW5hbGx5e2lmKGVfMSl0aHJvdyBlXzEuZXJyb3J9fX0oZGlySGFuZGxlKTtjb25zdCByZXN1bHQ9bmV3IE1hcDtyZXN1bHQuc2V0KFwiLlwiLGRpckhhbmRsZSk7Zm9yKGNvbnN0IGhhbmRsZSBvZiBoYW5kbGVzKXtjb25zdCByZWxhdGl2ZVBhdGg9KGF3YWl0IGRpckhhbmRsZS5yZXNvbHZlKGhhbmRsZSkpLmpvaW4oXCIvXCIpO3Jlc3VsdC5zZXQocmVsYXRpdmVQYXRoLGhhbmRsZSl9cmV0dXJuIHJlc3VsdH07ZnVuY3Rpb24gaW5pdGlhbGl6ZUZpbGVTeXN0ZW0oTW9kdWxlLGNvbmZpZyl7bGV0IHN0ZExpYlVSTDtzdGRMaWJVUkw9bnVsbCE9Y29uZmlnLnN0ZExpYlVSTD9jb25maWcuc3RkTGliVVJMOmNvbmZpZy5pbmRleFVSTCtcInB5dGhvbl9zdGRsaWIuemlwXCIsZnVuY3Rpb24oTW9kdWxlLHN0ZGxpYlVSTCl7Y29uc3Qgc3RkbGliUHJvbWlzZT1sb2FkQmluYXJ5RmlsZShzdGRsaWJVUkwpO01vZHVsZS5wcmVSdW4ucHVzaCgoKCk9Pntjb25zdCBweW1ham9yPU1vZHVsZS5fcHlfdmVyc2lvbl9tYWpvcigpLHB5bWlub3I9TW9kdWxlLl9weV92ZXJzaW9uX21pbm9yKCk7TW9kdWxlLkZTLm1rZGlyVHJlZShcIi9saWJcIiksTW9kdWxlLkZTLm1rZGlyVHJlZShgL2xpYi9weXRob24ke3B5bWFqb3J9LiR7cHltaW5vcn0vc2l0ZS1wYWNrYWdlc2ApLE1vZHVsZS5hZGRSdW5EZXBlbmRlbmN5KFwiaW5zdGFsbC1zdGRsaWJcIiksc3RkbGliUHJvbWlzZS50aGVuKChzdGRsaWI9PntNb2R1bGUuRlMud3JpdGVGaWxlKGAvbGliL3B5dGhvbiR7cHltYWpvcn0ke3B5bWlub3J9LnppcGAsc3RkbGliKX0pKS5jYXRjaCgoZT0+e2NvbnNvbGUuZXJyb3IoXCJFcnJvciBvY2N1cnJlZCB3aGlsZSBpbnN0YWxsaW5nIHRoZSBzdGFuZGFyZCBsaWJyYXJ5OlwiKSxjb25zb2xlLmVycm9yKGUpfSkpLmZpbmFsbHkoKCgpPT57TW9kdWxlLnJlbW92ZVJ1bkRlcGVuZGVuY3koXCJpbnN0YWxsLXN0ZGxpYlwiKX0pKX0pKX0oTW9kdWxlLHN0ZExpYlVSTCksZnVuY3Rpb24oTW9kdWxlLHBhdGgpe01vZHVsZS5wcmVSdW4ucHVzaCgoZnVuY3Rpb24oKXt0cnl7TW9kdWxlLkZTLm1rZGlyVHJlZShwYXRoKX1jYXRjaChlKXtjb25zb2xlLmVycm9yKGBFcnJvciBvY2N1cnJlZCB3aGlsZSBtYWtpbmcgYSBob21lIGRpcmVjdG9yeSAnJHtwYXRofSc6YCksY29uc29sZS5lcnJvcihlKSxjb25zb2xlLmVycm9yKFwiVXNpbmcgJy8nIGZvciBhIGhvbWUgZGlyZWN0b3J5IGluc3RlYWRcIikscGF0aD1cIi9cIn1Nb2R1bGUuRU5WLkhPTUU9cGF0aCxNb2R1bGUuRlMuY2hkaXIocGF0aCl9KSl9KE1vZHVsZSxjb25maWcuaG9tZWRpciksZnVuY3Rpb24oTW9kdWxlLG1vdW50cyl7TW9kdWxlLnByZVJ1bi5wdXNoKCgoKT0+e2Zvcihjb25zdCBtb3VudCBvZiBtb3VudHMpTW9kdWxlLkZTLm1rZGlyVHJlZShtb3VudCksTW9kdWxlLkZTLm1vdW50KE1vZHVsZS5GUy5maWxlc3lzdGVtcy5OT0RFRlMse3Jvb3Q6bW91bnR9LG1vdW50KX0pKX0oTW9kdWxlLGNvbmZpZy5fbm9kZV9tb3VudHMpLE1vZHVsZS5wcmVSdW4ucHVzaCgoKCk9PmZ1bmN0aW9uKG1vZHVsZSl7Y29uc3QgRlM9bW9kdWxlLkZTLE1FTUZTPW1vZHVsZS5GUy5maWxlc3lzdGVtcy5NRU1GUyxQQVRIPW1vZHVsZS5QQVRILG5hdGl2ZUZTQXN5bmM9e0RJUl9NT0RFOjE2ODk1LEZJTEVfTU9ERTozMzI3OSxtb3VudDpmdW5jdGlvbihtb3VudCl7aWYoIW1vdW50Lm9wdHMuZmlsZVN5c3RlbUhhbmRsZSl0aHJvdyBuZXcgRXJyb3IoXCJvcHRzLmZpbGVTeXN0ZW1IYW5kbGUgaXMgcmVxdWlyZWRcIik7cmV0dXJuIE1FTUZTLm1vdW50LmFwcGx5KG51bGwsYXJndW1lbnRzKX0sc3luY2ZzOmFzeW5jKG1vdW50LHBvcHVsYXRlLGNhbGxiYWNrKT0+e3RyeXtjb25zdCBsb2NhbD1uYXRpdmVGU0FzeW5jLmdldExvY2FsU2V0KG1vdW50KSxyZW1vdGU9YXdhaXQgbmF0aXZlRlNBc3luYy5nZXRSZW1vdGVTZXQobW91bnQpLHNyYz1wb3B1bGF0ZT9yZW1vdGU6bG9jYWwsZHN0PXBvcHVsYXRlP2xvY2FsOnJlbW90ZTthd2FpdCBuYXRpdmVGU0FzeW5jLnJlY29uY2lsZShtb3VudCxzcmMsZHN0KSxjYWxsYmFjayhudWxsKX1jYXRjaChlKXtjYWxsYmFjayhlKX19LGdldExvY2FsU2V0Om1vdW50PT57bGV0IGVudHJpZXM9T2JqZWN0LmNyZWF0ZShudWxsKTtmdW5jdGlvbiBpc1JlYWxEaXIocCl7cmV0dXJuXCIuXCIhPT1wJiZcIi4uXCIhPT1wfWZ1bmN0aW9uIHRvQWJzb2x1dGUocm9vdCl7cmV0dXJuIHA9PlBBVEguam9pbjIocm9vdCxwKX1sZXQgY2hlY2s9RlMucmVhZGRpcihtb3VudC5tb3VudHBvaW50KS5maWx0ZXIoaXNSZWFsRGlyKS5tYXAodG9BYnNvbHV0ZShtb3VudC5tb3VudHBvaW50KSk7Zm9yKDtjaGVjay5sZW5ndGg7KXtsZXQgcGF0aD1jaGVjay5wb3AoKSxzdGF0PUZTLnN0YXQocGF0aCk7RlMuaXNEaXIoc3RhdC5tb2RlKSYmY2hlY2sucHVzaC5hcHBseShjaGVjayxGUy5yZWFkZGlyKHBhdGgpLmZpbHRlcihpc1JlYWxEaXIpLm1hcCh0b0Fic29sdXRlKHBhdGgpKSksZW50cmllc1twYXRoXT17dGltZXN0YW1wOnN0YXQubXRpbWUsbW9kZTpzdGF0Lm1vZGV9fXJldHVybnt0eXBlOlwibG9jYWxcIixlbnRyaWVzOmVudHJpZXN9fSxnZXRSZW1vdGVTZXQ6YXN5bmMgbW91bnQ9Pntjb25zdCBlbnRyaWVzPU9iamVjdC5jcmVhdGUobnVsbCksaGFuZGxlcz1hd2FpdCBnZXRGc0hhbmRsZXMobW91bnQub3B0cy5maWxlU3lzdGVtSGFuZGxlKTtmb3IoY29uc3RbcGF0aCxoYW5kbGVdb2YgaGFuZGxlcylcIi5cIiE9PXBhdGgmJihlbnRyaWVzW1BBVEguam9pbjIobW91bnQubW91bnRwb2ludCxwYXRoKV09e3RpbWVzdGFtcDpcImZpbGVcIj09PWhhbmRsZS5raW5kPyhhd2FpdCBoYW5kbGUuZ2V0RmlsZSgpKS5sYXN0TW9kaWZpZWREYXRlOm5ldyBEYXRlLG1vZGU6XCJmaWxlXCI9PT1oYW5kbGUua2luZD9uYXRpdmVGU0FzeW5jLkZJTEVfTU9ERTpuYXRpdmVGU0FzeW5jLkRJUl9NT0RFfSk7cmV0dXJue3R5cGU6XCJyZW1vdGVcIixlbnRyaWVzOmVudHJpZXMsaGFuZGxlczpoYW5kbGVzfX0sbG9hZExvY2FsRW50cnk6cGF0aD0+e2NvbnN0IG5vZGU9RlMubG9va3VwUGF0aChwYXRoKS5ub2RlLHN0YXQ9RlMuc3RhdChwYXRoKTtpZihGUy5pc0RpcihzdGF0Lm1vZGUpKXJldHVybnt0aW1lc3RhbXA6c3RhdC5tdGltZSxtb2RlOnN0YXQubW9kZX07aWYoRlMuaXNGaWxlKHN0YXQubW9kZSkpcmV0dXJuIG5vZGUuY29udGVudHM9TUVNRlMuZ2V0RmlsZURhdGFBc1R5cGVkQXJyYXkobm9kZSkse3RpbWVzdGFtcDpzdGF0Lm10aW1lLG1vZGU6c3RhdC5tb2RlLGNvbnRlbnRzOm5vZGUuY29udGVudHN9O3Rocm93IG5ldyBFcnJvcihcIm5vZGUgdHlwZSBub3Qgc3VwcG9ydGVkXCIpfSxzdG9yZUxvY2FsRW50cnk6KHBhdGgsZW50cnkpPT57aWYoRlMuaXNEaXIoZW50cnkubW9kZSkpRlMubWtkaXJUcmVlKHBhdGgsZW50cnkubW9kZSk7ZWxzZXtpZighRlMuaXNGaWxlKGVudHJ5Lm1vZGUpKXRocm93IG5ldyBFcnJvcihcIm5vZGUgdHlwZSBub3Qgc3VwcG9ydGVkXCIpO0ZTLndyaXRlRmlsZShwYXRoLGVudHJ5LmNvbnRlbnRzLHtjYW5Pd246ITB9KX1GUy5jaG1vZChwYXRoLGVudHJ5Lm1vZGUpLEZTLnV0aW1lKHBhdGgsZW50cnkudGltZXN0YW1wLGVudHJ5LnRpbWVzdGFtcCl9LHJlbW92ZUxvY2FsRW50cnk6cGF0aD0+e3ZhciBzdGF0PUZTLnN0YXQocGF0aCk7RlMuaXNEaXIoc3RhdC5tb2RlKT9GUy5ybWRpcihwYXRoKTpGUy5pc0ZpbGUoc3RhdC5tb2RlKSYmRlMudW5saW5rKHBhdGgpfSxsb2FkUmVtb3RlRW50cnk6YXN5bmMgaGFuZGxlPT57aWYoXCJmaWxlXCI9PT1oYW5kbGUua2luZCl7Y29uc3QgZmlsZT1hd2FpdCBoYW5kbGUuZ2V0RmlsZSgpO3JldHVybntjb250ZW50czpuZXcgVWludDhBcnJheShhd2FpdCBmaWxlLmFycmF5QnVmZmVyKCkpLG1vZGU6bmF0aXZlRlNBc3luYy5GSUxFX01PREUsdGltZXN0YW1wOmZpbGUubGFzdE1vZGlmaWVkRGF0ZX19aWYoXCJkaXJlY3RvcnlcIj09PWhhbmRsZS5raW5kKXJldHVybnttb2RlOm5hdGl2ZUZTQXN5bmMuRElSX01PREUsdGltZXN0YW1wOm5ldyBEYXRlfTt0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGtpbmQ6IFwiK2hhbmRsZS5raW5kKX0sc3RvcmVSZW1vdGVFbnRyeTphc3luYyhoYW5kbGVzLHBhdGgsZW50cnkpPT57Y29uc3QgcGFyZW50RGlySGFuZGxlPWhhbmRsZXMuZ2V0KFBBVEguZGlybmFtZShwYXRoKSksaGFuZGxlPUZTLmlzRmlsZShlbnRyeS5tb2RlKT9hd2FpdCBwYXJlbnREaXJIYW5kbGUuZ2V0RmlsZUhhbmRsZShQQVRILmJhc2VuYW1lKHBhdGgpLHtjcmVhdGU6ITB9KTphd2FpdCBwYXJlbnREaXJIYW5kbGUuZ2V0RGlyZWN0b3J5SGFuZGxlKFBBVEguYmFzZW5hbWUocGF0aCkse2NyZWF0ZTohMH0pO2lmKFwiZmlsZVwiPT09aGFuZGxlLmtpbmQpe2NvbnN0IHdyaXRhYmxlPWF3YWl0IGhhbmRsZS5jcmVhdGVXcml0YWJsZSgpO2F3YWl0IHdyaXRhYmxlLndyaXRlKGVudHJ5LmNvbnRlbnRzKSxhd2FpdCB3cml0YWJsZS5jbG9zZSgpfWhhbmRsZXMuc2V0KHBhdGgsaGFuZGxlKX0scmVtb3ZlUmVtb3RlRW50cnk6YXN5bmMoaGFuZGxlcyxwYXRoKT0+e2NvbnN0IHBhcmVudERpckhhbmRsZT1oYW5kbGVzLmdldChQQVRILmRpcm5hbWUocGF0aCkpO2F3YWl0IHBhcmVudERpckhhbmRsZS5yZW1vdmVFbnRyeShQQVRILmJhc2VuYW1lKHBhdGgpKSxoYW5kbGVzLmRlbGV0ZShwYXRoKX0scmVjb25jaWxlOmFzeW5jKG1vdW50LHNyYyxkc3QpPT57bGV0IHRvdGFsPTA7Y29uc3QgY3JlYXRlPVtdO09iamVjdC5rZXlzKHNyYy5lbnRyaWVzKS5mb3JFYWNoKChmdW5jdGlvbihrZXkpe2NvbnN0IGU9c3JjLmVudHJpZXNba2V5XSxlMj1kc3QuZW50cmllc1trZXldOyghZTJ8fEZTLmlzRmlsZShlLm1vZGUpJiZlLnRpbWVzdGFtcC5nZXRUaW1lKCk+ZTIudGltZXN0YW1wLmdldFRpbWUoKSkmJihjcmVhdGUucHVzaChrZXkpLHRvdGFsKyspfSkpLGNyZWF0ZS5zb3J0KCk7Y29uc3QgcmVtb3ZlPVtdO2lmKE9iamVjdC5rZXlzKGRzdC5lbnRyaWVzKS5mb3JFYWNoKChmdW5jdGlvbihrZXkpe3NyYy5lbnRyaWVzW2tleV18fChyZW1vdmUucHVzaChrZXkpLHRvdGFsKyspfSkpLHJlbW92ZS5zb3J0KCkucmV2ZXJzZSgpLCF0b3RhbClyZXR1cm47Y29uc3QgaGFuZGxlcz1cInJlbW90ZVwiPT09c3JjLnR5cGU/c3JjLmhhbmRsZXM6ZHN0LmhhbmRsZXM7Zm9yKGNvbnN0IHBhdGggb2YgY3JlYXRlKXtjb25zdCByZWxQYXRoPVBBVEgubm9ybWFsaXplKHBhdGgucmVwbGFjZShtb3VudC5tb3VudHBvaW50LFwiL1wiKSkuc3Vic3RyaW5nKDEpO2lmKFwibG9jYWxcIj09PWRzdC50eXBlKXtjb25zdCBoYW5kbGU9aGFuZGxlcy5nZXQocmVsUGF0aCksZW50cnk9YXdhaXQgbmF0aXZlRlNBc3luYy5sb2FkUmVtb3RlRW50cnkoaGFuZGxlKTtuYXRpdmVGU0FzeW5jLnN0b3JlTG9jYWxFbnRyeShwYXRoLGVudHJ5KX1lbHNle2NvbnN0IGVudHJ5PW5hdGl2ZUZTQXN5bmMubG9hZExvY2FsRW50cnkocGF0aCk7YXdhaXQgbmF0aXZlRlNBc3luYy5zdG9yZVJlbW90ZUVudHJ5KGhhbmRsZXMscmVsUGF0aCxlbnRyeSl9fWZvcihjb25zdCBwYXRoIG9mIHJlbW92ZSlpZihcImxvY2FsXCI9PT1kc3QudHlwZSluYXRpdmVGU0FzeW5jLnJlbW92ZUxvY2FsRW50cnkocGF0aCk7ZWxzZXtjb25zdCByZWxQYXRoPVBBVEgubm9ybWFsaXplKHBhdGgucmVwbGFjZShtb3VudC5tb3VudHBvaW50LFwiL1wiKSkuc3Vic3RyaW5nKDEpO2F3YWl0IG5hdGl2ZUZTQXN5bmMucmVtb3ZlUmVtb3RlRW50cnkoaGFuZGxlcyxyZWxQYXRoKX19fTttb2R1bGUuRlMuZmlsZXN5c3RlbXMuTkFUSVZFRlNfQVNZTkM9bmF0aXZlRlNBc3luY30oTW9kdWxlKSkpfWZ1bmN0aW9uIGZpbmFsaXplQm9vdHN0cmFwKEFQSSxjb25maWcpe0FQSS5ydW5QeXRob25JbnRlcm5hbF9kaWN0PUFQSS5fcHlvZGlkZS5fYmFzZS5ldmFsX2NvZGUoXCJ7fVwiKSxBUEkuaW1wb3J0bGliPUFQSS5ydW5QeXRob25JbnRlcm5hbChcImltcG9ydCBpbXBvcnRsaWI7IGltcG9ydGxpYlwiKTtsZXQgaW1wb3J0X21vZHVsZT1BUEkuaW1wb3J0bGliLmltcG9ydF9tb2R1bGU7QVBJLnN5cz1pbXBvcnRfbW9kdWxlKFwic3lzXCIpLEFQSS5zeXMucGF0aC5pbnNlcnQoMCxjb25maWcuaG9tZWRpciksQVBJLm9zPWltcG9ydF9tb2R1bGUoXCJvc1wiKTtsZXQgZ2xvYmFscz1BUEkucnVuUHl0aG9uSW50ZXJuYWwoXCJpbXBvcnQgX19tYWluX187IF9fbWFpbl9fLl9fZGljdF9fXCIpLGJ1aWx0aW5zPUFQSS5ydW5QeXRob25JbnRlcm5hbChcImltcG9ydCBidWlsdGluczsgYnVpbHRpbnMuX19kaWN0X19cIik7dmFyIGJ1aWx0aW5zX2RpY3Q7QVBJLmdsb2JhbHM9KGJ1aWx0aW5zX2RpY3Q9YnVpbHRpbnMsbmV3IFByb3h5KGdsb2JhbHMse2dldDoodGFyZ2V0LHN5bWJvbCk9PlwiZ2V0XCI9PT1zeW1ib2w/a2V5PT57bGV0IHJlc3VsdD10YXJnZXQuZ2V0KGtleSk7cmV0dXJuIHZvaWQgMD09PXJlc3VsdCYmKHJlc3VsdD1idWlsdGluc19kaWN0LmdldChrZXkpKSxyZXN1bHR9OlwiaGFzXCI9PT1zeW1ib2w/a2V5PT50YXJnZXQuaGFzKGtleSl8fGJ1aWx0aW5zX2RpY3QuaGFzKGtleSk6UmVmbGVjdC5nZXQodGFyZ2V0LHN5bWJvbCl9KSk7bGV0IGltcG9ydGhvb2s9QVBJLl9weW9kaWRlLl9pbXBvcnRob29rO2ltcG9ydGhvb2sucmVnaXN0ZXJfanNfZmluZGVyKCksaW1wb3J0aG9vay5yZWdpc3Rlcl9qc19tb2R1bGUoXCJqc1wiLGNvbmZpZy5qc2dsb2JhbHMpO2xldCBweW9kaWRlPUFQSS5tYWtlUHVibGljQVBJKCk7cmV0dXJuIGltcG9ydGhvb2sucmVnaXN0ZXJfanNfbW9kdWxlKFwicHlvZGlkZV9qc1wiLHB5b2RpZGUpLEFQSS5weW9kaWRlX3B5PWltcG9ydF9tb2R1bGUoXCJweW9kaWRlXCIpLEFQSS5weW9kaWRlX2NvZGU9aW1wb3J0X21vZHVsZShcInB5b2RpZGUuY29kZVwiKSxBUEkucHlvZGlkZV9mZmk9aW1wb3J0X21vZHVsZShcInB5b2RpZGUuZmZpXCIpLEFQSS5wYWNrYWdlX2xvYWRlcj1pbXBvcnRfbW9kdWxlKFwicHlvZGlkZS5fcGFja2FnZV9sb2FkZXJcIiksQVBJLnNpdGVwYWNrYWdlcz1BUEkucGFja2FnZV9sb2FkZXIuU0lURV9QQUNLQUdFUy5fX3N0cl9fKCksQVBJLmRzb2Rpcj1BUEkucGFja2FnZV9sb2FkZXIuRFNPX0RJUi5fX3N0cl9fKCksQVBJLmRlZmF1bHRMZExpYnJhcnlQYXRoPVtBUEkuZHNvZGlyLEFQSS5zaXRlcGFja2FnZXNdLEFQSS5vcy5lbnZpcm9uLl9fc2V0aXRlbV9fKFwiTERfTElCUkFSWV9QQVRIXCIsQVBJLmRlZmF1bHRMZExpYnJhcnlQYXRoLmpvaW4oXCI6XCIpKSxweW9kaWRlLnB5b2RpZGVfcHk9QVBJLnB5b2RpZGVfcHkscHlvZGlkZS5nbG9iYWxzPUFQSS5nbG9iYWxzLHB5b2RpZGV9YXN5bmMgZnVuY3Rpb24gbG9hZFB5b2RpZGUob3B0aW9ucz17fSl7YXdhaXQgYXN5bmMgZnVuY3Rpb24oKXtpZighSU5fTk9ERSlyZXR1cm47aWYobm9kZVVybE1vZD0oYXdhaXQgaW1wb3J0KFwidXJsXCIpKS5kZWZhdWx0LG5vZGVGc1Byb21pc2VzTW9kPWF3YWl0IGltcG9ydChcImZzL3Byb21pc2VzXCIpLG5vZGVGZXRjaD1nbG9iYWxUaGlzLmZldGNoP2ZldGNoOihhd2FpdCBpbXBvcnQoXCJub2RlLWZldGNoXCIpKS5kZWZhdWx0LG5vZGVWbU1vZD0oYXdhaXQgaW1wb3J0KFwidm1cIikpLmRlZmF1bHQsbm9kZVBhdGg9YXdhaXQgaW1wb3J0KFwicGF0aFwiKSxwYXRoU2VwPW5vZGVQYXRoLnNlcCxcInVuZGVmaW5lZFwiIT10eXBlb2YgcmVxdWlyZSlyZXR1cm47Y29uc3Qgbm9kZV9tb2R1bGVzPXtmczphd2FpdCBpbXBvcnQoXCJmc1wiKSxjcnlwdG86YXdhaXQgaW1wb3J0KFwiY3J5cHRvXCIpLHdzOmF3YWl0IGltcG9ydChcIndzXCIpLGNoaWxkX3Byb2Nlc3M6YXdhaXQgaW1wb3J0KFwiY2hpbGRfcHJvY2Vzc1wiKX07Z2xvYmFsVGhpcy5yZXF1aXJlPWZ1bmN0aW9uKG1vZCl7cmV0dXJuIG5vZGVfbW9kdWxlc1ttb2RdfX0oKTtsZXQgaW5kZXhVUkw9b3B0aW9ucy5pbmRleFVSTHx8ZnVuY3Rpb24oKXtpZihcInN0cmluZ1wiPT10eXBlb2YgX19kaXJuYW1lKXJldHVybiBfX2Rpcm5hbWU7bGV0IGVycjt0cnl7dGhyb3cgbmV3IEVycm9yfWNhdGNoKGUpe2Vycj1lfWxldCBmaWxlTmFtZT1FcnJvclN0YWNrUGFyc2VyLnBhcnNlKGVycilbMF0uZmlsZU5hbWU7Y29uc3QgaW5kZXhPZkxhc3RTbGFzaD1maWxlTmFtZS5sYXN0SW5kZXhPZihwYXRoU2VwKTtpZigtMT09PWluZGV4T2ZMYXN0U2xhc2gpdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGV4dHJhY3QgaW5kZXhVUkwgcGF0aCBmcm9tIHB5b2RpZGUgbW9kdWxlIGxvY2F0aW9uXCIpO3JldHVybiBmaWxlTmFtZS5zbGljZSgwLGluZGV4T2ZMYXN0U2xhc2gpfSgpO2luZGV4VVJMPXJlc29sdmVQYXRoKGluZGV4VVJMKSxpbmRleFVSTC5lbmRzV2l0aChcIi9cIil8fChpbmRleFVSTCs9XCIvXCIpLG9wdGlvbnMuaW5kZXhVUkw9aW5kZXhVUkw7Y29uc3QgZGVmYXVsdF9jb25maWc9e2Z1bGxTdGRMaWI6ITEsanNnbG9iYWxzOmdsb2JhbFRoaXMsc3RkaW46Z2xvYmFsVGhpcy5wcm9tcHQ/Z2xvYmFsVGhpcy5wcm9tcHQ6dm9pZCAwLGhvbWVkaXI6XCIvaG9tZS9weW9kaWRlXCIsbG9ja0ZpbGVVUkw6aW5kZXhVUkwrXCJyZXBvZGF0YS5qc29uXCIsYXJnczpbXSxfbm9kZV9tb3VudHM6W119LGNvbmZpZz1PYmplY3QuYXNzaWduKGRlZmF1bHRfY29uZmlnLG9wdGlvbnMpLE1vZHVsZT1mdW5jdGlvbigpe2xldCBNb2R1bGU9e25vSW1hZ2VEZWNvZGluZzohMCxub0F1ZGlvRGVjb2Rpbmc6ITAsbm9XYXNtRGVjb2Rpbmc6ITEscHJlUnVuOltdLHF1aXQ6KHN0YXR1cyx0b1Rocm93KT0+e3Rocm93IE1vZHVsZS5leGl0ZWQ9e3N0YXR1czpzdGF0dXMsdG9UaHJvdzp0b1Rocm93fSx0b1Rocm93fX07cmV0dXJuIE1vZHVsZX0oKTtNb2R1bGUucHJpbnQ9Y29uZmlnLnN0ZG91dCxNb2R1bGUucHJpbnRFcnI9Y29uZmlnLnN0ZGVycixNb2R1bGUuYXJndW1lbnRzPWNvbmZpZy5hcmdzO2NvbnN0IEFQST17Y29uZmlnOmNvbmZpZ307TW9kdWxlLkFQST1BUEksaW5pdGlhbGl6ZUZpbGVTeXN0ZW0oTW9kdWxlLGNvbmZpZyk7Y29uc3QgbW9kdWxlTG9hZGVkPW5ldyBQcm9taXNlKChyPT5Nb2R1bGUucG9zdFJ1bj1yKSk7aWYoTW9kdWxlLmxvY2F0ZUZpbGU9cGF0aD0+Y29uZmlnLmluZGV4VVJMK3BhdGgsXCJmdW5jdGlvblwiIT10eXBlb2YgX2NyZWF0ZVB5b2RpZGVNb2R1bGUpe2NvbnN0IHNjcmlwdFNyYz1gJHtjb25maWcuaW5kZXhVUkx9cHlvZGlkZS5hc20uanNgO2F3YWl0IGxvYWRTY3JpcHQoc2NyaXB0U3JjKX1pZihhd2FpdCBfY3JlYXRlUHlvZGlkZU1vZHVsZShNb2R1bGUpLGF3YWl0IG1vZHVsZUxvYWRlZCxNb2R1bGUuZXhpdGVkKXRocm93IE1vZHVsZS5leGl0ZWQudG9UaHJvdztpZihcIjAuMjMuM1wiIT09QVBJLnZlcnNpb24pdGhyb3cgbmV3IEVycm9yKGBQeW9kaWRlIHZlcnNpb24gZG9lcyBub3QgbWF0Y2g6ICcwLjIzLjMnIDw9PT4gJyR7QVBJLnZlcnNpb259Jy4gSWYgeW91IHVwZGF0ZWQgdGhlIFB5b2RpZGUgdmVyc2lvbiwgbWFrZSBzdXJlIHlvdSBhbHNvIHVwZGF0ZWQgdGhlICdpbmRleFVSTCcgcGFyYW1ldGVyIHBhc3NlZCB0byBsb2FkUHlvZGlkZS5gKTtNb2R1bGUubG9jYXRlRmlsZT1wYXRoPT57dGhyb3cgbmV3IEVycm9yKFwiRGlkbid0IGV4cGVjdCB0byBsb2FkIGFueSBtb3JlIGZpbGVfcGFja2FnZXIgZmlsZXMhXCIpfTtsZXRbZXJyLGNhcHR1cmVkX3N0ZGVycl09QVBJLnJhd1J1bihcImltcG9ydCBfcHlvZGlkZV9jb3JlXCIpO2VyciYmTW9kdWxlLkFQSS5mYXRhbF9sb2FkaW5nX2Vycm9yKFwiRmFpbGVkIHRvIGltcG9ydCBfcHlvZGlkZV9jb3JlXFxuXCIsY2FwdHVyZWRfc3RkZXJyKTtjb25zdCBweW9kaWRlPWZpbmFsaXplQm9vdHN0cmFwKEFQSSxjb25maWcpO2lmKHB5b2RpZGUudmVyc2lvbi5pbmNsdWRlcyhcImRldlwiKXx8QVBJLnNldENkblVybChgaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L3B5b2RpZGUvdiR7cHlvZGlkZS52ZXJzaW9ufS9mdWxsL2ApLGF3YWl0IEFQSS5wYWNrYWdlSW5kZXhSZWFkeSxBUEkuX3B5b2RpZGUuX2ltcG9ydGhvb2sucmVnaXN0ZXJfbW9kdWxlX25vdF9mb3VuZF9ob29rKEFQSS5faW1wb3J0X25hbWVfdG9fcGFja2FnZV9uYW1lLEFQSS5yZXBvZGF0YV91bnZlbmRvcmVkX3N0ZGxpYnNfYW5kX3Rlc3QpLFwiMC4yMy4zXCIhPT1BUEkucmVwb2RhdGFfaW5mby52ZXJzaW9uKXRocm93IG5ldyBFcnJvcihcIkxvY2sgZmlsZSB2ZXJzaW9uIGRvZXNuJ3QgbWF0Y2ggUHlvZGlkZSB2ZXJzaW9uXCIpO3JldHVybiBBUEkucGFja2FnZV9sb2FkZXIuaW5pdF9sb2FkZWRfcGFja2FnZXMoKSxjb25maWcuZnVsbFN0ZExpYiYmYXdhaXQgcHlvZGlkZS5sb2FkUGFja2FnZShBUEkucmVwb2RhdGFfdW52ZW5kb3JlZF9zdGRsaWJzKSxBUEkuaW5pdGlhbGl6ZVN0cmVhbXMoY29uZmlnLnN0ZGluLGNvbmZpZy5zdGRvdXQsY29uZmlnLnN0ZGVycikscHlvZGlkZX1nbG9iYWxUaGlzLmxvYWRQeW9kaWRlPWxvYWRQeW9kaWRlLGV4cG9ydHMubG9hZFB5b2RpZGU9bG9hZFB5b2RpZGUsZXhwb3J0cy52ZXJzaW9uPVwiMC4yMy4zXCIsT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1weW9kaWRlLmpzLm1hcFxuIiwidmFyIGU9e2Q6KG4sdCk9Pntmb3IodmFyIHIgaW4gdCllLm8odCxyKSYmIWUubyhuLHIpJiZPYmplY3QuZGVmaW5lUHJvcGVydHkobixyLHtlbnVtZXJhYmxlOiEwLGdldDp0W3JdfSl9LG86KGUsbik9Pk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pfSxuPXt9O2UuZChuLHtaNTooKT0+eSx5UzooKT0+bSxOdDooKT0+aCxqWDooKT0+dixVUzooKT0+RSxIZzooKT0+ZyxlcDooKT0+YyxndTooKT0+dSxHczooKT0+XyxTYzooKT0+cH0pO2NvbnN0IHQ9KGUsbj17fSk9Pntjb25zdCB0PSEwPT09bi5zYWZlfHwhMD09PW4ua2VlcFByb3RlY3RlZDtsZXQgcj0hMTtjb25zdCBzPWU9PntsZXQgaSxvLGE9XCJcIjtpZihcIm5vZGVzXCJpbiBlKWZvcihjb25zdCBsIG9mIGUubm9kZXMpc3dpdGNoKGwudHlwZSl7Y2FzZVwiYmxvY2tcIjppZihuLmZpcnN0JiYhMD09PXIpe2ErPXMobCk7YnJlYWt9aWYoITA9PT1uLnByZXNlcnZlTmV3bGluZXMpe2k9cyhsKSxvPWkuc3BsaXQoXCJcXG5cIiksYSs9XCJcXG5cIi5yZXBlYXQoby5sZW5ndGgtMSk7YnJlYWt9aWYoITA9PT10JiYhMD09PWwucHJvdGVjdGVkKXthKz1zKGwpO2JyZWFrfXI9ITA7YnJlYWs7Y2FzZVwibGluZVwiOmlmKG4uZmlyc3QmJiEwPT09cil7YSs9bC52YWx1ZTticmVha30hMD09PXQmJiEwPT09bC5wcm90ZWN0ZWQmJihhKz1sLnZhbHVlKSxyPSEwO2JyZWFrO2RlZmF1bHQ6YSs9bC52YWx1ZXx8XCJcIn1yZXR1cm4gYX07cmV0dXJuIHMoZSl9O2NsYXNzIHJ7Y29uc3RydWN0b3IoZSl7dGhpcy50eXBlPWUudHlwZSx0aGlzLnZhbHVlPWUudmFsdWUsdGhpcy5tYXRjaD1lLm1hdGNoLHRoaXMubmV3bGluZT1lLm5ld2xpbmV8fFwiXCJ9Z2V0IHByb3RlY3RlZCgpe3JldHVybiBCb29sZWFuKHRoaXMubWF0Y2gmJlwiIVwiPT09dGhpcy5tYXRjaFsxXSl9fWNsYXNzIHMgZXh0ZW5kcyBye2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLHRoaXMubm9kZXM9KG51bGw9PWU/dm9pZCAwOmUubm9kZXMpfHxbXX1wdXNoKGUpe3RoaXMubm9kZXMucHVzaChlKX1nZXQgcHJvdGVjdGVkKCl7cmV0dXJuIHRoaXMubm9kZXMubGVuZ3RoPjAmJiEwPT09dGhpcy5ub2Rlc1swXS5wcm90ZWN0ZWR9fWNvbnN0IGk9e2FkYTp7TElORV9SRUdFWDovXi0tLiovfSxhcGw6e0xJTkVfUkVHRVg6L17ijZ0uKi99LGFwcGxlc2NyaXB0OntCTE9DS19PUEVOX1JFR0VYOi9eXFwoXFwqLyxCTE9DS19DTE9TRV9SRUdFWDovXlxcKlxcKS99LGNzaGFycDp7TElORV9SRUdFWDovXlxcL1xcLy4qL30saGFza2VsbDp7QkxPQ0tfT1BFTl9SRUdFWDovXlxcey0vLEJMT0NLX0NMT1NFX1JFR0VYOi9eLVxcfS8sTElORV9SRUdFWDovXi0tLiovfSxqYXZhc2NyaXB0OntCTE9DS19PUEVOX1JFR0VYOi9eXFwvXFwqXFwqPyghPykvLEJMT0NLX0NMT1NFX1JFR0VYOi9eXFwqXFwvKFxcbj8pLyxMSU5FX1JFR0VYOi9eXFwvXFwvKCE/KS4qL30sbHVhOntCTE9DS19PUEVOX1JFR0VYOi9eLS1cXFtcXFsvLEJMT0NLX0NMT1NFX1JFR0VYOi9eXFxdXFxdLyxMSU5FX1JFR0VYOi9eLS0uKi99LG1hdGxhYjp7QkxPQ0tfT1BFTl9SRUdFWDovXiV7LyxCTE9DS19DTE9TRV9SRUdFWDovXiV9LyxMSU5FX1JFR0VYOi9eJS4qL30scGVybDp7TElORV9SRUdFWDovXiMuKi99LHBocDp7QkxPQ0tfT1BFTl9SRUdFWDovXlxcL1xcKlxcKj8oIT8pLyxCTE9DS19DTE9TRV9SRUdFWDovXlxcKlxcLyhcXG4/KS8sTElORV9SRUdFWDovXigjfFxcL1xcLykuKj8oPz1cXD8+fFxcbikvfSxydWJ5OntCTE9DS19PUEVOX1JFR0VYOi9ePWJlZ2luLyxCTE9DS19DTE9TRV9SRUdFWDovXj1lbmQvLExJTkVfUkVHRVg6L14jLiovfSxzaGViYW5nOntMSU5FX1JFR0VYOi9eIyEuKi99LHB5dGhvbjp7QkxPQ0tfT1BFTl9SRUdFWDovXlwiXCJcIi8sQkxPQ0tfQ0xPU0VfUkVHRVg6L15cIlwiXCIvLExJTkVfUkVHRVg6L14jLiovfSxjOntCTE9DS19PUEVOX1JFR0VYOi9eXFwvXFwqXFwqPyghPykvLEJMT0NLX0NMT1NFX1JFR0VYOi9eXFwqXFwvKFxcbj8pLyxMSU5FX1JFR0VYOi9eXFwvXFwvKCE/KS4qL30sY3NzOntCTE9DS19PUEVOX1JFR0VYOi9eXFwvXFwqXFwqPyghPykvLEJMT0NLX0NMT1NFX1JFR0VYOi9eXFwqXFwvKFxcbj8pLyxMSU5FX1JFR0VYOi9eXFwvXFwvKCE/KS4qL30samF2YTp7QkxPQ0tfT1BFTl9SRUdFWDovXlxcL1xcKlxcKj8oIT8pLyxCTE9DS19DTE9TRV9SRUdFWDovXlxcKlxcLyhcXG4/KS8sTElORV9SRUdFWDovXlxcL1xcLyghPykuKi99LGpzOntCTE9DS19PUEVOX1JFR0VYOi9eXFwvXFwqXFwqPyghPykvLEJMT0NLX0NMT1NFX1JFR0VYOi9eXFwqXFwvKFxcbj8pLyxMSU5FX1JFR0VYOi9eXFwvXFwvKCE/KS4qL30sbGVzczp7QkxPQ0tfT1BFTl9SRUdFWDovXlxcL1xcKlxcKj8oIT8pLyxCTE9DS19DTE9TRV9SRUdFWDovXlxcKlxcLyhcXG4/KS8sTElORV9SRUdFWDovXlxcL1xcLyghPykuKi99LHBhc2NhbDp7QkxPQ0tfT1BFTl9SRUdFWDovXlxcKFxcKi8sQkxPQ0tfQ0xPU0VfUkVHRVg6L15cXCpcXCkvfSxvY2FtbDp7QkxPQ0tfT1BFTl9SRUdFWDovXlxcKFxcKi8sQkxPQ0tfQ0xPU0VfUkVHRVg6L15cXCpcXCkvfSxzYXNzOntCTE9DS19PUEVOX1JFR0VYOi9eXFwvXFwqXFwqPyghPykvLEJMT0NLX0NMT1NFX1JFR0VYOi9eXFwqXFwvKFxcbj8pLyxMSU5FX1JFR0VYOi9eXFwvXFwvKCE/KS4qL30sc3FsOntMSU5FX1JFR0VYOi9eLS0uKi99LHN3aWZ0OntCTE9DS19PUEVOX1JFR0VYOi9eXFwvXFwqXFwqPyghPykvLEJMT0NLX0NMT1NFX1JFR0VYOi9eXFwqXFwvKFxcbj8pLyxMSU5FX1JFR0VYOi9eXFwvXFwvKCE/KS4qL30sdHM6e0JMT0NLX09QRU5fUkVHRVg6L15cXC9cXCpcXCo/KCE/KS8sQkxPQ0tfQ0xPU0VfUkVHRVg6L15cXCpcXC8oXFxuPykvLExJTkVfUkVHRVg6L15cXC9cXC8oIT8pLiovfSx0eXBzY3JpcHQ6e0JMT0NLX09QRU5fUkVHRVg6L15cXC9cXCpcXCo/KCE/KS8sQkxPQ0tfQ0xPU0VfUkVHRVg6L15cXCpcXC8oXFxuPykvLExJTkVfUkVHRVg6L15cXC9cXC8oIT8pLiovfX0sbz0vXlxcXFwuLyxhPS9eKFsnXCJgXSkoKD86XFxcXFxcMXxbXlxcMV0pKj8pKFxcMSkvLGw9L15cXHIqXFxuLyxmPShlLG49e30pPT57dmFyIHQ7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGlucHV0IHRvIGJlIGEgc3RyaW5nXCIpO2NvbnN0IGY9bmV3IHMoe3R5cGU6XCJyb290XCIsbm9kZXM6W10sdmFsdWU6XCJcIn0pLGQ9W2ZdLHU9KG4ubGFuZ3VhZ2V8fFwiamF2YXNjcmlwdFwiKS50b0xvd2VyQ2FzZSgpLGM9aVt1XTtpZih2b2lkIDA9PT1jKXRocm93IG5ldyBFcnJvcihgTGFuZ3VhZ2UgXCIke3V9XCIgaXMgbm90IHN1cHBvcnRlZCBieSBzdHJpcC1jb21tZW50c2ApO2NvbnN0e0xJTkVfUkVHRVg6XyxCTE9DS19PUEVOX1JFR0VYOnAsQkxPQ0tfQ0xPU0VfUkVHRVg6aH09YztsZXQgRSxtLGc9Zix5PWUsdj0hMTtbcCxoXS5maWx0ZXIoKGU9PnZvaWQgMCE9PWUpKS5ldmVyeSgoZT0+J15cIlwiXCInPT09ZS5zb3VyY2UpKSYmKHY9ITApO2NvbnN0IE49KGU9eVswXXx8XCJcIik9Pih5PXkuc2xpY2UoZS5sZW5ndGgpLGUpLGI9KGUsbj1cInRleHRcIik9Pntjb25zdCB0PWUuZXhlYyh5KTtpZih0KXJldHVybiBOKHRbMF0pLHt0eXBlOm4sdmFsdWU6dFswXSxtYXRjaDp0fX0sUj1lPT57bSYmXCJ0ZXh0XCI9PT1tLnR5cGUmJlwidGV4dFwiPT09ZS50eXBlP20udmFsdWU9bS52YWx1ZT9tLnZhbHVlK2UudmFsdWU6ZS52YWx1ZTooZy5wdXNoKGUpLFwibm9kZXNcImluIGUmJmUubm9kZXMmJihkLnB1c2goZSksZz1lKSxtPWUpfSxDPSgpPT57aWYoXCJyb290XCI9PT1nLnR5cGUpdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVW5jbG9zZWQgYmxvY2sgY29tbWVudFwiKTtkLnBvcCgpLGc9ZFtkLmxlbmd0aC0xXX07Zm9yKDtcIlwiIT09eTspKEU9YihvLFwidGV4dFwiKSk/UihuZXcgcyhFKSk6XCJibG9ja1wiPT09Zy50eXBlfHxtJiYvXFx3JC8udGVzdChudWxsIT09KHQ9bS52YWx1ZSkmJnZvaWQgMCE9PXQ/dDpcIlwiKXx8diYmeS5zdGFydHNXaXRoKCdcIlwiXCInKXx8IShFPWIoYSxcInRleHRcIikpPyhFPWIobCxcIm5ld2xpbmVcIikpP1IobmV3IHIoRSkpOiFwfHwhbi5ibG9ja3x8diYmXCJibG9ja1wiPT09Zy50eXBlfHwhKEU9YihwLFwib3BlblwiKSk/aCYmXCJibG9ja1wiPT09Zy50eXBlJiZuLmJsb2NrJiYoRT1iKGgsXCJjbG9zZVwiKSk/KEUubmV3bGluZT1FLm1hdGNoWzFdfHxcIlwiLFIobmV3IHIoRSkpLEMoKSk6XyYmXCJibG9ja1wiIT09Zy50eXBlJiZuLmxpbmUmJihFPWIoXyxcImxpbmVcIikpfHwoRT1iKC9eW2EtekFCRC1aMC05XFx0IF0rLyxcInRleHRcIikpP1IobmV3IHIoRSkpOlIobmV3IHIoe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Tih5WzBdKX0pKTooUihuZXcgcyh7dHlwZTpcImJsb2NrXCJ9KSksUihuZXcgcihFKSkpOlIobmV3IHIoRSkpO3JldHVybiBmfSxkPShlLG4pPT57Y29uc3Qgcj1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse2Jsb2NrOiEwLGxpbmU6ITB9KTtyZXR1cm4gdChmKGUscikscil9O2Z1bmN0aW9uIHUoZSl7cmV0dXJuIGUucmVwbGFjZSgvPCEtLVtcXHNcXFNdKj8oLS0+fCQpL2csXCJcIil9ZnVuY3Rpb24gYyhlKXtyZXR1cm4gZS5yZXBsYWNlKC9cXC9cXCpbXFxzXFxTXSs/XFwqXFwvL2csXCJcIil9ZnVuY3Rpb24gXyhlKXt0cnl7cmV0dXJuIGQoZSl9Y2F0Y2gobil7cmV0dXJuIGV9fWZ1bmN0aW9uIHAoZSl7cmV0dXJuIGUucmVwbGFjZSgvXFxzL2csXCJcIil9ZnVuY3Rpb24gaChlKXtyZXR1cm4gZS5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZyxcIlxcXFwkJlwiKX1mdW5jdGlvbiBFKGUsbil7dmFyIHQ7Y29uc3Qgcj1kKG4pLHM9YF5cXFxccyo/JHtoKGUpfVxcXFwoXFxcXHMqP1xcXFwpYCxpPW51bGwhPT0odD1uZXcgUmVnRXhwKHMsXCJnbVwiKS5leGVjKHIpKSYmdm9pZCAwIT09dD90OltdO3JldHVybiBCb29sZWFuKGkubGVuZ3RoKX1mdW5jdGlvbiBtKC4uLmUpe2NvbnN0IG49ZS5tYXAoKGU9Pm5ldyBSZWdFeHAoZSkuc291cmNlKSkuam9pbihcIlwiKTtyZXR1cm4gbmV3IFJlZ0V4cChuKX1kLmJsb2NrPShlLG4pPT57Y29uc3Qgcj1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse2Jsb2NrOiEwfSk7cmV0dXJuIHQoZihlLHIpLHIpfSxkLmxpbmU9KGUsbik9Pntjb25zdCByPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7bGluZTohMH0pO3JldHVybiB0KGYoZSxyKSxyKX0sZC5maXJzdD0oZSxuKT0+e2NvbnN0IHI9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtibG9jazohMCxsaW5lOiEwLGZpcnN0OiEwfSk7cmV0dXJuIHQoZihlLHIpLHIpfSxkLnBhcnNlPWY7Y29uc3QgZz17YXN0SGVscGVyczonaW1wb3J0IGFzdFxcblxcbiMgQSBjaGFpbmFibGUgY2xhc3MgdGhhdCBhbGxvd3MgdXMgdG8gY2FsbCBmdW5jdGlvbnMgb24gdGhlIHJlc3VsdCBvZiBwYXJzaW5nIGEgc3RyaW5nXFxuXFxuXFxuY2xhc3MgTm9kZTpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIHRyZWU9Tm9uZSk6XFxuICAgICAgICBpZiBpc2luc3RhbmNlKHRyZWUsIHN0cik6XFxuICAgICAgICAgICAgc2VsZi50cmVlID0gYXN0LnBhcnNlKHRyZWUpXFxuICAgICAgICBlbGlmIGlzaW5zdGFuY2UodHJlZSwgYXN0LkFTVCkgb3IgdHJlZSA9PSBOb25lOlxcbiAgICAgICAgICAgIHNlbGYudHJlZSA9IHRyZWVcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgcmFpc2UgVHlwZUVycm9yKFwiTm9kZSBtdXN0IGJlIGluaXRpYWxpemVkIHdpdGggYSBzdHJpbmcgb3IgQVNUXCIpXFxuXFxuICAgIGRlZiBfX2dldGl0ZW1fXyhzZWxmLCBpKTpcXG4gICAgICAgIGlmIGdldGF0dHIoc2VsZi50cmVlLCBcIl9fZ2V0aXRlbV9fXCIsIEZhbHNlKTpcXG4gICAgICAgICAgICByZXR1cm4gTm9kZShzZWxmLnRyZWVbaV0pXFxuICAgICAgICBlbGlmIGdldGF0dHIoc2VsZi50cmVlLCBcImJvZHlcIiwgRmFsc2UpOlxcbiAgICAgICAgICAgIHJldHVybiBOb2RlKHNlbGYudHJlZS5ib2R5W2ldKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByYWlzZSBJbmRleEVycm9yKFwiRW1wdHkgTm9kZXMgY2Fubm90IGJlIGluZGV4ZWQuXCIpXFxuXFxuICAgIGRlZiBfX2xlbl9fKHNlbGYpOlxcbiAgICAgICAgaWYgZ2V0YXR0cihzZWxmLnRyZWUsIFwiX19sZW5fX1wiLCBGYWxzZSk6XFxuICAgICAgICAgICAgcmV0dXJuIGxlbihzZWxmLnRyZWUpXFxuICAgICAgICBpZiBzZWxmLnRyZWUgaXMgTm9uZTpcXG4gICAgICAgICAgICByZXR1cm4gMFxcbiAgICAgICAgaWYgbm90IGhhc2F0dHIoc2VsZi50cmVlLCBcImJvZHlcIik6XFxuICAgICAgICAgICAgcmV0dXJuIDFcXG4gICAgICAgIHJldHVybiBsZW4oc2VsZi50cmVlLmJvZHkpXFxuXFxuICAgIGRlZiBfX2VxX18oc2VsZiwgb3RoZXIpOlxcbiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2Uob3RoZXIsIE5vZGUpOlxcbiAgICAgICAgICAgIHJldHVybiBGYWxzZVxcbiAgICAgICAgaWYgc2VsZi50cmVlID09IE5vbmU6XFxuICAgICAgICAgICAgcmV0dXJuIG90aGVyLnRyZWUgPT0gTm9uZVxcbiAgICAgICAgaWYgb3RoZXIudHJlZSA9PSBOb25lOlxcbiAgICAgICAgICAgIHJldHVybiBGYWxzZVxcbiAgICAgICAgcmV0dXJuIGFzdC5kdW1wKHNlbGYudHJlZSwgaW5jbHVkZV9hdHRyaWJ1dGVzPVRydWUpID09IGFzdC5kdW1wKFxcbiAgICAgICAgICAgIG90aGVyLnRyZWUsIGluY2x1ZGVfYXR0cmlidXRlcz1UcnVlXFxuICAgICAgICApXFxuXFxuICAgIGRlZiBfX3JlcHJfXyhzZWxmKTpcXG4gICAgICAgIGlmIHNlbGYudHJlZSA9PSBOb25lOlxcbiAgICAgICAgICAgIHJldHVybiBcIk5vZGU6XFxcXG5Ob25lXCJcXG4gICAgICAgIHJldHVybiBcIk5vZGU6XFxcXG5cIiArIGFzdC5kdW1wKHNlbGYudHJlZSwgaW5kZW50PTIpXFxuXFxuICAgIGRlZiBfX3N0cl9fKHNlbGYpOlxcbiAgICAgICAgaWYgc2VsZi50cmVlID09IE5vbmU6XFxuICAgICAgICAgICAgcmV0dXJuIFwiIyBubyBhc3RcIlxcbiAgICAgICAgcmV0dXJuIGFzdC51bnBhcnNlKHNlbGYudHJlZSlcXG5cXG4gICAgZGVmIF9oYXNfYm9keShzZWxmKTpcXG4gICAgICAgIHJldHVybiBib29sKGdldGF0dHIoc2VsZi50cmVlLCBcImJvZHlcIiwgRmFsc2UpKVxcblxcbiAgICAjIFwiZmluZFwiIGZ1bmN0aW9ucyByZXR1cm4gYSBuZXcgbm9kZSB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIGZpbmRcXG4gICAgIyBmdW5jdGlvbi4gSW4gdGhpcyBjYXNlLCBpdCByZXR1cm5zIGEgbmV3IG5vZGUgd2l0aCB0aGUgZnVuY3Rpb25cXG4gICAgIyBkZWZpbml0aW9uIChpZiBpdCBleGlzdHMpXFxuXFxuICAgIGRlZiBmaW5kX2Z1bmN0aW9uKHNlbGYsIGZ1bmMpOlxcbiAgICAgICAgaWYgbm90IHNlbGYuX2hhc19ib2R5KCk6XFxuICAgICAgICAgICAgcmV0dXJuIE5vZGUoKVxcbiAgICAgICAgZm9yIG5vZGUgaW4gc2VsZi50cmVlLmJvZHk6XFxuICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShub2RlLCBhc3QuRnVuY3Rpb25EZWYpOlxcbiAgICAgICAgICAgICAgICBpZiBub2RlLm5hbWUgPT0gZnVuYzpcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOb2RlKG5vZGUpXFxuICAgICAgICByZXR1cm4gTm9kZSgpXFxuXFxuICAgIGRlZiBmaW5kX2Z1bmN0aW9ucyhzZWxmLCBmdW5jKTpcXG4gICAgICAgIHJldHVybiBbXFxuICAgICAgICAgICAgbm9kZVxcbiAgICAgICAgICAgIGZvciBub2RlIGluIHNlbGYuX2ZpbmRfYWxsKChhc3QuRnVuY3Rpb25EZWYsIGFzdC5Bc3luY0Z1bmN0aW9uRGVmKSlcXG4gICAgICAgICAgICBpZiBub2RlLnRyZWUubmFtZSA9PSBmdW5jXFxuICAgICAgICBdXFxuXFxuICAgIGRlZiBmaW5kX2FzeW5jX2Z1bmN0aW9uKHNlbGYsIGZ1bmMpOlxcbiAgICAgICAgaWYgbm90IHNlbGYuX2hhc19ib2R5KCk6XFxuICAgICAgICAgICAgcmV0dXJuIE5vZGUoKVxcbiAgICAgICAgZm9yIG5vZGUgaW4gc2VsZi50cmVlLmJvZHk6XFxuICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShub2RlLCBhc3QuQXN5bmNGdW5jdGlvbkRlZik6XFxuICAgICAgICAgICAgICAgIGlmIG5vZGUubmFtZSA9PSBmdW5jOlxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5vZGUobm9kZSlcXG4gICAgICAgIHJldHVybiBOb2RlKClcXG5cXG4gICAgZGVmIGZpbmRfYXdhaXRzKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIFtcXG4gICAgICAgICAgICBub2RlXFxuICAgICAgICAgICAgZm9yIG5vZGUgaW4gc2VsZi5fZmluZF9hbGwoYXN0LkV4cHIpXFxuICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShub2RlLnRyZWUudmFsdWUsIGFzdC5Bd2FpdClcXG4gICAgICAgIF1cXG5cXG4gICAgZGVmIGhhc19hcmdzKHNlbGYsIGFyZ19zdHIpOlxcbiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2Uoc2VsZi50cmVlLCAoYXN0LkZ1bmN0aW9uRGVmLCBhc3QuQXN5bmNGdW5jdGlvbkRlZikpOlxcbiAgICAgICAgICAgIHJldHVybiBGYWxzZVxcbiAgICAgICAgZGVjX2xpc3QgPSAoZlwiQHtOb2RlKG5vZGUpfVwiIGZvciBub2RlIGluIHNlbGYudHJlZS5kZWNvcmF0b3JfbGlzdClcXG4gICAgICAgIGRlY19zdHIgPSBcIlxcXFxuXCIuam9pbihkZWNfbGlzdCkgKyBcIlxcXFxuXCIgaWYgZGVjX2xpc3QgZWxzZSBcIlwiXFxuICAgICAgICBpZiBpZCA6PSBnZXRhdHRyKHNlbGYudHJlZS5yZXR1cm5zLCBcImlkXCIsIEZhbHNlKTpcXG4gICAgICAgICAgICByZXR1cm5zID0gZlwiIC0+IHtpZH1cIlxcbiAgICAgICAgZWxpZiB2YWwgOj0gZ2V0YXR0cihzZWxmLnRyZWUucmV0dXJucywgXCJ2YWx1ZVwiLCBGYWxzZSk6XFxuICAgICAgICAgICAgcmV0dXJucyA9IGZcIiAtPiBcXCd7dmFsfVxcJ1wiXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJldHVybnMgPSBcIlwiXFxuICAgICAgICBhc3luY19rdyA9IFwiXCJcXG4gICAgICAgIGlmIGlzaW5zdGFuY2Uoc2VsZi50cmVlLCBhc3QuQXN5bmNGdW5jdGlvbkRlZik6XFxuICAgICAgICAgICAgYXN5bmNfa3cgPSBcImFzeW5jIFwiXFxuICAgICAgICBib2R5X2xpbmVzID0gc3RyKHNlbGYuZmluZF9ib2R5KCkpLnNwbGl0KFwiXFxcXG5cIilcXG4gICAgICAgIG5ld19ib2R5ID0gXCJcIi5qb2luKFtmXCJcXFxcbiAge2xpbmV9XCIgZm9yIGxpbmUgaW4gYm9keV9saW5lc10pXFxuICAgICAgICBmdW5jX3N0ciA9IChcXG4gICAgICAgICAgICBmXCJ7ZGVjX3N0cn17YXN5bmNfa3d9ZGVmIHtzZWxmLnRyZWUubmFtZX0oe2FyZ19zdHJ9KXtyZXR1cm5zfTp7bmV3X2JvZHl9XCJcXG4gICAgICAgIClcXG4gICAgICAgIHJldHVybiBzZWxmLmlzX2VxdWl2YWxlbnQoZnVuY19zdHIpXFxuXFxuICAgICMgcmV0dXJuc19zdHIgaXMgdGhlIGFubm90YXRpb24gb2YgdGhlIHR5cGUgcmV0dXJuZWQgYnkgdGhlIGZ1bmN0aW9uXFxuICAgIGRlZiBoYXNfcmV0dXJucyhzZWxmLCByZXR1cm5zX3N0cik6XFxuICAgICAgICBpZiBub3QgaXNpbnN0YW5jZShzZWxmLnRyZWUsIChhc3QuRnVuY3Rpb25EZWYsIGFzdC5Bc3luY0Z1bmN0aW9uRGVmKSk6XFxuICAgICAgICAgICAgcmV0dXJuIEZhbHNlXFxuICAgICAgICBpZiBpc2luc3RhbmNlKHNlbGYudHJlZS5yZXR1cm5zLCBhc3QuTmFtZSk6XFxuICAgICAgICAgICAgcmV0dXJuIHJldHVybnNfc3RyID09IHNlbGYudHJlZS5yZXR1cm5zLmlkXFxuICAgICAgICBlbGlmIGlzaW5zdGFuY2Uoc2VsZi50cmVlLnJldHVybnMsIGFzdC5Db25zdGFudCk6XFxuICAgICAgICAgICAgcmV0dXJuIHJldHVybnNfc3RyID09IHNlbGYudHJlZS5yZXR1cm5zLnZhbHVlXFxuICAgICAgICByZXR1cm4gRmFsc2VcXG5cXG4gICAgZGVmIGZpbmRfYm9keShzZWxmKTpcXG4gICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKHNlbGYudHJlZSwgYXN0LkFTVCk6XFxuICAgICAgICAgICAgcmV0dXJuIE5vZGUoKVxcbiAgICAgICAgaWYgbm90IGhhc2F0dHIoc2VsZi50cmVlLCBcImJvZHlcIik6XFxuICAgICAgICAgICAgcmV0dXJuIE5vZGUoKVxcbiAgICAgICAgcmV0dXJuIE5vZGUoYXN0Lk1vZHVsZShzZWxmLnRyZWUuYm9keSwgW10pKVxcblxcbiAgICAjIGZpbmQgdGhlIHJldHVybiBzdGF0ZW1lbnQgb2YgYSBmdW5jdGlvblxcbiAgICBkZWYgZmluZF9yZXR1cm4oc2VsZik6XFxuICAgICAgICBpZiByZXR1cm5fbGlzdCA6PSBzZWxmLl9maW5kX2FsbChhc3QuUmV0dXJuKTpcXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuX2xpc3RbMF1cXG4gICAgICAgIHJldHVybiBOb2RlKClcXG5cXG4gICAgZGVmIGhhc19yZXR1cm4oc2VsZiwgcmV0dXJuX3ZhbHVlKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmZpbmRfcmV0dXJuKCkuaXNfZXF1aXZhbGVudChmXCJyZXR1cm4ge3JldHVybl92YWx1ZX1cIilcXG5cXG4gICAgZGVmIGZpbmRfaW1wb3J0cyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLl9maW5kX2FsbCgoYXN0LkltcG9ydCwgYXN0LkltcG9ydEZyb20pKVxcblxcbiAgICBkZWYgZmluZF9jb21wcyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBbXFxuICAgICAgICAgICAgbm9kZVxcbiAgICAgICAgICAgIGZvciBub2RlIGluIHNlbGYuX2ZpbmRfYWxsKGFzdC5FeHByKVxcbiAgICAgICAgICAgIGlmIGlzaW5zdGFuY2UoXFxuICAgICAgICAgICAgICAgIG5vZGUudHJlZS52YWx1ZSxcXG4gICAgICAgICAgICAgICAgKGFzdC5MaXN0Q29tcCwgYXN0LlNldENvbXAsIGFzdC5HZW5lcmF0b3JFeHAsIGFzdC5EaWN0Q29tcCksXFxuICAgICAgICAgICAgKVxcbiAgICAgICAgXVxcblxcbiAgICBkZWYgX2ZpbmRfY29tcChcXG4gICAgICAgIHNlbGYsIGNsYXNzZXM9KGFzdC5MaXN0Q29tcCwgYXN0LlNldENvbXAsIGFzdC5HZW5lcmF0b3JFeHAsIGFzdC5EaWN0Q29tcClcXG4gICAgKTpcXG4gICAgICAgIGlmIGlzaW5zdGFuY2Uoc2VsZi50cmVlLCBjbGFzc2VzKTpcXG4gICAgICAgICAgICByZXR1cm4gTm9kZShzZWxmLnRyZWUpXFxuICAgICAgICBlbGlmIGlzaW5zdGFuY2Uoc2VsZi50cmVlLCAoYXN0LkFzc2lnbiwgYXN0LkFubkFzc2lnbiwgYXN0LlJldHVybikpOlxcbiAgICAgICAgICAgIGlmIGlzaW5zdGFuY2Uoc2VsZi50cmVlLnZhbHVlLCBjbGFzc2VzKTpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIE5vZGUoc2VsZi50cmVlLnZhbHVlKVxcbiAgICAgICAgICAgIHJldHVybiBOb2RlKClcXG5cXG4gICAgIyBmaW5kIGEgbGlzdCBvZiBpdGVyYWJsZXMgb2YgYSBjb21wcmVoZW5zaW9uL2dlbmVyYXRvciBleHByZXNzaW9uXFxuICAgIGRlZiBmaW5kX2NvbXBfaXRlcnMoc2VsZik6XFxuICAgICAgICBpZiBub3QgKG5vZGUgOj0gc2VsZi5fZmluZF9jb21wKCkpOlxcbiAgICAgICAgICAgIHJldHVybiBbXVxcbiAgICAgICAgcmV0dXJuIFtOb2RlKGdlbi5pdGVyKSBmb3IgZ2VuIGluIG5vZGUudHJlZS5nZW5lcmF0b3JzXVxcblxcbiAgICAjIGZpbmQgYSBsaXN0IG9mIHRhcmdldHMgKGl0ZXJhdGlvbiB2YXJpYWJsZXMpIG9mIGEgY29tcHJlaGVuc2lvbi9nZW5lcmF0b3IgZXhwcmVzc2lvblxcbiAgICBkZWYgZmluZF9jb21wX3RhcmdldHMoc2VsZik6XFxuICAgICAgICBpZiBub3QgKG5vZGUgOj0gc2VsZi5fZmluZF9jb21wKCkpOlxcbiAgICAgICAgICAgIHJldHVybiBbXVxcbiAgICAgICAgcmV0dXJuIFtOb2RlKGdlbi50YXJnZXQpIGZvciBnZW4gaW4gbm9kZS50cmVlLmdlbmVyYXRvcnNdXFxuXFxuICAgICMgZmluZCB0aGUga2V5IG9mIGEgZGljdGlvbmFyeSBjb21wcmVoZW5zaW9uXFxuICAgIGRlZiBmaW5kX2NvbXBfa2V5KHNlbGYpOlxcbiAgICAgICAgaWYgbm90IChub2RlIDo9IHNlbGYuX2ZpbmRfY29tcChhc3QuRGljdENvbXApKTpcXG4gICAgICAgICAgICByZXR1cm4gTm9kZSgpXFxuICAgICAgICByZXR1cm4gTm9kZShub2RlLnRyZWUua2V5KVxcblxcbiAgICAjIGZpbmQgdGhlIGV4cHJlc3Npb24gZXZhbHVhdGVkIGZvciBhIGNvbXByZWhlbnNpb24vZ2VuZXJhdG9yIGV4cHJlc3Npb25cXG4gICAgIyB3aGljaCBpcyB0aGUgdmFsdWUgb2YgdGhlIGtleSBpbiBjYXNlIG9mIGEgZGljdGlvbmFyeSBjb21wcmVoZW5zaW9uXFxuICAgIGRlZiBmaW5kX2NvbXBfZXhwcihzZWxmKTpcXG4gICAgICAgIGlmIG5vdCAobm9kZSA6PSBzZWxmLl9maW5kX2NvbXAoKSk6XFxuICAgICAgICAgICAgcmV0dXJuIE5vZGUoKVxcbiAgICAgICAgaWYgaXNpbnN0YW5jZShub2RlLnRyZWUsIChhc3QuTGlzdENvbXAsIGFzdC5TZXRDb21wLCBhc3QuR2VuZXJhdG9yRXhwKSk6XFxuICAgICAgICAgICAgcmV0dXJuIE5vZGUobm9kZS50cmVlLmVsdClcXG4gICAgICAgIGVsaWYgaXNpbnN0YW5jZShub2RlLnRyZWUsIGFzdC5EaWN0Q29tcCk6XFxuICAgICAgICAgICAgcmV0dXJuIE5vZGUobm9kZS50cmVlLnZhbHVlKVxcblxcbiAgICAjIGZpbmQgYSBsaXN0IG9mIGBJZkV4cHJgcyBhdCB0aGUgZW5kIG9mIHRoZSBjb21wcmVoZW5zaW9uL2dlbmVyYXRvciBleHByZXNzaW9uXFxuICAgIGRlZiBmaW5kX2NvbXBfaWZzKHNlbGYpOlxcbiAgICAgICAgaWYgbm90IChub2RlIDo9IHNlbGYuX2ZpbmRfY29tcCgpKTpcXG4gICAgICAgICAgICByZXR1cm4gW11cXG4gICAgICAgIHJldHVybiBbXFxuICAgICAgICAgICAgTm9kZShnZW4uaWZzW2ldKVxcbiAgICAgICAgICAgIGZvciBnZW4gaW4gbm9kZS50cmVlLmdlbmVyYXRvcnNcXG4gICAgICAgICAgICBmb3IgaSBpbiByYW5nZShsZW4oZ2VuLmlmcykpXFxuICAgICAgICBdXFxuXFxuICAgICMgXCJoYXNcIiBmdW5jdGlvbnMgcmV0dXJuIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgd2hhdGV2ZXIgaXMgYmVpbmdcXG4gICAgIyBzZWFyY2hlZCBmb3IgZXhpc3RzLiBJbiB0aGlzIGNhc2UsIGl0IHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFyaWFibGUgZXhpc3RzLlxcblxcbiAgICBkZWYgaGFzX3ZhcmlhYmxlKHNlbGYsIG5hbWUpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuZmluZF92YXJpYWJsZShuYW1lKSAhPSBOb2RlKClcXG5cXG4gICAgZGVmIGhhc19pbXBvcnQoc2VsZiwgaW1wb3J0X3N0cik6XFxuICAgICAgICByZXR1cm4gYW55KFxcbiAgICAgICAgICAgIGltcG9ydF9ub2RlLmlzX2VxdWl2YWxlbnQoaW1wb3J0X3N0cikgZm9yIGltcG9ydF9ub2RlIGluIHNlbGYuZmluZF9pbXBvcnRzKClcXG4gICAgICAgIClcXG5cXG4gICAgIyBmaW5kIGEgbGlzdCBvZiBmdW5jdGlvbiBjYWxscyBvZiB0aGUgXFwnbmFtZVxcJyBmdW5jdGlvblxcbiAgICBkZWYgZmluZF9jYWxscyhzZWxmLCBuYW1lKTpcXG4gICAgICAgIGNhbGxfbGlzdCA9IFtdXFxuICAgICAgICBmb3Igbm9kZSBpbiBzZWxmLl9maW5kX2FsbChhc3QuRXhwcik6XFxuICAgICAgICAgICAgaWYgZnVuYyA6PSBnZXRhdHRyKG5vZGUudHJlZS52YWx1ZSwgXCJmdW5jXCIsIEZhbHNlKTpcXG4gICAgICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShmdW5jLCBhc3QuTmFtZSkgYW5kIGZ1bmMuaWQgPT0gbmFtZTpcXG4gICAgICAgICAgICAgICAgICAgIGNhbGxfbGlzdC5hcHBlbmQoTm9kZShub2RlLnRyZWUudmFsdWUpKVxcbiAgICAgICAgICAgICAgICBlbGlmIGlzaW5zdGFuY2UoZnVuYywgYXN0LkF0dHJpYnV0ZSkgYW5kIGZ1bmMuYXR0ciA9PSBuYW1lOlxcbiAgICAgICAgICAgICAgICAgICAgY2FsbF9saXN0LmFwcGVuZChOb2RlKG5vZGUudHJlZS52YWx1ZSkpXFxuICAgICAgICByZXR1cm4gY2FsbF9saXN0XFxuXFxuICAgIGRlZiBoYXNfY2FsbChzZWxmLCBjYWxsKTpcXG4gICAgICAgIHJldHVybiBhbnkobm9kZS5pc19lcXVpdmFsZW50KGNhbGwpIGZvciBub2RlIGluIHNlbGYuX2ZpbmRfYWxsKGFzdC5FeHByKSlcXG5cXG4gICAgZGVmIGZpbmRfY2FsbF9hcmdzKHNlbGYpOlxcbiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2Uoc2VsZi50cmVlLCBhc3QuQ2FsbCk6XFxuICAgICAgICAgICAgcmV0dXJuIFtdXFxuICAgICAgICByZXR1cm4gW05vZGUoYXJnKSBmb3IgYXJnIGluIHNlbGYudHJlZS5hcmdzXVxcblxcbiAgICBkZWYgaGFzX3N0bXQoc2VsZiwgbm9kZV9zdHIpOlxcbiAgICAgICAgaWYgbm90IHNlbGYuX2hhc19ib2R5KCk6XFxuICAgICAgICAgICAgcmV0dXJuIEZhbHNlXFxuICAgICAgICByZXR1cm4gYW55KE5vZGUobm9kZSkuaXNfZXF1aXZhbGVudChub2RlX3N0cikgZm9yIG5vZGUgaW4gc2VsZi50cmVlLmJvZHkpXFxuXFxuICAgIGRlZiBmaW5kX3ZhcmlhYmxlKHNlbGYsIG5hbWUpOlxcbiAgICAgICAgaWYgbm90IHNlbGYuX2hhc19ib2R5KCk6XFxuICAgICAgICAgICAgcmV0dXJuIE5vZGUoKVxcbiAgICAgICAgZm9yIG5vZGUgaW4gc2VsZi50cmVlLmJvZHk6XFxuICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShub2RlLCBhc3QuQXNzaWduKTpcXG4gICAgICAgICAgICAgICAgZm9yIHRhcmdldCBpbiBub2RlLnRhcmdldHM6XFxuICAgICAgICAgICAgICAgICAgICBpZiBpc2luc3RhbmNlKHRhcmdldCwgYXN0Lk5hbWUpOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIHRhcmdldC5pZCA9PSBuYW1lOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTm9kZShub2RlKVxcbiAgICAgICAgICAgICAgICAgICAgaWYgaXNpbnN0YW5jZSh0YXJnZXQsIGFzdC5BdHRyaWJ1dGUpOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzID0gbmFtZS5zcGxpdChcIi5cIilcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiB0YXJnZXQudmFsdWUuaWQgPT0gbmFtZXNbMF0gYW5kIHRhcmdldC5hdHRyID09IG5hbWVzWzFdOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTm9kZShub2RlKVxcbiAgICAgICAgICAgIGVsaWYgaXNpbnN0YW5jZShub2RlLCBhc3QuQW5uQXNzaWduKTpcXG4gICAgICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShub2RlLnRhcmdldCwgYXN0Lk5hbWUpOlxcbiAgICAgICAgICAgICAgICAgICAgaWYgbm9kZS50YXJnZXQuaWQgPT0gbmFtZTpcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTm9kZShub2RlKVxcbiAgICAgICAgcmV0dXJuIE5vZGUoKVxcblxcbiAgICAjIGZpbmQgdmFyaWFibGUgaW5jcmVtZW50ZWQgb3IgZGVjcmVtZW50ZWQgdXNpbmcgKz0gb3IgLT1cXG4gICAgZGVmIGZpbmRfYXVnX3ZhcmlhYmxlKHNlbGYsIG5hbWUpOlxcbiAgICAgICAgaWYgbm90IHNlbGYuX2hhc19ib2R5KCk6XFxuICAgICAgICAgICAgcmV0dXJuIE5vZGUoKVxcbiAgICAgICAgZm9yIG5vZGUgaW4gc2VsZi50cmVlLmJvZHk6XFxuICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShub2RlLCBhc3QuQXVnQXNzaWduKTpcXG4gICAgICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShub2RlLnRhcmdldCwgYXN0Lk5hbWUpOlxcbiAgICAgICAgICAgICAgICAgICAgaWYgbm9kZS50YXJnZXQuaWQgPT0gbmFtZTpcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTm9kZShub2RlKVxcbiAgICAgICAgcmV0dXJuIE5vZGUoKVxcblxcbiAgICBkZWYgZ2V0X3ZhcmlhYmxlKHNlbGYsIG5hbWUpOlxcbiAgICAgICAgdmFyID0gc2VsZi5maW5kX3ZhcmlhYmxlKG5hbWUpXFxuICAgICAgICBpZiB2YXIgIT0gTm9kZSgpOlxcbiAgICAgICAgICAgIHJldHVybiB2YXIudHJlZS52YWx1ZS52YWx1ZVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gTm9uZVxcblxcbiAgICBkZWYgaGFzX2Z1bmN0aW9uKHNlbGYsIG5hbWUpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuZmluZF9mdW5jdGlvbihuYW1lKSAhPSBOb2RlKClcXG5cXG4gICAgZGVmIGhhc19jbGFzcyhzZWxmLCBuYW1lKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmZpbmRfY2xhc3MobmFtZSkgIT0gTm9kZSgpXFxuXFxuICAgIGRlZiBoYXNfZGVjb3JhdG9ycyhzZWxmLCAqYXJncyk6XFxuICAgICAgICAjIHRoZSBvcmRlciBvZiBhcmdzIGRvZXMgbWF0dGVyXFxuICAgICAgICBpZiBub3QgaXNpbnN0YW5jZShzZWxmLnRyZWUsIChhc3QuRnVuY3Rpb25EZWYsIGFzdC5Bc3luY0Z1bmN0aW9uRGVmKSk6XFxuICAgICAgICAgICAgcmV0dXJuIEZhbHNlXFxuICAgICAgICBkZWNfbGlzdCA9IChOb2RlKG5vZGUpIGZvciBub2RlIGluIHNlbGYudHJlZS5kZWNvcmF0b3JfbGlzdClcXG4gICAgICAgIHJldHVybiBhbGwoYW55KGRlYy5pc19lcXVpdmFsZW50KGFyZykgZm9yIGRlYyBpbiBkZWNfbGlzdCkgZm9yIGFyZyBpbiBhcmdzKVxcblxcbiAgICAjIENoZWNrcyBpZiB0aGUgY3VycmVudCBzY29wZSBjb250YWlucyBhIFwicGFzc1wiIHN0YXRlbWVudFxcblxcbiAgICBkZWYgaGFzX3Bhc3Moc2VsZik6XFxuICAgICAgICBpZiBpc2luc3RhbmNlKHNlbGYudHJlZSwgKGFzdC5JZiwgYXN0LldoaWxlLCBhc3QuRm9yKSk6XFxuICAgICAgICAgICAgcmV0dXJuIEZhbHNlXFxuICAgICAgICBpZiBnZXRhdHRyKHNlbGYudHJlZSwgXCJib2R5XCIsIEZhbHNlKTpcXG4gICAgICAgICAgICByZXR1cm4gYW55KGlzaW5zdGFuY2Uobm9kZSwgYXN0LlBhc3MpIGZvciBub2RlIGluIHNlbGYudHJlZS5ib2R5KVxcbiAgICAgICAgcmV0dXJuIEZhbHNlXFxuXFxuICAgICMgQ2hlY2tzIHRoZSB2YXJpYWJsZSwgbmFtZSwgaXMgaW4gdGhlIGN1cnJlbnQgc2NvcGUgYW5kIGlzIGFuIGludGVnZXJcXG5cXG4gICAgZGVmIGlzX2ludGVnZXIoc2VsZik6XFxuICAgICAgICBpZiBub3QgaXNpbnN0YW5jZShzZWxmLnRyZWUsIGFzdC5Bc3NpZ24pOlxcbiAgICAgICAgICAgIHJldHVybiBGYWxzZVxcbiAgICAgICAgcmV0dXJuIHR5cGUoc2VsZi50cmVlLnZhbHVlLnZhbHVlKSA9PSB0eXBlKDEpXFxuXFxuICAgIGRlZiB2YWx1ZV9pc19jYWxsKHNlbGYsIG5hbWUpOlxcbiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2Uoc2VsZi50cmVlLCBhc3QuQXNzaWduKTpcXG4gICAgICAgICAgICByZXR1cm4gRmFsc2VcXG4gICAgICAgIGNhbGwgPSBzZWxmLnRyZWUudmFsdWVcXG4gICAgICAgIGlmIGlzaW5zdGFuY2UoY2FsbCwgYXN0LkNhbGwpOlxcbiAgICAgICAgICAgIHJldHVybiBjYWxsLmZ1bmMuaWQgPT0gbmFtZVxcbiAgICAgICAgcmV0dXJuIEZhbHNlXFxuXFxuICAgICMgTG9vc2VseSBjb21wYXJlcyB0aGUgY29kZSBpbiB0YXJnZXRfc3RyIHdpdGggdGhlIGNvZGUgcmVwcmVzZW50ZWQgYnkgdGhlXFxuICAgICMgTm9kZVxcJ3MgQVNULiBJZiB0aGUgdHdvIGNvZGVzIGFyZSBzZW1hbnRpY2FsbHkgZXF1aXZhbGVudCAoaS5lLiB0aGUgc2FtZSBpZlxcbiAgICAjIHlvdSBpZ25vcmUgZm9ybWF0dGluZyBhbmQgY29udGV4dCkgdGhlbiB0aGlzIHJldHVybnMgVHJ1ZSwgb3RoZXJ3aXNlXFxuICAgICMgRmFsc2UuXFxuICAgICNcXG4gICAgIyBJZ25vcmluZyBjb250ZXh0IG1lYW5zIHRoYXQgdGhlIGZvbGxvd2luZyBjb21wYXJpc29uIGlzIFRydWUgZGVzcGl0ZSB0aGVcXG4gICAgIyBmYWN0IHRoYXQgdGhlIEFTVCBvZiBgY29uZF9ub2RlYCBpcyBgQ29uc3RhbnQodmFsdWU9VHJ1ZSlgIGFuZCBgVHJ1ZWBcXG4gICAgIyBjb21waWxlcyB0byBgTW9kdWxlKGJvZHk9W0V4cHIodmFsdWU9Q29uc3RhbnQodmFsdWU9VHJ1ZSkpXSxcXG4gICAgIyB0eXBlX2lnbm9yZXM9W10pYDpcXG4gICAgI1xcbiAgICAjIG5vZGUgPSBOb2RlKFwiaWYgVHJ1ZTpcXFxcbiAgcGFzc1wiKSBjb25kX25vZGUgPVxcbiAgICAjIG5vZGUuZmluZF9pZnMoKVswXS5maW5kX2NvbmRpdGlvbnMoKVswXSBjb25kX25vZGUuaXNfZXF1aXZhbGVudChcIlRydWVcIilcXG5cXG4gICAgZGVmIGlzX2VxdWl2YWxlbnQoc2VsZiwgdGFyZ2V0X3N0cik6XFxuICAgICAgICAjIFNldHRpbmcgdGhlIHRyZWUgdG8gTm9uZSBpcyB1c2VkIHRvIHJlcHJlc2VudCBtaXNzaW5nIGVsZW1lbnRzLiBTdWNoXFxuICAgICAgICAjIGFzIHRoZSBjb25kaXRpb24gb2YgYSBmaW5hbCBlbHNlIGNsYXVzZS4gSXQgaXMsIHRoZXJlZm9yZSwgbm90XFxuICAgICAgICAjIGVxdWl2YWxlbnQgdG8gYW55IHN0cmluZy5cXG4gICAgICAgIGlmIHNlbGYudHJlZSA9PSBOb25lOlxcbiAgICAgICAgICAgIHJldHVybiBGYWxzZVxcbiAgICAgICAgY29kZV9zdHIgPSBhc3QudW5wYXJzZShzZWxmLnRyZWUpXFxuXFxuICAgICAgICAjIFdoeSBwYXJzZSBhbmQgdW5wYXJzZSBhZ2Fpbj8gQmVjYXVzZSBvZiBhbiBlZGdlIGNhc2Ugd2hlbiBjb21wYXJpbmdcXG4gICAgICAgICMgdGhlIGB0YXJnZXRfc3RyYCBcIlxcJ1RydWVcXCdcIiB3aXRoIHRoZSB0ZXN0IGluIFwiaWYgXFwnVHJ1ZVxcJzpcIi4gVGhlc2Ugc2hvdWxkXFxuICAgICAgICAjIGJlIGVxdWl2YWxlbnQsIGJ1dCB0aGUgY29uZGl0aW9uIHVucGFyc2VzIHRvIFwiXFwnVHJ1ZVxcJ1wiLCB3aGlsZSB0aGVcXG4gICAgICAgICMgYHRhcmdldF9zdHJgIGJlY29tZXMgXFwnXCJcIlwiVHJ1ZVwiXCJcIlxcJyB3aGVuIHBhcnNlZCBhbmQgdW5wYXJzZWQgYWdhaW4uXFxuXFxuICAgICAgICAjIEJ5IHBhcnNpbmcgYW5kIHVucGFyc2luZyBgY29kZV9zdHJgIHdlIGdldCBcXCdcIlwiXCJUcnVlXCJcIlwiXFwnIGFuZCB0aGVcXG4gICAgICAgICMgY29tcGFyaXNvbiByZXR1cm5zIFRydWUgYXMgZXhwZWN0ZWQuXFxuICAgICAgICByZXR1cm4gYXN0LnVucGFyc2UoYXN0LnBhcnNlKGNvZGVfc3RyKSkgPT0gYXN0LnVucGFyc2UoYXN0LnBhcnNlKHRhcmdldF9zdHIpKVxcblxcbiAgICBkZWYgaXNfZW1wdHkoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi50cmVlID09IE5vbmVcXG5cXG4gICAgIyBGaW5kcyB0aGUgY2xhc3MgZGVmaW5pdGlvbiB3aXRoIHRoZSBnaXZlbiBuYW1lXFxuXFxuICAgIGRlZiBmaW5kX2NsYXNzKHNlbGYsIGNsYXNzX25hbWUpOlxcbiAgICAgICAgaWYgbm90IHNlbGYuX2hhc19ib2R5KCk6XFxuICAgICAgICAgICAgcmV0dXJuIE5vZGUoKVxcbiAgICAgICAgZm9yIG5vZGUgaW4gc2VsZi50cmVlLmJvZHk6XFxuICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShub2RlLCBhc3QuQ2xhc3NEZWYpOlxcbiAgICAgICAgICAgICAgICBpZiBub2RlLm5hbWUgPT0gY2xhc3NfbmFtZTpcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOb2RlKG5vZGUpXFxuICAgICAgICByZXR1cm4gTm9kZSgpXFxuXFxuICAgIGRlZiBpbmhlcml0c19mcm9tKHNlbGYsICphcmdzKTpcXG4gICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKHNlbGYudHJlZSwgYXN0LkNsYXNzRGVmKTpcXG4gICAgICAgICAgICByZXR1cm4gRmFsc2VcXG4gICAgICAgIGlmIG5vdCBzZWxmLnRyZWUuYmFzZXM6XFxuICAgICAgICAgICAgcmV0dXJuIEZhbHNlXFxuICAgICAgICBpZF9saXN0ID0gW25vZGUuaWQgZm9yIG5vZGUgaW4gc2VsZi50cmVlLmJhc2VzXVxcbiAgICAgICAgcmV0dXJuIGFsbChhcmcgaW4gaWRfbGlzdCBmb3IgYXJnIGluIGFyZ3MpXFxuXFxuICAgICMgRmluZCBhbiBhcnJheSBvZiBjb25kaXRpb25zIGluIGFuIGlmIHN0YXRlbWVudFxcblxcbiAgICBkZWYgZmluZF9pZnMoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5fZmluZF9hbGwoYXN0LklmKVxcblxcbiAgICBkZWYgX2ZpbmRfYWxsKHNlbGYsIGFzdF90eXBlKTpcXG4gICAgICAgIHJldHVybiBbTm9kZShub2RlKSBmb3Igbm9kZSBpbiBzZWxmLnRyZWUuYm9keSBpZiBpc2luc3RhbmNlKG5vZGUsIGFzdF90eXBlKV1cXG5cXG4gICAgZGVmIGZpbmRfd2hpbGVzKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2ZpbmRfYWxsKGFzdC5XaGlsZSlcXG5cXG4gICAgZGVmIGZpbmRfZm9yX2xvb3BzKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2ZpbmRfYWxsKGFzdC5Gb3IpXFxuXFxuICAgIGRlZiBmaW5kX2Zvcl92YXJzKHNlbGYpOlxcbiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2Uoc2VsZi50cmVlLCBhc3QuRm9yKTpcXG4gICAgICAgICAgICByZXR1cm4gTm9kZSgpXFxuICAgICAgICByZXR1cm4gTm9kZShzZWxmLnRyZWUudGFyZ2V0KVxcblxcbiAgICBkZWYgZmluZF9mb3JfaXRlcihzZWxmKTpcXG4gICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKHNlbGYudHJlZSwgYXN0LkZvcik6XFxuICAgICAgICAgICAgcmV0dXJuIE5vZGUoKVxcbiAgICAgICAgcmV0dXJuIE5vZGUoc2VsZi50cmVlLml0ZXIpXFxuXFxuICAgIGRlZiBmaW5kX2lmKHNlbGYsIGlmX3N0cik6XFxuICAgICAgICBpZl9saXN0ID0gc2VsZi5fZmluZF9hbGwoYXN0LklmKVxcbiAgICAgICAgZm9yIGlmX3N0YXRlbWVudCBpbiBpZl9saXN0OlxcbiAgICAgICAgICAgIGlmIGlmX3N0YXRlbWVudC5maW5kX2NvbmRpdGlvbnMoKVswXS5pc19lcXVpdmFsZW50KGlmX3N0cik6XFxuICAgICAgICAgICAgICAgIHJldHVybiBpZl9zdGF0ZW1lbnRcXG4gICAgICAgIHJldHVybiBOb2RlKClcXG5cXG4gICAgZGVmIGZpbmRfd2hpbGUoc2VsZiwgd2hpbGVfc3RyKTpcXG4gICAgICAgIHdoaWxlX2xpc3QgPSBzZWxmLl9maW5kX2FsbChhc3QuV2hpbGUpXFxuICAgICAgICBmb3Igd2hpbGVfbG9vcCBpbiB3aGlsZV9saXN0OlxcbiAgICAgICAgICAgIGlmIHdoaWxlX2xvb3AuZmluZF9jb25kaXRpb25zKClbMF0uaXNfZXF1aXZhbGVudCh3aGlsZV9zdHIpOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gd2hpbGVfbG9vcFxcbiAgICAgICAgcmV0dXJuIE5vZGUoKVxcblxcbiAgICBkZWYgZmluZF9mb3Ioc2VsZiwgdGFyZ2V0X3N0ciwgaXRlcl9zdHIpOlxcbiAgICAgICAgZm9yX2xpc3QgPSBzZWxmLl9maW5kX2FsbChhc3QuRm9yKVxcbiAgICAgICAgZm9yIGZvcl9sb29wIGluIGZvcl9saXN0OlxcbiAgICAgICAgICAgIGlmIGZvcl9sb29wLmZpbmRfZm9yX3ZhcnMoKS5pc19lcXVpdmFsZW50KFxcbiAgICAgICAgICAgICAgICB0YXJnZXRfc3RyXFxuICAgICAgICAgICAgKSBhbmQgZm9yX2xvb3AuZmluZF9mb3JfaXRlcigpLmlzX2VxdWl2YWxlbnQoaXRlcl9zdHIpOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9yX2xvb3BcXG4gICAgICAgIHJldHVybiBOb2RlKClcXG5cXG4gICAgIyBGaW5kIGFuIGFycmF5IG9mIGJvZGllcyBpbiBpZi9lbGlmIHN0YXRlbWVudCBhbmQgd2hpbGUgb3IgZm9yIGxvb3BzXFxuXFxuICAgIGRlZiBmaW5kX2JvZGllcyhzZWxmKTpcXG4gICAgICAgIGRlZiBfZmluZF9ib2RpZXModHJlZSk6XFxuICAgICAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UodHJlZSwgKGFzdC5JZiwgYXN0LldoaWxlLCBhc3QuRm9yKSk6XFxuICAgICAgICAgICAgICAgIHJldHVybiBbXVxcbiAgICAgICAgICAgIGlmIHRyZWUub3JlbHNlID09IFtdOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gW3RyZWUuYm9keV1cXG4gICAgICAgICAgICBpZiBpc2luc3RhbmNlKHRyZWUub3JlbHNlWzBdLCAoYXN0LklmLCBhc3QuV2hpbGUsIGFzdC5Gb3IpKTpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0cmVlLmJvZHldICsgX2ZpbmRfYm9kaWVzKHRyZWUub3JlbHNlWzBdKVxcblxcbiAgICAgICAgICAgIHJldHVybiBbdHJlZS5ib2R5XSArIFt0cmVlLm9yZWxzZV1cXG5cXG4gICAgICAgIHJldHVybiBbTm9kZShhc3QuTW9kdWxlKGJvZHksIFtdKSkgZm9yIGJvZHkgaW4gX2ZpbmRfYm9kaWVzKHNlbGYudHJlZSldXFxuXFxuICAgICMgRmluZCBhbiBhcnJheSBvZiBjb25kaXRpb25zIGluIGlmL2VsaWYgc3RhdGVtZW50IG9yIHdoaWxlIGxvb3BcXG5cXG4gICAgZGVmIGZpbmRfY29uZGl0aW9ucyhzZWxmKTpcXG4gICAgICAgIGRlZiBfZmluZF9jb25kaXRpb25zKHRyZWUpOlxcbiAgICAgICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKHRyZWUsIChhc3QuSWYsIGFzdC5XaGlsZSkpOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gW11cXG4gICAgICAgICAgICB0ZXN0ID0gdHJlZS50ZXN0XFxuICAgICAgICAgICAgaWYgdHJlZS5vcmVsc2UgPT0gW106XFxuICAgICAgICAgICAgICAgIHJldHVybiBbdGVzdF1cXG4gICAgICAgICAgICBpZiBpc2luc3RhbmNlKHRyZWUub3JlbHNlWzBdLCAoYXN0LklmLCBhc3QuV2hpbGUpKTpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0ZXN0XSArIF9maW5kX2NvbmRpdGlvbnModHJlZS5vcmVsc2VbMF0pXFxuXFxuICAgICAgICAgICAgcmV0dXJuIFt0ZXN0LCBOb25lXVxcblxcbiAgICAgICAgcmV0dXJuIFtOb2RlKHRlc3QpIGZvciB0ZXN0IGluIF9maW5kX2NvbmRpdGlvbnMoc2VsZi50cmVlKV1cXG5cXG4gICAgIyBSZXR1cnMgYSBCb29sZWFuIGluZGljYXRpbmcgaWYgdGhlIHN0YXRlbWVudHMgcGFzc2VkIGFzIGFyZ3VtZW50c1xcbiAgICAjIGFyZSBmb3VuZCBpbiB0aGUgc2FtZSBvcmRlciBpbiB0aGUgdHJlZSAoc3RhdGVtZW50cyBjYW4gYmUgbm9uLWNvbnNlY3V0aXZlKVxcbiAgICBkZWYgaXNfb3JkZXJlZChzZWxmLCAqYXJncyk6XFxuICAgICAgICBpZiBub3Qgc2VsZi5faGFzX2JvZHkoKTpcXG4gICAgICAgICAgICByZXR1cm4gRmFsc2VcXG4gICAgICAgIGlmIGxlbihhcmdzKSA8IDI6XFxuICAgICAgICAgICAgcmV0dXJuIEZhbHNlXFxuICAgICAgICBhcmdfZGljdCA9IHtrZXk6IE5vbmUgZm9yIGtleSBpbiByYW5nZShsZW4oYXJncykpfVxcbiAgICAgICAgZm9yIGksIG5vZGUgaW4gZW51bWVyYXRlKHNlbGYudHJlZS5ib2R5KTpcXG4gICAgICAgICAgICBmb3IgaiwgYXJnIGluIGVudW1lcmF0ZShhcmdzKTpcXG4gICAgICAgICAgICAgICAgaWYgTm9kZShub2RlKS5pc19lcXVpdmFsZW50KGFyZyk6XFxuICAgICAgICAgICAgICAgICAgICBhcmdfZGljdFtqXSA9IGlcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICBpZiBOb25lIGluIGFyZ19kaWN0LnZhbHVlcygpOlxcbiAgICAgICAgICAgIHJldHVybiBGYWxzZVxcbiAgICAgICAgcmV0dXJuIGFsbChhcmdfZGljdFtuXSA8IGFyZ19kaWN0W24gKyAxXSBmb3IgbiBpbiByYW5nZShsZW4oYXJnX2RpY3QpIC0gMSkpXFxuXFxuXFxuIyBFeGNlcHRpb24gZm9ybWF0dGluZyBmdW5jdGlvbnMuIEN1cnJlbnRseSBidW5kbGVkIHdpdGggdGhlIE5vZGUgY2xhc3MsIHVudGlsXFxuIyB3ZSBpbXByb3ZlIHRoZSB0ZXN0aW5nLCBidWlsZGluZyBhbmQgQ0kgc28gdGhhdCB0aGV5IGNhbiBlYXNpbHkgaGFuZGxlXFxuIyBtdWx0aXBsZSBmaWxlcy5cXG5cXG5cXG5kZWYgZHJvcF91bnRpbCgqLCB0cmFjZXMsIGZpbGVuYW1lKTpcXG4gICAgZnJvbSBpdGVydG9vbHMgaW1wb3J0IGRyb3B3aGlsZVxcblxcbiAgICByZXR1cm4gbGlzdChcXG4gICAgICAgIGRyb3B3aGlsZShsYW1iZGEgbGluZTogbm90IGxpbmUuc3RhcnRzd2l0aChmXFwnICBGaWxlIFwie2ZpbGVuYW1lfVwiXFwnKSwgdHJhY2VzKVxcbiAgICApXFxuXFxuXFxuZGVmIGJ1aWxkX21lc3NhZ2UoKiwgdHJhY2VzLCBleGNlcHRpb25fbGlzdCk6XFxuICAgIHJldHVybiBcIlwiLmpvaW4oW1wiVHJhY2ViYWNrIChtb3N0IHJlY2VudCBjYWxsIGxhc3QpOlxcXFxuXCJdICsgdHJhY2VzICsgZXhjZXB0aW9uX2xpc3QpXFxuXFxuXFxuZGVmIF9yZXBsYWNlX3N0YXJ0c3dpdGgoc3RyaW5nLCBvbGQsIG5ldyk6XFxuICAgIGlmIHN0cmluZy5zdGFydHN3aXRoKG9sZCk6XFxuICAgICAgICByZXR1cm4gbmV3ICsgc3RyaW5nW2xlbihvbGQpIDpdXFxuICAgIHJldHVybiBzdHJpbmdcXG5cXG5cXG5kZWYgZm9ybWF0X2V4Y2VwdGlvbigqLCBleGNlcHRpb24sIHRyYWNlYmFjaywgZmlsZW5hbWUsIG5ld19maWxlbmFtZT1Ob25lKTpcXG4gICAgaWYgbmV3X2ZpbGVuYW1lIGlzIE5vbmU6XFxuICAgICAgICBuZXdfZmlsZW5hbWUgPSBmaWxlbmFtZVxcbiAgICBmcm9tIHRyYWNlYmFjayBpbXBvcnQgZm9ybWF0X2V4Y2VwdGlvbl9vbmx5LCBmb3JtYXRfdGJcXG5cXG4gICAgIyBUaGUgdHJhY2UgdXAgdG8gXCJmaWxlbmFtZVwiIGFyZSB0aGUgZnJhbWVzIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIHRoZSB1c2VyXFwnc1xcbiAgICAjIGNvZGUgc28gd2UgZHJvcCB0aGVtLlxcbiAgICB0cmFjZXMgPSBkcm9wX3VudGlsKHRyYWNlcz1mb3JtYXRfdGIodHJhY2ViYWNrKSwgZmlsZW5hbWU9ZmlsZW5hbWUpXFxuICAgIHJlbmFtZWRfdHJhY2VzID0gW1xcbiAgICAgICAgX3JlcGxhY2Vfc3RhcnRzd2l0aCh0cmFjZSwgZlxcJyAgRmlsZSBcIntmaWxlbmFtZX1cIlxcJywgZlxcJyAgRmlsZSBcIntuZXdfZmlsZW5hbWV9XCJcXCcpXFxuICAgICAgICBmb3IgdHJhY2UgaW4gdHJhY2VzXFxuICAgIF1cXG4gICAgcmVuYW1lZF9leGNlcHRpb24gPSBbXFxuICAgICAgICBfcmVwbGFjZV9zdGFydHN3aXRoKGUsIGZcXCcgIEZpbGUgXCJ7ZmlsZW5hbWV9XCJcXCcsIGZcXCcgIEZpbGUgXCJ7bmV3X2ZpbGVuYW1lfVwiXFwnKVxcbiAgICAgICAgZm9yIGUgaW4gZm9ybWF0X2V4Y2VwdGlvbl9vbmx5KGV4Y2VwdGlvbilcXG4gICAgXVxcbiAgICByZXR1cm4gYnVpbGRfbWVzc2FnZSh0cmFjZXM9cmVuYW1lZF90cmFjZXMsIGV4Y2VwdGlvbl9saXN0PXJlbmFtZWRfZXhjZXB0aW9uKVxcbicsZ2V0RGVmKGUsbil7Y29uc3QgdD1uZXcgUmVnRXhwKGBcXFxcbj8oPzxmdW5jdGlvbl9pbmRlbnRhdGlvbj4gKj8pZGVmICske259ICpcXFxcKCg/PGZ1bmN0aW9uX3BhcmFtZXRlcnM+W15cXFxcKV0qKVxcXFwpXFxcXHMqOlxcXFxzKj9cXFxcbj8oPzxmdW5jdGlvbl9ib2R5Pi4qPykoPz1cXFxcblxcXFxrPGZ1bmN0aW9uX2luZGVudGF0aW9uPltcXFxcdyNdfCQpYCxcInNcIikuZXhlYyhlKTtpZih0KXtjb25zdHtmdW5jdGlvbl9wYXJhbWV0ZXJzOmUsZnVuY3Rpb25fYm9keTpuLGZ1bmN0aW9uX2luZGVudGF0aW9uOnJ9PXQuZ3JvdXBzLHM9ci5yZXBsYWNlKC9cXG4rLyxcIlwiKTtyZXR1cm57ZGVmOnRbMF0ucmVwbGFjZSgvXlxcbi8sXCJcIiksZnVuY3Rpb25fcGFyYW1ldGVyczplLGZ1bmN0aW9uX2JvZHk6bixmdW5jdGlvbl9pbmRlbnRhdGlvbjpzLmxlbmd0aH19cmV0dXJuIG51bGx9LHJlbW92ZUNvbW1lbnRzOmU9PmUucmVwbGFjZSgvXFwvXFwvLip8XFwvXFwqW1xcc1xcU10qP1xcKlxcL3woIy4qJCkvZ20sXCJcIiksZ2V0QmxvY2soZSxuKXtjb25zdCB0PW4gaW5zdGFuY2VvZiBSZWdFeHA/bi5zb3VyY2U6bi5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZyxcIlxcXFwkJlwiKSxyPW5ldyBSZWdFeHAoYFxcXFxuPyg/PGJsb2NrX2luZGVudGF0aW9uPiAqPykoPzxibG9ja19jb25kaXRpb24+JHt0fSlcXFxccyo6XFxcXHMqP1xcXFxuKD88YmxvY2tfYm9keT4oXFxcXGs8YmxvY2tfaW5kZW50YXRpb24+ICtbXlxcXFxuXSp8ICpcXFxcbikrKShcXG58JClgLFwic21cIikuZXhlYyhlKTtpZihyKXtjb25zdHtibG9ja19ib2R5OmUsYmxvY2tfaW5kZW50YXRpb246bixibG9ja19jb25kaXRpb246dH09ci5ncm91cHM7cmV0dXJue2Jsb2NrX2JvZHk6ZSxibG9ja19jb25kaXRpb246dCxibG9ja19pbmRlbnRhdGlvbjpuLnJlcGxhY2UoL1xcbisvZyxcIlwiKS5sZW5ndGh9fXJldHVybiBudWxsfX07Y2xhc3MgeXtjb25zdHJ1Y3RvcihlKXt0aGlzLmRvYz1lfV9nZXRTdHlsZVJ1bGVzKCl7Y29uc3QgZT10aGlzLmdldFN0eWxlU2hlZXQoKTtyZXR1cm4gdGhpcy5zdHlsZVNoZWV0VG9Dc3NSdWxlc0FycmF5KGUpLmZpbHRlcigoZT0+ZS50eXBlPT09Q1NTUnVsZS5TVFlMRV9SVUxFKSl9Z2V0U3R5bGVEZWNsYXJhdGlvbnMoZSl7dmFyIG47cmV0dXJuIG51bGw9PT0obj10aGlzLl9nZXRTdHlsZVJ1bGVzKCkpfHx2b2lkIDA9PT1uP3ZvaWQgMDpuLmZpbHRlcigobj0+KG51bGw9PW4/dm9pZCAwOm4uc2VsZWN0b3JUZXh0KT09PWUpKS5tYXAoKGU9PmUuc3R5bGUpKX1nZXRTdHlsZShlKXt2YXIgbjtjb25zdCB0PW51bGw9PT0obj10aGlzLl9nZXRTdHlsZVJ1bGVzKCkuZmluZCgobj0+KG51bGw9PW4/dm9pZCAwOm4uc2VsZWN0b3JUZXh0KT09PWUpKSl8fHZvaWQgMD09PW4/dm9pZCAwOm4uc3R5bGU7cmV0dXJuIHQ/KHQuZ2V0UHJvcFZhbD0oZSxuPSExKT0+bj90LmdldFByb3BlcnR5VmFsdWUoZSkucmVwbGFjZSgvXFxzKy9nLFwiXCIpOnQuZ2V0UHJvcGVydHlWYWx1ZShlKSx0KTpudWxsfWdldFN0eWxlQW55KGUpe2Zvcihjb25zdCBuIG9mIGUpe2NvbnN0IGU9dGhpcy5nZXRTdHlsZShuKTtpZihlKXJldHVybiBlfXJldHVybiBudWxsfWdldFN0eWxlUnVsZShlKXt2YXIgbjtjb25zdCB0PW51bGw9PT0obj10aGlzLl9nZXRTdHlsZVJ1bGVzKCkpfHx2b2lkIDA9PT1uP3ZvaWQgMDpuLmZpbmQoKG49PihudWxsPT1uP3ZvaWQgMDpuLnNlbGVjdG9yVGV4dCk9PT1lKSk7cmV0dXJuIHQ/T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtpc0RlY2xhcmVkQWZ0ZXI6ZT0+KGU9Pm49Pnt2YXIgdCxyLHMsaTtjb25zdCBvPShudWxsPT09KHI9QXJyYXkuZnJvbSgobnVsbD09PSh0PWUucGFyZW50U3R5bGVTaGVldCl8fHZvaWQgMD09PXQ/dm9pZCAwOnQuY3NzUnVsZXMpfHxbXSkpfHx2b2lkIDA9PT1yP3ZvaWQgMDpyLmZpbHRlcigoZT0+ZS50eXBlPT09Q1NTUnVsZS5TVFlMRV9SVUxFKSkpLmZpbmQoKGU9PihudWxsPT1lP3ZvaWQgMDplLnNlbGVjdG9yVGV4dCk9PT1uKSk7cmV0dXJuISFvJiZBcnJheS5mcm9tKChudWxsPT09KHM9ZS5wYXJlbnRTdHlsZVNoZWV0KXx8dm9pZCAwPT09cz92b2lkIDA6cy5jc3NSdWxlcyl8fFtdKS5pbmRleE9mKGUpPkFycmF5LmZyb20oKG51bGw9PT0oaT1udWxsPT1vP3ZvaWQgMDpvLnBhcmVudFN0eWxlU2hlZXQpfHx2b2lkIDA9PT1pP3ZvaWQgMDppLmNzc1J1bGVzKXx8W10pLmluZGV4T2Yobyl9KSh0KShlKX0pOm51bGx9Z2V0Q1NTUnVsZXMoZSl7Y29uc3Qgbj10aGlzLmdldFN0eWxlU2hlZXQoKSx0PXRoaXMuc3R5bGVTaGVldFRvQ3NzUnVsZXNBcnJheShuKTtzd2l0Y2goZSl7Y2FzZVwibWVkaWFcIjpyZXR1cm4gdC5maWx0ZXIoKGU9PmUudHlwZT09PUNTU1J1bGUuTUVESUFfUlVMRSkpO2Nhc2VcImZvbnRmYWNlXCI6cmV0dXJuIHQuZmlsdGVyKChlPT5lLnR5cGU9PT1DU1NSdWxlLkZPTlRfRkFDRV9SVUxFKSk7Y2FzZVwiaW1wb3J0XCI6cmV0dXJuIHQuZmlsdGVyKChlPT5lLnR5cGU9PT1DU1NSdWxlLklNUE9SVF9SVUxFKSk7Y2FzZVwia2V5ZnJhbWVzXCI6cmV0dXJuIHQuZmlsdGVyKChlPT5lLnR5cGU9PT1DU1NSdWxlLktFWUZSQU1FU19SVUxFKSk7ZGVmYXVsdDpyZXR1cm4gdH19aXNQcm9wZXJ0eVVzZWQoZSl7cmV0dXJuIHRoaXMuX2dldFN0eWxlUnVsZXMoKS5zb21lKChuPT57dmFyIHQ7cmV0dXJuIG51bGw9PT0odD1uLnN0eWxlKXx8dm9pZCAwPT09dD92b2lkIDA6dC5nZXRQcm9wZXJ0eVZhbHVlKGUpfSkpfWdldFJ1bGVMaXN0c1dpdGhpbk1lZGlhKGUpe2NvbnN0IG49dGhpcy5nZXRDU1NSdWxlcyhcIm1lZGlhXCIpLHQ9bnVsbD09bj92b2lkIDA6bi5maW5kKChuPT57dmFyIHQ7cmV0dXJuKG51bGw9PT0odD1udWxsPT1uP3ZvaWQgMDpuLm1lZGlhKXx8dm9pZCAwPT09dD92b2lkIDA6dC5tZWRpYVRleHQpPT09ZX0pKSxyPW51bGw9PXQ/dm9pZCAwOnQuY3NzUnVsZXM7cmV0dXJuIEFycmF5LmZyb20ocnx8W10pfWdldFN0eWxlU2hlZXQoKXt2YXIgZSxuLHQscixzO2NvbnN0IGk9bnVsbD09PShlPXRoaXMuZG9jKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5xdWVyeVNlbGVjdG9yKFwibGlua1tocmVmKj0nc3R5bGVzJ11cIiksbz1udWxsPT09KG49dGhpcy5kb2MpfHx2b2lkIDA9PT1uP3ZvaWQgMDpuLnF1ZXJ5U2VsZWN0b3IoXCJzdHlsZS5mY2MtaW5qZWN0ZWQtc3R5bGVzXCIpLGE9bnVsbD09PSh0PXRoaXMuZG9jKXx8dm9pZCAwPT09dD92b2lkIDA6dC5xdWVyeVNlbGVjdG9yKFwic3R5bGU6bm90KFtjbGFzc10pOm5vdChbbWVkaWFdKVwiKTtyZXR1cm4obnVsbD09PShzPW51bGw9PT0ocj1udWxsPT1pP3ZvaWQgMDppLnNoZWV0KXx8dm9pZCAwPT09cj92b2lkIDA6ci5jc3NSdWxlcyl8fHZvaWQgMD09PXM/dm9pZCAwOnMubGVuZ3RoKT9pLnNoZWV0Om8/by5zaGVldDphP2Euc2hlZXQ6bnVsbH1zdHlsZVNoZWV0VG9Dc3NSdWxlc0FycmF5KGUpe3JldHVybiBBcnJheS5mcm9tKChudWxsPT1lP3ZvaWQgMDplLmNzc1J1bGVzKXx8W10pfXNlbGVjdG9yc0Zyb21TZWxlY3RvcihlKXtjb25zdCBuPXRoaXMuZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoZSksdD1BcnJheS5mcm9tKG4pLm1hcCgoZT0+e2NvbnN0IG49W10sdD1bXSxyPVtdO2Zvcig7ZS5wYXJlbnROb2RlOyl7bGV0IHM9ZS50YWdOYW1lLnRvTG93ZXJDYXNlKCk7QXJyYXkuZnJvbShlLnBhcmVudE5vZGUuY2hpbGRyZW4pLmZpbHRlcigobj0+bi50YWdOYW1lPT09ZS50YWdOYW1lKSkubGVuZ3RoPjEmJihzKz1gOm50aC1jaGlsZCgke0FycmF5LmZyb20oZS5wYXJlbnROb2RlLmNoaWxkTm9kZXMpLmluZGV4T2YoZSkrMX0pYCksbi51bnNoaWZ0KHMpLHQudW5zaGlmdChzKSxyLnB1c2goW24uam9pbihcIiA+IFwiKSx0LmpvaW4oXCIgXCIpXSksZT1lLnBhcmVudE5vZGV9cmV0dXJuIHIuZmxhdCgpfSkpLmZsYXQoKTtyZXR1cm5bLi4ubmV3IFNldCh0KV19fWZ1bmN0aW9uIHYoZSl7Y29uc3Qgbj1lLm1hdGNoKC8oPzpmdW5jdGlvblxccypbXihdKlxcKChbXildKilcXCkpLyl8fGUubWF0Y2goLyg/OlxcYig/OmNvbnN0fGxldHx2YXIpXFxzKlxcdytcXHMqPVxccyooPzpmdW5jdGlvbik/XFxzKlxcKChbXildKilcXCkpLyl8fGUubWF0Y2goLz1cXHMrKFteKV0qKT0+Lyk7cmV0dXJuIG4/KG5bMV18fG5bMl18fG5bM118fG5bNF0pLnNwbGl0KFwiLFwiKS5tYXAoKGU9Pntjb25zdCBuPWUudHJpbSgpLnNwbGl0KFwiPVwiKSx0PW4ubGVuZ3RoPjE/blsxXS5yZXBsYWNlKC9bJ1wiXS9nLFwiXCIpLnRyaW0oKTp2b2lkIDA7cmV0dXJue25hbWU6blswXS50cmltKCksZGVmYXVsdFZhbHVlOnR9fSkpOltdfXZhciBOPW4uWjUsYj1uLnlTLFI9bi5OdCxDPW4ualgsTD1uLlVTLE89bi5IZyxTPW4uZXAsdz1uLmd1LEc9bi5Hcyx4PW4uU2M7ZXhwb3J0e04gYXMgQ1NTSGVscCxiIGFzIGNvbmNhdFJlZ2V4LFIgYXMgZXNjYXBlUmVnRXhwLEMgYXMgZ2V0RnVuY3Rpb25QYXJhbXMsTCBhcyBpc0NhbGxlZFdpdGhOb0FyZ3MsTyBhcyBweXRob24sUyBhcyByZW1vdmVDc3NDb21tZW50cyx3IGFzIHJlbW92ZUh0bWxDb21tZW50cyxHIGFzIHJlbW92ZUpTQ29tbWVudHMseCBhcyByZW1vdmVXaGl0ZVNwYWNlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuLy8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbl9fd2VicGFja19yZXF1aXJlX18ubSA9IF9fd2VicGFja19tb2R1bGVzX187XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwidmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mID8gKG9iaikgPT4gKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKSA6IChvYmopID0+IChvYmouX19wcm90b19fKTtcbnZhciBsZWFmUHJvdG90eXBlcztcbi8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLy8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLy8gbW9kZSAmIDE2OiByZXR1cm4gdmFsdWUgd2hlbiBpdCdzIFByb21pc2UtbGlrZVxuLy8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuX193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcblx0aWYobW9kZSAmIDEpIHZhbHVlID0gdGhpcyh2YWx1ZSk7XG5cdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG5cdGlmKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUpIHtcblx0XHRpZigobW9kZSAmIDQpICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcblx0XHRpZigobW9kZSAmIDE2KSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHZhbHVlO1xuXHR9XG5cdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG5cdHZhciBkZWYgPSB7fTtcblx0bGVhZlByb3RvdHlwZXMgPSBsZWFmUHJvdG90eXBlcyB8fCBbbnVsbCwgZ2V0UHJvdG8oe30pLCBnZXRQcm90byhbXSksIGdldFByb3RvKGdldFByb3RvKV07XG5cdGZvcih2YXIgY3VycmVudCA9IG1vZGUgJiAyICYmIHZhbHVlOyB0eXBlb2YgY3VycmVudCA9PSAnb2JqZWN0JyAmJiAhfmxlYWZQcm90b3R5cGVzLmluZGV4T2YoY3VycmVudCk7IGN1cnJlbnQgPSBnZXRQcm90byhjdXJyZW50KSkge1xuXHRcdE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGN1cnJlbnQpLmZvckVhY2goKGtleSkgPT4gKGRlZltrZXldID0gKCkgPT4gKHZhbHVlW2tleV0pKSk7XG5cdH1cblx0ZGVmWydkZWZhdWx0J10gPSAoKSA9PiAodmFsdWUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGRlZik7XG5cdHJldHVybiBucztcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5mID0ge307XG4vLyBUaGlzIGZpbGUgY29udGFpbnMgb25seSB0aGUgZW50cnkgY2h1bmsuXG4vLyBUaGUgY2h1bmsgbG9hZGluZyBmdW5jdGlvbiBmb3IgYWRkaXRpb25hbCBjaHVua3Ncbl9fd2VicGFja19yZXF1aXJlX18uZSA9IChjaHVua0lkKSA9PiB7XG5cdHJldHVybiBQcm9taXNlLmFsbChPYmplY3Qua2V5cyhfX3dlYnBhY2tfcmVxdWlyZV9fLmYpLnJlZHVjZSgocHJvbWlzZXMsIGtleSkgPT4ge1xuXHRcdF9fd2VicGFja19yZXF1aXJlX18uZltrZXldKGNodW5rSWQsIHByb21pc2VzKTtcblx0XHRyZXR1cm4gcHJvbWlzZXM7XG5cdH0sIFtdKSk7XG59OyIsIi8vIFRoaXMgZnVuY3Rpb24gYWxsb3cgdG8gcmVmZXJlbmNlIGFzeW5jIGNodW5rc1xuX193ZWJwYWNrX3JlcXVpcmVfXy51ID0gKGNodW5rSWQpID0+IHtcblx0Ly8gcmV0dXJuIHVybCBmb3IgZmlsZW5hbWVzIGJhc2VkIG9uIHRlbXBsYXRlXG5cdHJldHVybiBcIlwiICsgY2h1bmtJZCArIFwiLVwiICsge1wiXzE0OGVcIjpcImIyYWM5NWU3YWUyNTllOGE0MThhXCIsXCJfNzk3N1wiOlwiZGI4NDliOWI3MDY1NTczZDg3MmVcIixcIm5vZGVfbW9kdWxlc19wbnBtX25vZGUtZmV0Y2hfMl83XzBfbm9kZV9tb2R1bGVzX25vZGUtZmV0Y2hfYnJvd3Nlcl9qc1wiOlwiOTM3ZTM2MmUwMTRiNzgwMTljNzZcIixcIl9iZjc5XCI6XCIwMjA3YzI2YjRiMGJlMDVlNjgwMlwiLFwiXzBlOTlcIjpcIjlkNGNiN2Q1NjI4ZDMzYTljYjI0XCIsXCJfOGI0OVwiOlwiMGI3MTcwOTA3NzlkMmVmYTE1NDVcIixcIl9jMDRjXCI6XCIwNGRjMzM2OTlmNjE4ZDIyYjFmYlwiLFwiXzhlMzVcIjpcIjgwODgyMmZiYzBlNGNhOWY4MGZmXCIsXCJfM2Y3NFwiOlwiZGUyZWUzMWUzYTkxNWU0YzcyMmJcIn1bY2h1bmtJZF0gKyBcIi5qc1wiO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCJ2YXIgaW5Qcm9ncmVzcyA9IHt9O1xudmFyIGRhdGFXZWJwYWNrUHJlZml4ID0gXCJAZnJlZWNvZGVjYW1wL2Jyb3dzZXItc2NyaXB0czpcIjtcbi8vIGxvYWRTY3JpcHQgZnVuY3Rpb24gdG8gbG9hZCBhIHNjcmlwdCB2aWEgc2NyaXB0IHRhZ1xuX193ZWJwYWNrX3JlcXVpcmVfXy5sID0gKHVybCwgZG9uZSwga2V5LCBjaHVua0lkKSA9PiB7XG5cdGlmKGluUHJvZ3Jlc3NbdXJsXSkgeyBpblByb2dyZXNzW3VybF0ucHVzaChkb25lKTsgcmV0dXJuOyB9XG5cdHZhciBzY3JpcHQsIG5lZWRBdHRhY2g7XG5cdGlmKGtleSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHMgPSBzY3JpcHRzW2ldO1xuXHRcdFx0aWYocy5nZXRBdHRyaWJ1dGUoXCJzcmNcIikgPT0gdXJsIHx8IHMuZ2V0QXR0cmlidXRlKFwiZGF0YS13ZWJwYWNrXCIpID09IGRhdGFXZWJwYWNrUHJlZml4ICsga2V5KSB7IHNjcmlwdCA9IHM7IGJyZWFrOyB9XG5cdFx0fVxuXHR9XG5cdGlmKCFzY3JpcHQpIHtcblx0XHRuZWVkQXR0YWNoID0gdHJ1ZTtcblx0XHRzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuXHRcdHNjcmlwdC5jaGFyc2V0ID0gJ3V0Zi04Jztcblx0XHRzY3JpcHQudGltZW91dCA9IDEyMDtcblx0XHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5uYykge1xuXHRcdFx0c2NyaXB0LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIF9fd2VicGFja19yZXF1aXJlX18ubmMpO1xuXHRcdH1cblx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKFwiZGF0YS13ZWJwYWNrXCIsIGRhdGFXZWJwYWNrUHJlZml4ICsga2V5KTtcblxuXHRcdHNjcmlwdC5zcmMgPSB1cmw7XG5cdH1cblx0aW5Qcm9ncmVzc1t1cmxdID0gW2RvbmVdO1xuXHR2YXIgb25TY3JpcHRDb21wbGV0ZSA9IChwcmV2LCBldmVudCkgPT4ge1xuXHRcdC8vIGF2b2lkIG1lbSBsZWFrcyBpbiBJRS5cblx0XHRzY3JpcHQub25lcnJvciA9IHNjcmlwdC5vbmxvYWQgPSBudWxsO1xuXHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHR2YXIgZG9uZUZucyA9IGluUHJvZ3Jlc3NbdXJsXTtcblx0XHRkZWxldGUgaW5Qcm9ncmVzc1t1cmxdO1xuXHRcdHNjcmlwdC5wYXJlbnROb2RlICYmIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cdFx0ZG9uZUZucyAmJiBkb25lRm5zLmZvckVhY2goKGZuKSA9PiAoZm4oZXZlbnQpKSk7XG5cdFx0aWYocHJldikgcmV0dXJuIHByZXYoZXZlbnQpO1xuXHR9XG5cdHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgdW5kZWZpbmVkLCB7IHR5cGU6ICd0aW1lb3V0JywgdGFyZ2V0OiBzY3JpcHQgfSksIDEyMDAwMCk7XG5cdHNjcmlwdC5vbmVycm9yID0gb25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHNjcmlwdC5vbmVycm9yKTtcblx0c2NyaXB0Lm9ubG9hZCA9IG9uU2NyaXB0Q29tcGxldGUuYmluZChudWxsLCBzY3JpcHQub25sb2FkKTtcblx0bmVlZEF0dGFjaCAmJiBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG59OyIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL2pzL1wiOyIsIi8vIG5vIGJhc2VVUklcblxuLy8gb2JqZWN0IHRvIHN0b3JlIGxvYWRlZCBhbmQgbG9hZGluZyBjaHVua3Ncbi8vIHVuZGVmaW5lZCA9IGNodW5rIG5vdCBsb2FkZWQsIG51bGwgPSBjaHVuayBwcmVsb2FkZWQvcHJlZmV0Y2hlZFxuLy8gW3Jlc29sdmUsIHJlamVjdCwgUHJvbWlzZV0gPSBjaHVuayBsb2FkaW5nLCAwID0gY2h1bmsgbG9hZGVkXG52YXIgaW5zdGFsbGVkQ2h1bmtzID0ge1xuXHRcInB5dGhvbi13b3JrZXJcIjogMFxufTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXy5mLmogPSAoY2h1bmtJZCwgcHJvbWlzZXMpID0+IHtcblx0XHQvLyBKU09OUCBjaHVuayBsb2FkaW5nIGZvciBqYXZhc2NyaXB0XG5cdFx0dmFyIGluc3RhbGxlZENodW5rRGF0YSA9IF9fd2VicGFja19yZXF1aXJlX18ubyhpbnN0YWxsZWRDaHVua3MsIGNodW5rSWQpID8gaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdIDogdW5kZWZpbmVkO1xuXHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSAhPT0gMCkgeyAvLyAwIG1lYW5zIFwiYWxyZWFkeSBpbnN0YWxsZWRcIi5cblxuXHRcdFx0Ly8gYSBQcm9taXNlIG1lYW5zIFwiY3VycmVudGx5IGxvYWRpbmdcIi5cblx0XHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSkge1xuXHRcdFx0XHRwcm9taXNlcy5wdXNoKGluc3RhbGxlZENodW5rRGF0YVsyXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZih0cnVlKSB7IC8vIGFsbCBjaHVua3MgaGF2ZSBKU1xuXHRcdFx0XHRcdC8vIHNldHVwIFByb21pc2UgaW4gY2h1bmsgY2FjaGVcblx0XHRcdFx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IChpbnN0YWxsZWRDaHVua0RhdGEgPSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSBbcmVzb2x2ZSwgcmVqZWN0XSkpO1xuXHRcdFx0XHRcdHByb21pc2VzLnB1c2goaW5zdGFsbGVkQ2h1bmtEYXRhWzJdID0gcHJvbWlzZSk7XG5cblx0XHRcdFx0XHQvLyBzdGFydCBjaHVuayBsb2FkaW5nXG5cdFx0XHRcdFx0dmFyIHVybCA9IF9fd2VicGFja19yZXF1aXJlX18ucCArIF9fd2VicGFja19yZXF1aXJlX18udShjaHVua0lkKTtcblx0XHRcdFx0XHQvLyBjcmVhdGUgZXJyb3IgYmVmb3JlIHN0YWNrIHVud291bmQgdG8gZ2V0IHVzZWZ1bCBzdGFja3RyYWNlIGxhdGVyXG5cdFx0XHRcdFx0dmFyIGVycm9yID0gbmV3IEVycm9yKCk7XG5cdFx0XHRcdFx0dmFyIGxvYWRpbmdFbmRlZCA9IChldmVudCkgPT4ge1xuXHRcdFx0XHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGluc3RhbGxlZENodW5rcywgY2h1bmtJZCkpIHtcblx0XHRcdFx0XHRcdFx0aW5zdGFsbGVkQ2h1bmtEYXRhID0gaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdO1xuXHRcdFx0XHRcdFx0XHRpZihpbnN0YWxsZWRDaHVua0RhdGEgIT09IDApIGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGVycm9yVHlwZSA9IGV2ZW50ICYmIChldmVudC50eXBlID09PSAnbG9hZCcgPyAnbWlzc2luZycgOiBldmVudC50eXBlKTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmVhbFNyYyA9IGV2ZW50ICYmIGV2ZW50LnRhcmdldCAmJiBldmVudC50YXJnZXQuc3JjO1xuXHRcdFx0XHRcdFx0XHRcdGVycm9yLm1lc3NhZ2UgPSAnTG9hZGluZyBjaHVuayAnICsgY2h1bmtJZCArICcgZmFpbGVkLlxcbignICsgZXJyb3JUeXBlICsgJzogJyArIHJlYWxTcmMgKyAnKSc7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3IubmFtZSA9ICdDaHVua0xvYWRFcnJvcic7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3IudHlwZSA9IGVycm9yVHlwZTtcblx0XHRcdFx0XHRcdFx0XHRlcnJvci5yZXF1ZXN0ID0gcmVhbFNyYztcblx0XHRcdFx0XHRcdFx0XHRpbnN0YWxsZWRDaHVua0RhdGFbMV0oZXJyb3IpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmwodXJsLCBsb2FkaW5nRW5kZWQsIFwiY2h1bmstXCIgKyBjaHVua0lkLCBjaHVua0lkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cbn07XG5cbi8vIG5vIHByZWZldGNoaW5nXG5cbi8vIG5vIHByZWxvYWRlZFxuXG4vLyBubyBITVJcblxuLy8gbm8gSE1SIG1hbmlmZXN0XG5cbi8vIG5vIG9uIGNodW5rcyBsb2FkZWRcblxuLy8gaW5zdGFsbCBhIEpTT05QIGNhbGxiYWNrIGZvciBjaHVuayBsb2FkaW5nXG52YXIgd2VicGFja0pzb25wQ2FsbGJhY2sgPSAocGFyZW50Q2h1bmtMb2FkaW5nRnVuY3Rpb24sIGRhdGEpID0+IHtcblx0dmFyIFtjaHVua0lkcywgbW9yZU1vZHVsZXMsIHJ1bnRpbWVdID0gZGF0YTtcblx0Ly8gYWRkIFwibW9yZU1vZHVsZXNcIiB0byB0aGUgbW9kdWxlcyBvYmplY3QsXG5cdC8vIHRoZW4gZmxhZyBhbGwgXCJjaHVua0lkc1wiIGFzIGxvYWRlZCBhbmQgZmlyZSBjYWxsYmFja1xuXHR2YXIgbW9kdWxlSWQsIGNodW5rSWQsIGkgPSAwO1xuXHRpZihjaHVua0lkcy5zb21lKChpZCkgPT4gKGluc3RhbGxlZENodW5rc1tpZF0gIT09IDApKSkge1xuXHRcdGZvcihtb2R1bGVJZCBpbiBtb3JlTW9kdWxlcykge1xuXHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1vcmVNb2R1bGVzLCBtb2R1bGVJZCkpIHtcblx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYocnVudGltZSkgdmFyIHJlc3VsdCA9IHJ1bnRpbWUoX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdH1cblx0aWYocGFyZW50Q2h1bmtMb2FkaW5nRnVuY3Rpb24pIHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uKGRhdGEpO1xuXHRmb3IoO2kgPCBjaHVua0lkcy5sZW5ndGg7IGkrKykge1xuXHRcdGNodW5rSWQgPSBjaHVua0lkc1tpXTtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oaW5zdGFsbGVkQ2h1bmtzLCBjaHVua0lkKSAmJiBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0pIHtcblx0XHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXVswXSgpO1xuXHRcdH1cblx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSAwO1xuXHR9XG5cbn1cblxudmFyIGNodW5rTG9hZGluZ0dsb2JhbCA9IHNlbGZbXCJ3ZWJwYWNrQ2h1bmtfZnJlZWNvZGVjYW1wX2Jyb3dzZXJfc2NyaXB0c1wiXSA9IHNlbGZbXCJ3ZWJwYWNrQ2h1bmtfZnJlZWNvZGVjYW1wX2Jyb3dzZXJfc2NyaXB0c1wiXSB8fCBbXTtcbmNodW5rTG9hZGluZ0dsb2JhbC5mb3JFYWNoKHdlYnBhY2tKc29ucENhbGxiYWNrLmJpbmQobnVsbCwgMCkpO1xuY2h1bmtMb2FkaW5nR2xvYmFsLnB1c2ggPSB3ZWJwYWNrSnNvbnBDYWxsYmFjay5iaW5kKG51bGwsIGNodW5rTG9hZGluZ0dsb2JhbC5wdXNoLmJpbmQoY2h1bmtMb2FkaW5nR2xvYmFsKSk7IiwiLy8gV2UgaGF2ZSB0byBzcGVjaWZ5IHB5b2RpZGUuanMgYmVjYXVzZSB3ZSBuZWVkIHRvIGltcG9ydCB0aGF0IGZpbGUgKG5vdCAubWpzKVxuLy8gYW5kICdpbXBvcnQnIGRlZmF1bHRzIHRvIC5tanNcbmltcG9ydCB7IGxvYWRQeW9kaWRlLCB0eXBlIFB5b2RpZGVJbnRlcmZhY2UgfSBmcm9tICdweW9kaWRlL3B5b2RpZGUuanMnO1xuaW1wb3J0IHBrZyBmcm9tICdweW9kaWRlL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgdHlwZSB7IFB5UHJveHksIFB5dGhvbkVycm9yIH0gZnJvbSAncHlvZGlkZS9mZmknO1xuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICdAZnJlZWNvZGVjYW1wL2N1cnJpY3VsdW0taGVscGVycyc7XG5cbmNvbnN0IGN0eDogV29ya2VyICYgdHlwZW9mIGdsb2JhbFRoaXMgPSBzZWxmIGFzIHVua25vd24gYXMgV29ya2VyICZcbiAgdHlwZW9mIGdsb2JhbFRoaXM7XG5cbmxldCBweW9kaWRlOiBQeW9kaWRlSW50ZXJmYWNlIHwgbnVsbCA9IG51bGw7XG5cbmludGVyZmFjZSBQeXRob25SdW5FdmVudCBleHRlbmRzIE1lc3NhZ2VFdmVudCB7XG4gIGRhdGE6IHtcbiAgICB0eXBlOiAncnVuJztcbiAgICBjb2RlOiB7XG4gICAgICBjb250ZW50czogc3RyaW5nO1xuICAgICAgZWRpdGFibGVDb250ZW50czogc3RyaW5nO1xuICAgICAgb3JpZ2luYWw6IHsgW2lkOiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgICB9O1xuICB9O1xufVxuXG5pbnRlcmZhY2UgTGlzdGVuUmVxdWVzdEV2ZW50IGV4dGVuZHMgTWVzc2FnZUV2ZW50IHtcbiAgZGF0YToge1xuICAgIHR5cGU6ICdsaXN0ZW4nO1xuICB9O1xufVxuXG5pbnRlcmZhY2UgQ2FuY2VsRXZlbnQgZXh0ZW5kcyBNZXNzYWdlRXZlbnQge1xuICBkYXRhOiB7XG4gICAgdHlwZTogJ2NhbmNlbCc7XG4gICAgdmFsdWU6IG51bWJlcjtcbiAgfTtcbn1cblxuLy8gU2luY2UgbWVzc2FnZXMgYXJlIGJ1ZmZlcmVkLCBpdCBuZWVkcyB0byBiZSBwb3NzaWJsZSB0byBkaXNjYXJkICdydW4nXG4vLyBtZXNzYWdlcy4gT3RoZXJ3aXNlIG1lc3NhZ2VzIGNvdWxkIGJ1aWxkIHVwIHdoaWxlIHRoZSB3b3JrZXIgaXMgYnVzeSAoZm9yXG4vLyBleGFtcGxlLCB3aGlsZSBsb2FkaW5nIHB5b2RpZGUpIGFuZCB0aGUgd29yayB3b3VsZCB0cnkgdG8gcHJvY2VzcyB0aGVtIGluXG4vLyBzZXF1ZW5jZS4gSW5zdGVhZCwgaXQgd2lsbCBpZ25vcmUgbWVzc2FnZXMgdW50aWwgaXQgcmVjZWl2ZXMgYSAnbGlzdGVuJ1xuLy8gbWVzc2FnZSBhbmQgd2lsbCBpbmZvcm0gdGhlIGNsaWVudCBldmVyeSB0aW1lIGl0IHN0YXJ0cyBpZ25vcmluZyBtZXNzYWdlcy5cbmxldCBpZ25vcmVSdW5NZXNzYWdlcyA9IHRydWU7XG5cbmFzeW5jIGZ1bmN0aW9uIHNldHVwUHlvZGlkZSgpIHtcbiAgaWYgKHB5b2RpZGUpIHJldHVybiBweW9kaWRlO1xuXG4gIHB5b2RpZGUgPSBhd2FpdCBsb2FkUHlvZGlkZSh7XG4gICAgLy8gVE9ETzogaG9zdCB0aGlzIG91cnNlbHZlc1xuICAgIGluZGV4VVJMOiBgaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L3B5b2RpZGUvdiR7cGtnLnZlcnNpb259L2Z1bGwvYFxuICB9KTtcblxuICAvLyBXZSBmcmVlemUgdGhpcyB0byBwcmV2ZW50IGxlYXJuZXJzIGZyb20gZ2V0dGluZyB0aGUgd29ya2VyIGludG8gYVxuICAvLyB3ZWlyZCBzdGF0ZS4gTk9URTogdGhpcyBoYXMgdG8gY29tZSBhZnRlciBweW9kaWRlIGlzIGxvYWRlZCwgYmVjYXVzZVxuICAvLyBweW9kaWRlIG1vZGlmaWVzIHNlbGYgd2hpbGUgbG9hZGluZy5cbiAgT2JqZWN0LmZyZWV6ZShzZWxmKTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgcHlvZGlkZS5GUy53cml0ZUZpbGUoXG4gICAgJy9ob21lL3B5b2RpZGUvYXN0X2hlbHBlcnMucHknLFxuICAgIGhlbHBlcnMucHl0aG9uLmFzdEhlbHBlcnMsXG4gICAge1xuICAgICAgZW5jb2Rpbmc6ICd1dGY4J1xuICAgIH1cbiAgKTtcblxuICBpZ25vcmVSdW5NZXNzYWdlcyA9IHRydWU7XG4gIHBvc3RNZXNzYWdlKHsgdHlwZTogJ3N0b3BwZWQnIH0pO1xufVxuXG5mdW5jdGlvbiByZXNldFB5b2RpZGUoKSB7XG4gIGlmIChweW9kaWRlKSBweW9kaWRlID0gbnVsbDtcbiAgdm9pZCBzZXR1cFB5b2RpZGUoKTtcbn1cblxudm9pZCBzZXR1cFB5b2RpZGUoKTtcblxuZnVuY3Rpb24gaW5pdFJ1blB5dGhvbigpIHtcbiAgaWYgKCFweW9kaWRlKSB0aHJvdyBuZXcgRXJyb3IoJ3B5b2RpZGUgbm90IGxvYWRlZCcpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG4gIGNvbnN0IHN0ciA9IHB5b2RpZGUuZ2xvYmFscy5nZXQoJ3N0cicpIGFzICh4OiB1bmtub3duKSA9PiBzdHJpbmc7XG5cbiAgZnVuY3Rpb24gcHJpbnQoLi4uYXJnczogdW5rbm93bltdKSB7XG4gICAgY29uc3QgdGV4dCA9IGFyZ3MubWFwKHggPT4gc3RyKHgpKS5qb2luKCcgJyk7XG4gICAgcG9zdE1lc3NhZ2UoeyB0eXBlOiAncHJpbnQnLCB0ZXh0IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5wdXQodGV4dDogc3RyaW5nKSB7XG4gICAgLy8gVE9ETzogc2VuZCB1bmlxdWUgaWRzIHRvIHRoZSBtYWluIHRocmVhZCBhbmQgdGhlIHNlcnZpY2Ugd29ya2VyLCBzbyB3ZVxuICAgIC8vIGNhbiBoYXZlIG11bHRpcGxlIGNvbmN1cnJlbnQgaW5wdXQgcmVxdWVzdHMuXG4gICAgcG9zdE1lc3NhZ2UoeyB0eXBlOiAnaW5wdXQnLCB0ZXh0IH0pO1xuICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXF1ZXN0Lm9wZW4oJ1BPU1QnLCAnL3B5dGhvbi9pbnRlcmNlcHQtaW5wdXQvJywgZmFsc2UpO1xuICAgIHJlcXVlc3Quc2VuZChudWxsKTtcblxuICAgIC8vIFdlIHdhbnQgdG8gcmFpc2UgYSBLZXlib2FyZEludGVycnVwdCBpZiB0aGUgdXNlciBjYW5jZWxzLiBUbyBkbyB0aGF0LFxuICAgIC8vIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIEpTIG9iamVjdCB3aXRoIHRoZSAndHlwZScgcHJvcGVydHkgc2V0IHRvXG4gICAgLy8gJ2NhbmNlbCcuIFRoZW4gdGhlIHB5dGhvbiBjb2RlIGNhbiBhY3R1YWxseSByYWlzZSB0aGUgZXhjZXB0aW9uLlxuICAgIHJldHVybiBKU09OLnBhcnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0KSBhcyB7XG4gICAgICB0eXBlOiAnbXNnJyB8ICdjYW5jZWwnO1xuICAgICAgdmFsdWU/OiBzdHJpbmc7XG4gICAgfTtcbiAgfVxuXG4gIC8vIEkgdHJpZWQgc2V0dGluZyBqc2dsb2JhbHMgaGVyZSwgdG8gcHJvdmlkZSAnaW5wdXQnIGFuZCAncHJpbnQnIHRvIHB5dGhvbixcbiAgLy8gd2l0aG91dCBoYXZpbmcgdG8gbW9kaWZ5IHRoZSBnbG9iYWwgd2luZG93IG9iamVjdC4gSG93ZXZlciwgaXQgZGlkbid0IHdvcmtcbiAgLy8gYmVjYXVzZSBweW9kaWRlIG5lZWRzIGFjY2VzcyB0byB0aGF0IG9iamVjdC4gSW5zdGVhZCwgSSB1c2VkXG4gIC8vIHJlZ2lzdGVySnNNb2R1bGUgd2hlbiBzZXR0aW5nIHVwIHJ1blB5dGhvbi5cblxuICAvLyBNYWtlIHByaW50IGF2YWlsYWJsZSB0byBweXRob25cbiAgcHlvZGlkZS5yZWdpc3RlckpzTW9kdWxlKCdqc2N1c3RvbScsIHtcbiAgICBwcmludCxcbiAgICBpbnB1dFxuICB9KTtcbiAgLy8gQ3JlYXRlIGZyZXNoIGdsb2JhbHMgZWFjaCB0aW1lIHVzZXIgY29kZSBpcyBydW4uXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGxcbiAgY29uc3QgZ2xvYmFscyA9IHB5b2RpZGUuZ2xvYmFscy5nZXQoJ2RpY3QnKSgpIGFzIFB5UHJveHk7XG4gIC8vIFNvbWUgdGVzdHMgcmVseSBvbiBfX25hbWVfXyBiZWluZyBzZXQgdG8gX19tYWluX18gYW5kIHdlIG5ldyBkaWN0cyBkbyBub3RcbiAgLy8gaGF2ZSB0aGlzIHNldCBieSBkZWZhdWx0LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG4gIGdsb2JhbHMuc2V0KCdfX25hbWVfXycsICdfX21haW5fXycpO1xuICAvLyBUaGUgcnVuUHl0aG9uIGhlbHBlciBpcyBhIHNob3J0Y3V0IGZvciBydW5uaW5nIHB5dGhvbiBjb2RlIHdpdGggb3VyXG4gIC8vIGN1c3RvbSBnbG9iYWxzLlxuICBjb25zdCBydW5QeXRob24gPSAocHlDb2RlOiBzdHJpbmcpID0+XG4gICAgcHlvZGlkZSEucnVuUHl0aG9uKHB5Q29kZSwgeyBnbG9iYWxzIH0pIGFzIHVua25vd247XG4gIHJ1blB5dGhvbihgXG4gIGltcG9ydCBqc2N1c3RvbVxuICBmcm9tIGpzY3VzdG9tIGltcG9ydCBwcmludFxuICBmcm9tIGpzY3VzdG9tIGltcG9ydCBpbnB1dFxuICBkZWYgX193cmFwKGZ1bmMpOlxuICAgIGRlZiBmbigqYXJncyk6XG4gICAgICBkYXRhID0gZnVuYygqYXJncylcbiAgICAgIGlmIGRhdGEudHlwZSA9PSAnY2FuY2VsJzpcbiAgICAgICAgcmFpc2UgS2V5Ym9hcmRJbnRlcnJ1cHQoZGF0YS52YWx1ZSlcbiAgICAgIHJldHVybiBkYXRhLnZhbHVlXG4gICAgcmV0dXJuIGZuXG4gIGlucHV0ID0gX193cmFwKGlucHV0KVxuICBgKTtcblxuICAvLyBFeHBvc2luZyBzeXMubGFzdF92YWx1ZSBjYW4gY3JlYXRlIG1lbW9yeSBsZWFrcywgc28gdGhpcyBqdXN0IHJldHVybnMgYVxuICAvLyBzdHJpbmcgaW5zdGVhZCBvZiB0aGUgYWN0dWFsIGV4Y2VwdGlvbi4gYXJnc1swXSBpcyB3aGF0IHdhcyBwYXNzZWQgdG8gdGhlXG4gIC8vIGV4Y2VwdGlvbiBjb25zdHJ1Y3Rvci4gSW4gb3VyIGNhc2UsIHRoYXQncyB0aGUgaWQgd2Ugd2FudC5cbiAgLy8gVE9ETzogSSdtIHVzaW5nICdqb2luJyB0byBtYWtlIHN1cmUgd2UncmUgbm90IGxlYWtpbmcgYSByZWZlcmVuY2UgdG8gdGhlXG4gIC8vIGV4Y2VwdGlvbi4gVGhpcyBtaWdodCBiZSBleGNlc3NpdmUsIGJ1dCBJIGRvbid0IGtub3cgZW5vdWdoIGFib3V0IHB5b2RpZGVcbiAgLy8gdG8gYmUgc3VyZS5cbiAgcnVuUHl0aG9uKGBcbiAgaW1wb3J0IHN5c1xuICBkZWYgX19nZXRfcmVzZXRfaWQoKTpcbiAgICBpZiBzeXMubGFzdF92YWx1ZSBhbmQgc3lzLmxhc3RfdmFsdWUuYXJnczpcbiAgICAgIHJldHVybiBcIlwiLmpvaW4oc3RyKHN5cy5sYXN0X3ZhbHVlLmFyZ3NbMF0pKVxuICAgIGVsc2U6XG4gICAgICByZXR1cm4gXCJcIlxuICBgKTtcbiAgcnVuUHl0aG9uKGBcbmRlZiBwcmludF9leGNlcHRpb24oKTpcbiAgICBmcm9tIGFzdF9oZWxwZXJzIGltcG9ydCBmb3JtYXRfZXhjZXB0aW9uXG4gICAgZm9ybWF0dGVkID0gZm9ybWF0X2V4Y2VwdGlvbihleGNlcHRpb249c3lzLmxhc3RfdmFsdWUsIHRyYWNlYmFjaz1zeXMubGFzdF90cmFjZWJhY2ssIGZpbGVuYW1lPVwiPGV4ZWM+XCIsIG5ld19maWxlbmFtZT1cIm1haW4ucHlcIilcbiAgICBwcmludChmb3JtYXR0ZWQpXG5gKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbFxuICBjb25zdCBwcmludEV4Y2VwdGlvbiA9IGdsb2JhbHMuZ2V0KCdwcmludF9leGNlcHRpb24nKSBhcyBQeVByb3h5ICZcbiAgICAoKCkgPT4gc3RyaW5nKTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG4gIGNvbnN0IGdldFJlc2V0SWQgPSBnbG9iYWxzLmdldCgnX19nZXRfcmVzZXRfaWQnKSBhcyBQeVByb3h5ICYgKCgpID0+IHN0cmluZyk7XG4gIHJldHVybiB7IHJ1blB5dGhvbiwgZ2V0UmVzZXRJZCwgZ2xvYmFscywgcHJpbnRFeGNlcHRpb24gfTtcbn1cblxuY3R4Lm9ubWVzc2FnZSA9IChlOiBQeXRob25SdW5FdmVudCB8IExpc3RlblJlcXVlc3RFdmVudCB8IENhbmNlbEV2ZW50KSA9PiB7XG4gIGNvbnN0IHsgZGF0YSB9ID0gZTtcbiAgaWYgKGRhdGEudHlwZSA9PT0gJ2xpc3RlbicpIHtcbiAgICBoYW5kbGVMaXN0ZW5SZXF1ZXN0KCk7XG4gIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnY2FuY2VsJykge1xuICAgIGhhbmRsZUNhbmNlbFJlcXVlc3QoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgaGFuZGxlUnVuUmVxdWVzdChkYXRhKTtcbiAgfVxufTtcblxuLy8gVGhpcyBsZXRzIHRoZSBjbGllbnQga25vdyB0aGF0IHRoZXJlIGlzIG5vdGhpbmcgdG8gY2FuY2VsLlxuZnVuY3Rpb24gaGFuZGxlQ2FuY2VsUmVxdWVzdCh7IHZhbHVlIH06IHsgdmFsdWU6IG51bWJlciB9KSB7XG4gIHBvc3RNZXNzYWdlKHsgdHlwZTogJ2lzLWFsaXZlJywgdGV4dDogdmFsdWUgfSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUxpc3RlblJlcXVlc3QoKSB7XG4gIGlnbm9yZVJ1bk1lc3NhZ2VzID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVJ1blJlcXVlc3QoZGF0YTogUHl0aG9uUnVuRXZlbnRbJ2RhdGEnXSkge1xuICB0cnkge1xuICAgIGlmIChpZ25vcmVSdW5NZXNzYWdlcykgcmV0dXJuO1xuICAgIGNvbnN0IGNvZGUgPSAoZGF0YS5jb2RlLmNvbnRlbnRzIHx8ICcnKS5zbGljZSgpO1xuICAgIC8vIFRPRE86IHVzZSByZXNldC10ZXJtaW5hbCBmb3IgY2xhcml0eT9cbiAgICBwb3N0TWVzc2FnZSh7IHR5cGU6ICdyZXNldCcgfSk7XG5cbiAgICBjb25zdCB7IHJ1blB5dGhvbiwgZ2V0UmVzZXRJZCwgZ2xvYmFscywgcHJpbnRFeGNlcHRpb24gfSA9IGluaXRSdW5QeXRob24oKTtcbiAgICAvLyB1c2UgcHlvZGlkZS5ydW5QeXRob25Bc3luYyBpZiB3ZSB3YW50IHRvcC1sZXZlbCBhd2FpdFxuICAgIHRyeSB7XG4gICAgICBydW5QeXRob24oY29kZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3QgZXJyID0gZSBhcyBQeXRob25FcnJvcjtcbiAgICAgIC8vIHRoZSBmb3JtYXR0ZWQgZXhjZXB0aW9uIGlzIHByaW50ZWQgdG8gdGhlIHRlcm1pbmFsXG4gICAgICBwcmludEV4Y2VwdGlvbigpO1xuICAgICAgLy8gYnV0IHRoZSBmdWxsIGVycm9yIGlzIGxvZ2dlZCB0byB0aGUgY29uc29sZSBmb3IgZGVidWdnaW5nXG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICBjb25zdCByZXNldElkID0gZ2V0UmVzZXRJZCgpO1xuICAgICAgLy8gVE9ETzogaWYgYSB1c2VyIHJhaXNlcyBhIEtleWJvYXJkSW50ZXJydXB0IHdpdGggYSBjdXN0b20gbWVzc2FnZSB0aGlzXG4gICAgICAvLyB3aWxsIGJlIHRyZWF0ZWQgYXMgYSByZXNldCwgdGhlIGNsaWVudCB3aWxsIHJlc2VuZCB0aGVpciBjb2RlIGFuZCB0aGlzXG4gICAgICAvLyB3aWxsIGxvb3AuIENhbiB3ZSBmaXggdGhhdD8gUGVyaGFwcyBieSB1c2luZyBhIGN1c3RvbSBleGNlcHRpb24/XG4gICAgICBpZiAoZXJyLnR5cGUgPT09ICdLZXlib2FyZEludGVycnVwdCcgJiYgcmVzZXRJZCkge1xuICAgICAgICAvLyBJZiB0aGUgY2xpZW50IHNlbmRzIGEgbG90IG9mIHJ1biBtZXNzYWdlcywgaXQncyBlYXN5IGZvciB0aGVtIHRvIGJ1aWxkXG4gICAgICAgIC8vIHVwIHdoaWxlIHRoZSB3b3JrZXIgaXMgYnVzeS4gQXMgc3VjaCwgd2UgYm90aCBpZ25vcmUgYW55IHF1ZXVlZCBydW5cbiAgICAgICAgLy8gbWVzc2FnZXMuLi5cbiAgICAgICAgaWdub3JlUnVuTWVzc2FnZXMgPSB0cnVlO1xuICAgICAgICAvLyAuLi5hbmQgdGVsbCB0aGUgY2xpZW50IHRoYXQgd2UncmUgaWdub3JpbmcgdGhlbS5cbiAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlOiAnc3RvcHBlZCcsIHRleHQ6IGdldFJlc2V0SWQoKSB9KTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZ2V0UmVzZXRJZC5kZXN0cm95KCk7XG4gICAgICBwcmludEV4Y2VwdGlvbi5kZXN0cm95KCk7XG4gICAgICBnbG9iYWxzLmRlc3Ryb3koKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUaGlzIHNob3VsZCBvbmx5IGJlIHJlYWNoIGlmIHB5b2RpZGUgY3Jhc2hlcywgYnV0IGl0J3MgaGVscGZ1bCB0byBsb2dcbiAgICAvLyB0aGUgZXJyb3IgaW4gY2FzZSBpdCdzIHNvbWV0aGluZyBlbHNlLlxuICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgdm9pZCByZXNldFB5b2RpZGUoKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbImxvYWRQeW9kaWRlIiwicGtnIiwiaGVscGVycyIsImN0eCIsInNlbGYiLCJweW9kaWRlIiwiaWdub3JlUnVuTWVzc2FnZXMiLCJzZXR1cFB5b2RpZGUiLCJpbmRleFVSTCIsImNvbmNhdCIsInZlcnNpb24iLCJPYmplY3QiLCJmcmVlemUiLCJGUyIsIndyaXRlRmlsZSIsInB5dGhvbiIsImFzdEhlbHBlcnMiLCJlbmNvZGluZyIsInBvc3RNZXNzYWdlIiwidHlwZSIsInJlc2V0UHlvZGlkZSIsImluaXRSdW5QeXRob24iLCJFcnJvciIsInN0ciIsImdsb2JhbHMiLCJnZXQiLCJwcmludCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwidGV4dCIsIm1hcCIsIngiLCJqb2luIiwiaW5wdXQiLCJyZXF1ZXN0IiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwic2VuZCIsIkpTT04iLCJwYXJzZSIsInJlc3BvbnNlVGV4dCIsInJlZ2lzdGVySnNNb2R1bGUiLCJzZXQiLCJydW5QeXRob24iLCJweUNvZGUiLCJwcmludEV4Y2VwdGlvbiIsImdldFJlc2V0SWQiLCJvbm1lc3NhZ2UiLCJlIiwiZGF0YSIsImhhbmRsZUxpc3RlblJlcXVlc3QiLCJoYW5kbGVDYW5jZWxSZXF1ZXN0IiwiaGFuZGxlUnVuUmVxdWVzdCIsIl9yZWYiLCJ2YWx1ZSIsImNvZGUiLCJjb250ZW50cyIsInNsaWNlIiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwicmVzZXRJZCIsImRlc3Ryb3kiXSwic291cmNlUm9vdCI6IiJ9