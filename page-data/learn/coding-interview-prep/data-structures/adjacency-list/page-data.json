{
    "componentChunkName": "component---src-templates-challenges-classic-show-tsx",
    "path": "/learn/coding-interview-prep/data-structures/adjacency-list",
    "result": {"data":{"challengeNode":{"challenge":{"block":"data-structures","title":"Adjacency List","description":"<section id=\"description\">\n<p>Graphs can be represented in different ways. Here we describe one way, which is called an <dfn>adjacency list</dfn>. An adjacency list is essentially a bulleted list where the left side is the node and the right side lists all the other nodes it's connected to. Below is a representation of an adjacency list.</p>\n<blockquote>Node1: Node2, Node3<br>Node2: Node1<br>Node3: Node1</blockquote>\n<p>Above is an undirected graph because <code>Node1</code> is connected to <code>Node2</code> and <code>Node3</code>, and that information is consistent with the connections <code>Node2</code> and <code>Node3</code> show. An adjacency list for a directed graph would mean each row of the list shows direction. If the above was directed, then <code>Node2: Node1</code> would mean there the directed edge is pointing from <code>Node2</code> towards <code>Node1</code>. We can represent the undirected graph above as an adjacency list by putting it within a JavaScript object.</p>\n<pre><code class=\"language-js\">var undirectedG = {\n  Node1: [\"Node2\", \"Node3\"],\n  Node2: [\"Node1\"],\n  Node3: [\"Node1\"]\n};\n</code></pre>\n<p>This can also be more simply represented as an array where the nodes just have numbers rather than string labels.</p>\n<pre><code class=\"language-js\">var undirectedGArr = [\n  [1, 2], // Node1\n  [0],    // Node2\n  [0]     // Node3\n];\n</code></pre>\n</section>","id":"587d8256367417b2b2512c77","hasEditableBoundaries":false,"instructions":"<section id=\"instructions\">\n<p>Create a social network as an undirected graph with 4 nodes/people named <code>James</code>, <code>Jill</code>, <code>Jenny</code>, and <code>Jeff</code>. There are edges/relationships between James and Jeff, Jill and Jenny, and Jeff and Jenny.</p>\n</section>","notes":null,"challengeType":1,"helpCategory":"JavaScript","videoUrl":null,"superBlock":"coding-interview-prep","translationPending":false,"forumTopicId":301620,"fields":{"blockName":"data-structures","slug":"/learn/coding-interview-prep/data-structures/adjacency-list","tests":[{"text":"<p><code>undirectedAdjList</code> should only contain four nodes.</p>","testString":"assert(Object.keys(undirectedAdjList).length === 4);"},{"text":"<p>There should be an edge between <code>Jeff</code> and <code>James</code>.</p>","testString":"assert(\n  undirectedAdjList.James.indexOf('Jeff') !== -1 &&\n    undirectedAdjList.Jeff.indexOf('James') !== -1\n);"},{"text":"<p>There should be an edge between <code>Jill</code> and <code>Jenny</code>.</p>","testString":"assert(\n  undirectedAdjList.Jill.indexOf('Jenny') !== -1 &&\n    undirectedAdjList.Jenny.indexOf('Jill') !== -1\n);"},{"text":"<p>There should be an edge between <code>Jeff</code> and <code>Jenny</code>.</p>","testString":"assert(\n  undirectedAdjList.Jeff.indexOf('Jenny') !== -1 &&\n    undirectedAdjList.Jenny.indexOf('Jeff') !== -1\n);"}]},"required":[],"usesMultifileEditor":false,"challengeFiles":[{"fileKey":"scriptjs","ext":"js","name":"script","contents":"var undirectedAdjList = {};","head":"","tail":"","editableRegionBoundaries":[],"history":["script.js"]}]}}},"pageContext":{"challengeMeta":{"blockHashSlug":"/learn/coding-interview-prep/#data-structures","dashedName":"adjacency-list","certification":"coding-interview-prep","disableLoopProtectTests":false,"disableLoopProtectPreview":false,"superBlock":"coding-interview-prep","block":"data-structures","isFirstStep":false,"template":null,"required":[],"nextBlock":"data-structures","nextChallengePath":"/learn/coding-interview-prep/data-structures/adjacency-matrix","prevChallengePath":"/learn/coding-interview-prep/data-structures/implement-heap-sort-with-a-min-heap","id":"587d8256367417b2b2512c77"},"projectPreview":{"showProjectPreview":false,"challengeData":{"challengeType":1,"challengeFiles":[{"name":"script","ext":"js","contents":"function dfs(graph, root) {\n    var stack = [];\n    var tempV;\n    var visited = [];\n    var tempVNeighbors = [];\n    stack.push(root);\n    while (stack.length > 0) {\n        tempV = stack.pop();\n        if (visited.indexOf(tempV) == -1) {\n            visited.push(tempV);\n            tempVNeighbors = graph[tempV];\n            for (var i = 0; i < tempVNeighbors.length; i++) {\n                if (tempVNeighbors[i] == 1) {\n                    stack.push(i);\n                }\n            }\n        }\n    }\n    return visited;\n}","head":"","tail":"","history":["script.js"],"fileKey":"scriptjs"}]}},"slug":"/learn/coding-interview-prep/data-structures/adjacency-list"}},
    "staticQueryHashes": ["1800977889","4268002518"]}