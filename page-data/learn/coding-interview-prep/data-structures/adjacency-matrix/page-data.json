{
    "componentChunkName": "component---src-templates-challenges-classic-show-tsx",
    "path": "/learn/coding-interview-prep/data-structures/adjacency-matrix",
    "result": {"data":{"challengeNode":{"challenge":{"block":"data-structures","title":"Adjacency Matrix","description":"<section id=\"description\">\n<p>Another way to represent a graph is to put it in an <dfn>adjacency matrix</dfn>. An <dfn>adjacency matrix</dfn> is a two-dimensional (2D) array where each nested array has the same number of elements as the outer array. In other words, it is a matrix or grid of numbers, where the numbers represent the edges.</p>\n<p><strong>Note</strong>: The numbers to the top and left of the matrix are just labels for the nodes. Inside the matrix, ones mean there exists an edge between the vertices (nodes) representing the row and column. Finally, zeros mean there is no edge or relationship.</p>\n<pre>\n    1 2 3\n  \\------\n1 | 0 1 1\n2 | 1 0 0\n3 | 1 0 0\n</pre>\n<p>Above is a very simple, undirected graph where you have three nodes, where the first node is connected to the second and third node. Below is a JavaScript implementation of the same thing.</p>\n<pre><code class=\"language-js\">var adjMat = [\n  [0, 1, 1],\n  [1, 0, 0],\n  [1, 0, 0]\n];\n</code></pre>\n<p>Unlike an adjacency list, each \"row\" of the matrix has to have the same number of elements as nodes in the graph. Here we have a three by three matrix, which means we have three nodes in our graph. A directed graph would look similar. Below is a graph where the first node has an edge pointing toward the second node, and then the second node has an edge pointing to the third node.</p>\n<pre><code class=\"language-js\">var adjMatDirected = [\n  [0, 1, 0],\n  [0, 0, 1],\n  [0, 0, 0]\n];\n</code></pre>\n<p>Graphs can also have <dfn>weights</dfn> on their edges. So far, we have <dfn>unweighted</dfn> edges where just the presence and lack of edge is binary (<code>0</code> or <code>1</code>). You can have different weights depending on your application.</p>\n</section>","id":"587d8256367417b2b2512c78","hasEditableBoundaries":false,"instructions":"<section id=\"instructions\">\n<p>Create an adjacency matrix of an undirected graph with five nodes. This matrix should be in a multi-dimensional array. These five nodes have relationships between the first and fourth node, the first and third node, the third and fifth node, and the fourth and fifth node. All edge weights are one.</p>\n</section>","notes":null,"challengeType":1,"helpCategory":"JavaScript","videoUrl":null,"superBlock":"coding-interview-prep","translationPending":false,"forumTopicId":301621,"fields":{"blockName":"data-structures","slug":"/learn/coding-interview-prep/data-structures/adjacency-matrix","tests":[{"text":"<p><code>undirectedAdjList</code> should only contain five nodes.</p>","testString":"assert(\n  adjMatUndirected.length === 5 &&\n    adjMatUndirected\n      .map(function (x) {\n        return x.length === 5;\n      })\n      .reduce(function (a, b) {\n        return a && b;\n      })\n);"},{"text":"<p>There should be an edge between the first and fourth node.</p>","testString":"assert(adjMatUndirected[0][3] === 1 && adjMatUndirected[3][0] === 1);"},{"text":"<p>There should be an edge between the first and third node.</p>","testString":"assert(adjMatUndirected[0][2] === 1 && adjMatUndirected[2][0] === 1);"},{"text":"<p>There should be an edge between the third and fifth node.</p>","testString":"assert(adjMatUndirected[2][4] === 1 && adjMatUndirected[4][2] === 1);"},{"text":"<p>There should be an edge between the fourth and fifth node.</p>","testString":"assert(adjMatUndirected[3][4] === 1 && adjMatUndirected[4][3] === 1);"}]},"required":[],"usesMultifileEditor":false,"challengeFiles":[{"fileKey":"scriptjs","ext":"js","name":"script","contents":"var adjMatUndirected = [];","head":"","tail":"","editableRegionBoundaries":[],"history":["script.js"]}]}}},"pageContext":{"challengeMeta":{"blockHashSlug":"/learn/coding-interview-prep/#data-structures","dashedName":"adjacency-matrix","certification":"coding-interview-prep","disableLoopProtectTests":false,"disableLoopProtectPreview":false,"superBlock":"coding-interview-prep","block":"data-structures","isFirstStep":false,"template":null,"required":[],"nextBlock":"data-structures","nextChallengePath":"/learn/coding-interview-prep/data-structures/incidence-matrix","prevChallengePath":"/learn/coding-interview-prep/data-structures/adjacency-list","id":"587d8256367417b2b2512c78"},"projectPreview":{"showProjectPreview":false,"challengeData":{"challengeType":1,"challengeFiles":[{"name":"script","ext":"js","contents":"function dfs(graph, root) {\n    var stack = [];\n    var tempV;\n    var visited = [];\n    var tempVNeighbors = [];\n    stack.push(root);\n    while (stack.length > 0) {\n        tempV = stack.pop();\n        if (visited.indexOf(tempV) == -1) {\n            visited.push(tempV);\n            tempVNeighbors = graph[tempV];\n            for (var i = 0; i < tempVNeighbors.length; i++) {\n                if (tempVNeighbors[i] == 1) {\n                    stack.push(i);\n                }\n            }\n        }\n    }\n    return visited;\n}","head":"","tail":"","history":["script.js"],"fileKey":"scriptjs"}]}},"slug":"/learn/coding-interview-prep/data-structures/adjacency-matrix"}},
    "staticQueryHashes": ["1800977889","4268002518"]}