{
    "componentChunkName": "component---src-templates-challenges-classic-show-tsx",
    "path": "/learn/scientific-computing-with-python/learn-string-manipulation-by-building-a-cipher/step-58",
    "result": {"data":{"challengeNode":{"challenge":{"block":"learn-string-manipulation-by-building-a-cipher","title":"Step 58","description":"<section id=\"description\">\n<p>Since your key is shorter than the text that you will have to encrypt, you will need to repeat it to generate the whole encrypted text.\nAt the beginning of your function body, declare a <code>key_index</code> variable and set it to zero.</p>\n</section>","id":"65549561463f0016876e852c","hasEditableBoundaries":true,"instructions":null,"notes":null,"challengeType":20,"helpCategory":"Python","videoUrl":null,"superBlock":"scientific-computing-with-python","translationPending":false,"forumTopicId":null,"fields":{"blockName":"learn-string-manipulation-by-building-a-cipher","slug":"/learn/scientific-computing-with-python/learn-string-manipulation-by-building-a-cipher/step-58","tests":[{"text":"<p>You should declare a variable called <code>key_index</code> at the beginning of your function body.</p>","testString":"const commentless_code = __helpers.python.removeComments(code);\nconst {function_body} = __helpers.python.getDef(commentless_code, \"vigenere\");\nassert(function_body.match(/^\\s*key_index\\s*=/));"},{"text":"<p>You should assign <code>0</code> to your <code>key_index</code> variable.</p>","testString":"const commentless_code = __helpers.python.removeComments(code);\nconst {function_body} = __helpers.python.getDef(commentless_code, \"vigenere\");   \nassert(function_body.match(/key_index\\s*=\\s*0/));"},{"text":"<p>Your code contains invalid syntax and/or invalid indentation.</p>","testString":"({test: () => assert(true) })"}]},"required":[],"usesMultifileEditor":true,"challengeFiles":[{"fileKey":"mainpy","ext":"py","name":"main","contents":"text = 'Hello Zaira'\ncustom_key = 'python'\n\ndef vigenere(message, key):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in message.lower():\n        if char == ' ':\n            encrypted_text += char\n        else:\n            index = alphabet.find(char)\n            new_index = (index + offset) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    print('plain text:', message)\n    print('encrypted text:', encrypted_text)","head":"","tail":"","editableRegionBoundaries":[0,17],"history":["main.py"]}]}}},"pageContext":{"challengeMeta":{"blockHashSlug":"/learn/scientific-computing-with-python/#learn-string-manipulation-by-building-a-cipher","dashedName":"step-58","certification":"scientific-computing-with-python","disableLoopProtectTests":false,"disableLoopProtectPreview":false,"superBlock":"scientific-computing-with-python","block":"learn-string-manipulation-by-building-a-cipher","isFirstStep":false,"template":null,"required":[],"nextBlock":"learn-string-manipulation-by-building-a-cipher","nextChallengePath":"/learn/scientific-computing-with-python/learn-string-manipulation-by-building-a-cipher/step-59","prevChallengePath":"/learn/scientific-computing-with-python/learn-string-manipulation-by-building-a-cipher/step-57","id":"65549561463f0016876e852c"},"projectPreview":{"showProjectPreview":false,"challengeData":{"challengeType":20,"challengeFiles":[{"name":"main","ext":"py","contents":"text = 'mrttaqrhknsw ih puggrur'\ncustom_key = 'happycoding'\n\ndef vigenere(message, key, direction=1):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n\n        # Append any non-letter character to the message\n        if not char.isalpha():\n            final_message += char\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n\ndef encrypt(message, key):\n    return vigenere(message, key)\n    \ndef decrypt(message, key):\n    return vigenere(message, key, -1)\n\nprint(f'\\nEncrypted text: {text}')\nprint(f'Key: {custom_key}')\ndecryption = decrypt(text, custom_key)\nprint(f'\\nDecrypted text: {decryption}\\n')","head":"","tail":"","history":["main.py"],"fileKey":"mainpy"}]}},"slug":"/learn/scientific-computing-with-python/learn-string-manipulation-by-building-a-cipher/step-58"}},
    "staticQueryHashes": ["1800977889","4268002518"]}