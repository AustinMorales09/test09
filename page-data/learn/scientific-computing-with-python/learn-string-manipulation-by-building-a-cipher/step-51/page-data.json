{
    "componentChunkName": "component---src-templates-challenges-classic-show-tsx",
    "path": "/learn/scientific-computing-with-python/learn-string-manipulation-by-building-a-cipher/step-51",
    "result": {"data":{"challengeNode":{"challenge":{"block":"learn-string-manipulation-by-building-a-cipher","title":"Step 51","description":"<section id=\"description\">\n<p>Now you should see the output again. Although this approach works, it doesn't significantly enhance the code's reusability. Repeatedly calling your function will result in the same outcome. However, functions can be declared with <em>parameters</em> to introduce versatility and customization:</p>\n<pre><code class=\"language-py\">def function_name(param_1, param_2):\n    &#x3C;code>\n</code></pre>\n<p>Parameters are variables that you can use inside your function. A function can be declared with different number of parameters. In the example above, <code>param_1</code> and <code>param_2</code> are parameters.</p>\n<p>Modify your function declaration so that it takes two parameters called <code>message</code> and <code>offset</code>.</p>\n<p>After that, you'll see an error appear in the terminal. You'll see how to solve it in the next steps.</p>\n</section>","id":"6553efd6ada3f42aa2d75448","hasEditableBoundaries":true,"instructions":null,"notes":null,"challengeType":20,"helpCategory":"Python","videoUrl":null,"superBlock":"scientific-computing-with-python","translationPending":false,"forumTopicId":null,"fields":{"blockName":"learn-string-manipulation-by-building-a-cipher","slug":"/learn/scientific-computing-with-python/learn-string-manipulation-by-building-a-cipher/step-51","tests":[{"text":"<p>Your <code>caesar</code> function should take <code>message</code> and <code>offset</code> as the parameters. Remember to separate the parameters with a comma.</p>","testString":"assert.match(code, /^def\\s+caesar\\s*\\(\\s*message\\s*,\\s*offset\\s*\\)\\s*:/m)"}]},"required":[],"usesMultifileEditor":true,"challengeFiles":[{"fileKey":"mainpy","ext":"py","name":"main","contents":"text = 'Hello Zaira'\nshift = 3\ndef caesar():\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in text.lower():\n        if char == ' ':\n            encrypted_text += char\n        else:\n            index = alphabet.find(char)\n            new_index = (index + shift) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    print('plain text:', text)\n    print('encrypted text:', encrypted_text)\n\ncaesar()","head":"","tail":"","editableRegionBoundaries":[2,4],"history":["main.py"]}]}}},"pageContext":{"challengeMeta":{"blockHashSlug":"/learn/scientific-computing-with-python/#learn-string-manipulation-by-building-a-cipher","dashedName":"step-51","certification":"scientific-computing-with-python","disableLoopProtectTests":false,"disableLoopProtectPreview":false,"superBlock":"scientific-computing-with-python","block":"learn-string-manipulation-by-building-a-cipher","isFirstStep":false,"template":null,"required":[],"nextBlock":"learn-string-manipulation-by-building-a-cipher","nextChallengePath":"/learn/scientific-computing-with-python/learn-string-manipulation-by-building-a-cipher/step-52","prevChallengePath":"/learn/scientific-computing-with-python/learn-string-manipulation-by-building-a-cipher/step-50","id":"6553efd6ada3f42aa2d75448"},"projectPreview":{"showProjectPreview":false,"challengeData":{"challengeType":20,"challengeFiles":[{"name":"main","ext":"py","contents":"text = 'mrttaqrhknsw ih puggrur'\ncustom_key = 'happycoding'\n\ndef vigenere(message, key, direction=1):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n\n        # Append any non-letter character to the message\n        if not char.isalpha():\n            final_message += char\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n\ndef encrypt(message, key):\n    return vigenere(message, key)\n    \ndef decrypt(message, key):\n    return vigenere(message, key, -1)\n\nprint(f'\\nEncrypted text: {text}')\nprint(f'Key: {custom_key}')\ndecryption = decrypt(text, custom_key)\nprint(f'\\nDecrypted text: {decryption}\\n')","head":"","tail":"","history":["main.py"],"fileKey":"mainpy"}]}},"slug":"/learn/scientific-computing-with-python/learn-string-manipulation-by-building-a-cipher/step-51"}},
    "staticQueryHashes": ["1800977889","4268002518"]}