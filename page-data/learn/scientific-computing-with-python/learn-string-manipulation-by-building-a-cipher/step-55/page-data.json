{
    "componentChunkName": "component---src-templates-challenges-classic-show-tsx",
    "path": "/learn/scientific-computing-with-python/learn-string-manipulation-by-building-a-cipher/step-55",
    "result": {"data":{"challengeNode":{"challenge":{"block":"learn-string-manipulation-by-building-a-cipher","title":"Step 55","description":"<section id=\"description\">\n<p>Currently, every single letter is always encrypted with the same letter, depending on the specified offset. What if the offset were different for each letter? That would be much more difficult to decrypt. This algorithm is referred to as the Vigenère cipher, where the offset for each letter is determined by another text, called the <em>key</em>.</p>\n<p>Start transforming your Caesar cipher into a Vigenère cipher by removing the two function calls.</p>\n</section>","id":"6553f8c570f9982e013a8886","hasEditableBoundaries":true,"instructions":null,"notes":null,"challengeType":20,"helpCategory":"Python","videoUrl":null,"superBlock":"scientific-computing-with-python","translationPending":false,"forumTopicId":null,"fields":{"blockName":"learn-string-manipulation-by-building-a-cipher","slug":"/learn/scientific-computing-with-python/learn-string-manipulation-by-building-a-cipher/step-55","tests":[{"text":"<p>You should remove your two <code>caesar()</code> function calls.</p>","testString":"({ test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    assert.isFalse(/^caesar\\s*\\(\\s*text\\s*,\\s*shift\\s*\\)/m.test(commentless_code))\n    assert.isFalse(/^caesar\\s*\\(\\s*text\\s*,\\s*13\\s*\\)/m.test(commentless_code))\n  }\n})"}]},"required":[],"usesMultifileEditor":true,"challengeFiles":[{"fileKey":"mainpy","ext":"py","name":"main","contents":"text = 'Hello Zaira'\nshift = 3\n\ndef caesar(message, offset):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in message.lower():\n        if char == ' ':\n            encrypted_text += char\n        else:\n            index = alphabet.find(char)\n            new_index = (index + offset) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    print('plain text:', message)\n    print('encrypted text:', encrypted_text)\n\ncaesar(text, shift)\ncaesar(text, 13)","head":"","tail":"","editableRegionBoundaries":[0,20],"history":["main.py"]}]}}},"pageContext":{"challengeMeta":{"blockHashSlug":"/learn/scientific-computing-with-python/#learn-string-manipulation-by-building-a-cipher","dashedName":"step-55","certification":"scientific-computing-with-python","disableLoopProtectTests":false,"disableLoopProtectPreview":false,"superBlock":"scientific-computing-with-python","block":"learn-string-manipulation-by-building-a-cipher","isFirstStep":false,"template":null,"required":[],"nextBlock":"learn-string-manipulation-by-building-a-cipher","nextChallengePath":"/learn/scientific-computing-with-python/learn-string-manipulation-by-building-a-cipher/step-56","prevChallengePath":"/learn/scientific-computing-with-python/learn-string-manipulation-by-building-a-cipher/step-54","id":"6553f8c570f9982e013a8886"},"projectPreview":{"showProjectPreview":false,"challengeData":{"challengeType":20,"challengeFiles":[{"name":"main","ext":"py","contents":"text = 'mrttaqrhknsw ih puggrur'\ncustom_key = 'happycoding'\n\ndef vigenere(message, key, direction=1):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n\n        # Append any non-letter character to the message\n        if not char.isalpha():\n            final_message += char\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n\ndef encrypt(message, key):\n    return vigenere(message, key)\n    \ndef decrypt(message, key):\n    return vigenere(message, key, -1)\n\nprint(f'\\nEncrypted text: {text}')\nprint(f'Key: {custom_key}')\ndecryption = decrypt(text, custom_key)\nprint(f'\\nDecrypted text: {decryption}\\n')","head":"","tail":"","history":["main.py"],"fileKey":"mainpy"}]}},"slug":"/learn/scientific-computing-with-python/learn-string-manipulation-by-building-a-cipher/step-55"}},
    "staticQueryHashes": ["1800977889","4268002518"]}