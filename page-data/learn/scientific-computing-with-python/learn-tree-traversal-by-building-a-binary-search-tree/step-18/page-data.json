{
    "componentChunkName": "component---src-templates-challenges-classic-show-tsx",
    "path": "/learn/scientific-computing-with-python/learn-tree-traversal-by-building-a-binary-search-tree/step-18",
    "result": {"data":{"challengeNode":{"challenge":{"block":"learn-tree-traversal-by-building-a-binary-search-tree","title":"Step 18","description":"<section id=\"description\">\n<p>Now, inside the <code>insert</code> method, you need to call the helper method <code>_insert()</code> that we defined earlier.\nHere, <code>_insert</code> has encapsulated the implementation of the insertion logic. This is useful for recursion and for keeping the implementation details hidden from the user.</p>\n<p>Delete <code>pass</code> and assign <code>self._insert(self.root, key)</code> to <code>self.root</code>.</p>\n<p>Note that:</p>\n<ul>\n<li><code>self.root</code> passes the root node of the tree as the first argument. This is the starting point for the insertion process.</li>\n<li><code>key</code>: passes the <code>key</code> value you want to insert as the second argument.</li>\n</ul>\n</section>","id":"65c4f3aee69d11dcfdbcfc00","hasEditableBoundaries":true,"instructions":null,"notes":null,"challengeType":20,"helpCategory":"Python","videoUrl":null,"superBlock":"scientific-computing-with-python","translationPending":false,"forumTopicId":null,"fields":{"blockName":"learn-tree-traversal-by-building-a-binary-search-tree","slug":"/learn/scientific-computing-with-python/learn-tree-traversal-by-building-a-binary-search-tree/step-18","tests":[{"text":"<p>You should remove the <code>pass</code> keyword from the <code>insert</code> method.</p>","testString":"({\n  test: () => {\n    assert.isFalse(\n      runPython(\n        `_Node(_code).find_class(\"BinarySearchTree\").find_function(\"insert\").has_pass()`\n      )\n    );\n  },\n});\n"},{"text":"<p>You should recursively call the <code>_insert()</code> method using <code>self._insert()</code></p>","testString":"({ test: () =>\n  {\n    const transformedCode = code.replace(/\\r/g, \"\");        \n    const ins = __helpers.python.getDef(\"\\n\"+transformedCode, \"insert\");\n    const {function_body} = ins;    \n    assert(function_body.match(/self\\._insert\\s*\\([^(]*\\)/));\n  }\n})"},{"text":"<p>You should pass <code>self.root</code> and <code>key</code> to your <code>_insert()</code> call.</p>","testString":"({ test: () =>\n  {\n    const transformedCode = code.replace(/\\r/g, \"\");        \n    const ins = __helpers.python.getDef(\"\\n\"+transformedCode, \"insert\");\n    const {function_body} = ins;    \n    assert(function_body.match(/self\\._insert\\s*\\(\\s*self\\.root\\s*,\\s*key\\s*\\)/));\n  }\n})"},{"text":"<p>You should assign the return value of your <code>_insert()</code> call to <code>self.root</code>.</p>","testString":"({ test: () =>\n  {\n    const transformedCode = code.replace(/\\r/g, \"\");        \n    const ins = __helpers.python.getDef(\"\\n\"+transformedCode, \"insert\");\n    const {function_body} = ins;    \n    assert(function_body.match(/^\\s{8}self\\.root\\s*=\\s*self\\._insert\\s*\\(\\s*self\\.root\\s*,\\s*key\\s*\\)/m));\n  }\n})"}]},"required":[],"usesMultifileEditor":true,"challengeFiles":[{"fileKey":"mainpy","ext":"py","name":"main","contents":"\nclass TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        pass\n\n","head":"","tail":"","editableRegionBoundaries":[14,30],"history":["main.py"]}]}}},"pageContext":{"challengeMeta":{"blockHashSlug":"/learn/scientific-computing-with-python/#learn-tree-traversal-by-building-a-binary-search-tree","dashedName":"step-18","certification":"scientific-computing-with-python","disableLoopProtectTests":false,"disableLoopProtectPreview":false,"superBlock":"scientific-computing-with-python","block":"learn-tree-traversal-by-building-a-binary-search-tree","isFirstStep":false,"template":null,"required":[],"nextBlock":"learn-tree-traversal-by-building-a-binary-search-tree","nextChallengePath":"/learn/scientific-computing-with-python/learn-tree-traversal-by-building-a-binary-search-tree/step-19","prevChallengePath":"/learn/scientific-computing-with-python/learn-tree-traversal-by-building-a-binary-search-tree/step-17","id":"65c4f3aee69d11dcfdbcfc00"},"projectPreview":{"showProjectPreview":false,"challengeData":{"challengeType":20,"challengeFiles":[{"name":"main","ext":"py","contents":"class TreeNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\n\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self,key):\n        self.root = self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n            node.right = self._insert(node.right, key)\n        return node\n\n    def search(self, key):\n        return self._search(self.root, key)\n\n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n\n    def delete(self, key):\n        self.root = self._delete(self.root, key)\n\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            node.key = self._min_value(node.right)\n            node.right = self._delete(node.right, node.key)\n        return node\n\n    def _min_value(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.key\n\n    def inorder_traversal(self):\n        result = []\n        self._inorder_traversal(self.root, result)\n        return result\n\n    def _inorder_traversal(self, node, result):\n        if node:\n            self._inorder_traversal(node.left, result)\n            result.append(node.key)\n            self._inorder_traversal(node.right, result)\n\n\nbst = BinarySearchTree()\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\nprint(\"Inorder traversal:\", bst.inorder_traversal())\n\nprint(\"Search for 40:\", bst.search(40))\n\nbst.delete(40)\n\nprint(\"Search for 40:\", bst.search(40))\n\nprint(\"Inorder traversal after deleting 40:\", bst.inorder_traversal())\n","head":"","tail":"","history":["main.py"],"fileKey":"mainpy"}]}},"slug":"/learn/scientific-computing-with-python/learn-tree-traversal-by-building-a-binary-search-tree/step-18"}},
    "staticQueryHashes": ["1800977889","4268002518"]}