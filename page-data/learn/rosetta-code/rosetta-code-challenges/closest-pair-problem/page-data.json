{
    "componentChunkName": "component---src-templates-challenges-classic-show-tsx",
    "path": "/learn/rosetta-code/rosetta-code-challenges/closest-pair-problem",
    "result": {"data":{"challengeNode":{"challenge":{"block":"rosetta-code-challenges","title":"Closest-pair problem","description":"<section id=\"description\">\n<p>Provide a function to find the closest two points among a set of given points in two dimensions.</p>\n<p>The straightforward solution is a $O(n^2)$ algorithm (which we can call <em>brute-force algorithm</em>); the pseudo-code (using indexes) could be simply:</p>\n<pre><strong>bruteForceClosestPair</strong> of P(1), P(2), ... P(N)\n<strong>if</strong> N &#x3C; 2 <strong>then</strong>\n  <strong>return</strong> ∞\n<strong>else</strong>\n  minDistance ← |P(1) - P(2)|\n  minPoints ← { P(1), P(2) }\n  <strong>foreach</strong> i ∈ [1, N-1]\n    <strong>foreach</strong> j ∈ [i+1, N]\n      <strong>if</strong> |P(i) - P(j)| &#x3C; minDistance <strong>then</strong>\n        minDistance ← |P(i) - P(j)|\n        minPoints ← { P(i), P(j) }\n      <strong>endif</strong>\n    <strong>endfor</strong>\n  <strong>endfor</strong>\n  <strong>return</strong> minDistance, minPoints\n<strong>endif</strong>\n</pre>\n<p>A better algorithm is based on the recursive divide and conquer approach, which is $O(n\\log n)$ a pseudo-code could be:</p>\n<pre><strong>closestPair</strong> of (xP, yP)\n  where xP is P(1) .. P(N) sorted by x coordinate, and\n  yP is P(1) .. P(N) sorted by y coordinate (ascending order)\n<strong>if</strong> N ≤ 3 <strong>then</strong>\n  <strong>return</strong> closest points of xP using brute-force algorithm\n<strong>else</strong>\n  xL ← points of xP from 1 to ⌈N/2⌉\n  xR ← points of xP from ⌈N/2⌉+1 to N\n  xm ← xP(⌈N/2⌉)<sub>x</sub>\n  yL ← { p ∈ yP : p<sub>x</sub> ≤ xm }\n  yR ← { p ∈ yP : p<sub>x</sub> > xm }\n  (dL, pairL) ← closestPair of (xL, yL)\n  (dR, pairR) ← closestPair of (xR, yR)\n  (dmin, pairMin) ← (dR, pairR)\n  <strong>if</strong> dL &#x3C; dR <strong>then</strong>\n    (dmin, pairMin) ← (dL, pairL)\n  <strong>endif</strong>\n  yS ← { p ∈ yP : |xm - p<sub>x</sub>| &#x3C; dmin }\n  nS ← number of points in yS\n  (closest, closestPair) ← (dmin, pairMin)\n  <strong>for</strong> i <strong>from</strong> 1 <strong>to</strong> nS - 1\n    k ← i + 1\n    <strong>while</strong> k ≤ nS <strong>and</strong> yS(k)<sub>y</sub> - yS(i)<sub>y</sub> &#x3C; dmin\n      <strong>if</strong> |yS(k) - yS(i)| &#x3C; closest <strong>then</strong>\n        (closest, closestPair) ← (|yS(k) - yS(i)|, {yS(k), yS(i)})\n      <strong>endif</strong>\n      k ← k + 1\n    <strong>endwhile</strong>\n  <strong>endfor</strong>\n  <strong>return</strong> closest, closestPair\n<strong>endif</strong>\n</pre>\n<p>For the input, expect the argument to be an array of <code>Point</code> objects with <code>x</code> and <code>y</code> members set to numbers. Return an object containing the key:value pairs for <code>distance</code> and <code>pair</code> (the pair of two closest points).</p>\n<p>For example <code>getClosestPair</code> with input array <code>points</code>:</p>\n<pre><code class=\"language-js\">const points = [\n  new Point(1, 2),\n  new Point(3, 3),\n  new Point(2, 2)\n];\n</code></pre>\n<p>Would return:</p>\n<pre><code class=\"language-js\">{\n  distance: 1,\n  pair: [\n    {\n      x: 1,\n      y: 2\n    },\n    {\n      x: 2,\n      y: 2\n    }\n  ]\n}\n</code></pre>\n<p><strong>Note:</strong> Sort the <code>pair</code> array by their <code>x</code> values in incrementing order.</p>\n</section>","id":"5951a53863c8a34f02bf1bdc","hasEditableBoundaries":false,"instructions":null,"notes":null,"challengeType":1,"helpCategory":"Rosetta","videoUrl":null,"superBlock":"rosetta-code","translationPending":false,"forumTopicId":302232,"fields":{"blockName":"rosetta-code-challenges","slug":"/learn/rosetta-code/rosetta-code-challenges/closest-pair-problem","tests":[{"text":"<p><code>getClosestPair</code> should be a function.</p>","testString":"assert(typeof getClosestPair === 'function');"},{"text":"<p><code>getClosestPair(points1).distance</code> should be <code>0.0894096443343775</code>.</p>","testString":"assert.equal(getClosestPair(points1).distance, answer1.distance);"},{"text":"<p><code>getClosestPair(points1).pair</code> should be <code>[ { x: 7.46489, y: 4.6268 }, { x: 7.46911, y: 4.71611 } ]</code>.</p>","testString":"assert.deepEqual(\n  JSON.parse(JSON.stringify(getClosestPair(points1))).pair,\n  answer1.pair\n);"},{"text":"<p><code>getClosestPair(points2).distance</code> should be <code>65.06919393998976</code>.</p>","testString":"assert.equal(getClosestPair(points2).distance, answer2.distance);"},{"text":"<p><code>getClosestPair(points2).pair</code> should be <code>[ { x: 37134, y: 1963 }, { x: 37181, y: 2008 } ]</code>.</p>","testString":"assert.deepEqual(\n  JSON.parse(JSON.stringify(getClosestPair(points2))).pair,\n  answer2.pair\n);"},{"text":"<p><code>getClosestPair(points3).distance</code> should be <code>6754.625082119658</code>.</p>","testString":"assert.equal(getClosestPair(points3).distance, answer3.distance);"},{"text":"<p><code>getClosestPair(points3).pair</code> should be <code>[ { x: 46817, y: 64975 }, { x: 48953, y: 58567 } ]</code>.</p>","testString":"assert.deepEqual(\n  JSON.parse(JSON.stringify(getClosestPair(points3))).pair,\n  answer3.pair\n);"}]},"required":[],"usesMultifileEditor":false,"challengeFiles":[{"fileKey":"scriptjs","ext":"js","name":"script","contents":"const Point = function(x, y) {\n  this.x = x;\n  this.y = y;\n};\nPoint.prototype.getX = function() {\n  return this.x;\n};\nPoint.prototype.getY = function() {\n  return this.y;\n};\n\nfunction getClosestPair(pointsArr) {\n\n  return true;\n}","head":"","tail":"const points1 = [\n    new Point(0.748501, 4.09624),\n    new Point(3.00302, 5.26164),\n    new Point(3.61878,  9.52232),\n    new Point(7.46911,  4.71611),\n    new Point(5.7819,   2.69367),\n    new Point(2.34709,  8.74782),\n    new Point(2.87169,  5.97774),\n    new Point(6.33101,  0.463131),\n    new Point(7.46489,  4.6268),\n    new Point(1.45428,  0.087596)\n];\n\nconst answer1 = {\n  distance: 0.0894096443343775,\n  pair: [\n    {\n      x: 7.46489,\n      y: 4.6268\n    },\n    {\n      x: 7.46911,\n      y: 4.71611\n    }\n  ]\n};\n\nconst points2 = [\n  new Point(37100, 13118),\n  new Point(37134, 1963),\n  new Point(37181, 2008),\n  new Point(37276, 21611),\n  new Point(37307, 9320)\n];\n\nconst answer2 = {\n  distance: 65.06919393998976,\n  pair: [\n    {\n      x: 37134,\n      y: 1963\n    },\n    {\n      x: 37181,\n      y: 2008\n    }\n  ]\n};\n\nconst points3 = [\n  new Point(16910, 54699),\n  new Point(14773, 61107),\n  new Point(95547, 45344),\n  new Point(95951, 17573),\n  new Point(5824, 41072),\n  new Point(8769, 52562),\n  new Point(21182, 41881),\n  new Point(53226, 45749),\n  new Point(68180, 887),\n  new Point(29322, 44017),\n  new Point(46817, 64975),\n  new Point(10501, 483),\n  new Point(57094, 60703),\n  new Point(23318, 35472),\n  new Point(72452, 88070),\n  new Point(67775, 28659),\n  new Point(19450, 20518),\n  new Point(17314, 26927),\n  new Point(98088, 11164),\n  new Point(25050, 56835),\n  new Point(8364, 6892),\n  new Point(37868, 18382),\n  new Point(23723, 7701),\n  new Point(55767, 11569),\n  new Point(70721, 66707),\n  new Point(31863, 9837),\n  new Point(49358, 30795),\n  new Point(13041, 39744),\n  new Point(59635, 26523),\n  new Point(25859, 1292),\n  new Point(1551, 53890),\n  new Point(70316, 94479),\n  new Point(48549, 86338),\n  new Point(46413, 92747),\n  new Point(27186, 50426),\n  new Point(27591, 22655),\n  new Point(10905, 46153),\n  new Point(40408, 84202),\n  new Point(52821, 73520),\n  new Point(84865, 77388),\n  new Point(99819, 32527),\n  new Point(34404, 75657),\n  new Point(78457, 96615),\n  new Point(42140, 5564),\n  new Point(62175, 92342),\n  new Point(54958, 67112),\n  new Point(4092, 19709),\n  new Point(99415, 60298),\n  new Point(51090, 52158),\n  new Point(48953, 58567)\n];\n\nconst answer3 = {\n  distance: 6754.625082119658,\n  pair: [\n    {\n      x: 46817,\n      y: 64975\n    },\n    {\n      x: 48953,\n      y: 58567\n    }\n  ]\n}","editableRegionBoundaries":[],"history":["script.js"]}]}}},"pageContext":{"challengeMeta":{"blockHashSlug":"/learn/rosetta-code/#rosetta-code-challenges","dashedName":"closest-pair-problem","certification":"rosetta-code","disableLoopProtectTests":true,"disableLoopProtectPreview":false,"superBlock":"rosetta-code","block":"rosetta-code-challenges","isFirstStep":false,"template":null,"required":[],"nextBlock":"rosetta-code-challenges","nextChallengePath":"/learn/rosetta-code/rosetta-code-challenges/combinations","prevChallengePath":"/learn/rosetta-code/rosetta-code-challenges/circles-of-given-radius-through-two-points","id":"5951a53863c8a34f02bf1bdc"},"projectPreview":{"showProjectPreview":false,"challengeData":{"challengeType":1,"challengeFiles":[{"name":"script","ext":"js","contents":"function ZigZagMatrix(n) {\n  const mtx = [];\n  for (let i = 0; i < n; i++) {\n    mtx[i] = [];\n  }\n\n  let i = 1;\n  let j = 1;\n  for (let e = 0; e < n * n; e++) {\n    mtx[i - 1][j - 1] = e;\n    if ((i + j) % 2 === 0) {\n      // Even stripes\n      if (j < n) j++;\n      else i += 2;\n      if (i > 1) i--;\n    } else {\n      // Odd stripes\n      if (i < n) i++;\n      else j += 2;\n      if (j > 1) j--;\n    }\n  }\n  return mtx;\n}","head":"","tail":"const zm1 = [[0]];\nconst zm2 = [[0, 1], [2, 3]];\nconst zm5 = [\n  [0, 1, 5, 6, 14],\n  [2, 4, 7, 13, 15],\n  [3, 8, 12, 16, 21],\n  [9, 11, 17, 20, 22],\n  [10, 18, 19, 23, 24]\n];","history":["script.js"],"fileKey":"scriptjs"}]}},"slug":"/learn/rosetta-code/rosetta-code-challenges/closest-pair-problem"}},
    "staticQueryHashes": ["1800977889","4268002518"]}